<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>SmartWealth Navigator - Enhanced Financial Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
     <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' cdn.tailwindcss.com cdn.plot.ly cdn.jsdelivr.net tfnwwpksieluzvxqdiiq.supabase.co; style-src 'self' 'unsafe-inline' fonts.googleapis.com fonts.gstatic.com; font-src 'self' fonts.gstatic.com; img-src 'self' static.wixstatic.com data:; connect-src 'self' tfnwwpksieluzvxqdiiq.supabase.co https://tfnwwpksieluzvxqdiiq.supabase.co; object-src 'none'; base-uri 'self'; form-action 'self';">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="./plotly.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* Base Styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f5f7fa;
            color: #374151;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            min-width: 100vw;
            overflow-x: hidden;

        }
        /* Garamond for Headers */
        h1, h2, h3, h4, .header-font {
            font-family: 'EB Garamond', serif;
            color: #111827;
            font-weight: bold;
        }
        h1 { font-size: 1.8em; }
        h2 { font-size: 1.5em; }
        h3 { font-size: 1.2em; color: #333; }
        h4 { font-size: 1.1em; }

        /* Main Container */
        .main-container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 1.5rem 2rem;
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.07);
        }

        /* Header */
        header {
            display: flex;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #e5e7eb;
            flex-wrap: wrap;
        }
        header img {
            height: 72px;
            margin-right: 15px;
            border-radius: 8px;
            object-fit: contain;
        }
        header h1 {
            color: #4f46e5;
            margin: 0;
            flex-grow: 1;
            font-size: 2.2em;
            line-height: 1.2;
        }

        /* Header Buttons */
        header button {
            margin-left: 10px;
            padding: 0.6rem 1.2rem;
            background-color: #4f46e5;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
        }
        header button#uploadButton { background-color: #059669; }
        header button:hover { background-color: #4338ca; }
        header button#uploadButton:hover { background-color: #047857; }
        #fileInput { display: none; }

        /* Grid Layout */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-bottom: 25px;
        }

        /* Dashboard Cards */
        .dashboard-card {
            background: #fff;
            padding: 1.5rem;
            border-radius: 10px;
            /* Updated Shadow for more prominence */
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            /* Slightly darker border */
            border: 1px solid #d1d5db; /* Using a slightly darker gray than #e5e7eb */
            display: flex;
            flex-direction: column;
            min-height: 160px;
        }

        /* Card Headers */
        .card-header {
            font-family: 'Inter', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            color: #374151;
            margin: -1.5rem -1.5rem 1.25rem -1.5rem;
            padding: 0.75rem 1.5rem;
            border-bottom: 1px solid #e5e7eb;
            background-color: #f9fafb;
            border-radius: 10px 10px 0 0;
        }
        .dashboard-card h3 {
             margin: 0 0 1rem 0;
             padding: 0; border: none; background: none;
        }

        .card-content { flex-grow: 1; font-size: 0.95em; }
        .card-content p { margin-bottom: 0.6rem; }
        .card-content p strong { font-weight: 500; color: #1f2937; margin-right: 5px; }

        /* Chart Card Specifics */
        .chart-card {
            min-height: 400px;
            overflow: hidden;
        }
        .chart-container-div {
            min-height: 400px; /* Keep this height */
            width: 100%; /* Keep width 100% */
            flex-grow: 1; /* Allow it to grow in flex container */
            display: flex; /* Keep flex display for centering */
            align-items: center; /* Keep centering */
            justify-content: center; /* Keep centering */
            padding: 15px; /* Keep padding */
            box-sizing: border-box; /* Keep box-sizing */
            overflow: hidden; /* Keep overflow hidden */
            /* Ensure no specific Plotly width/height overrides from parent */
            position: relative; /* Add relative positioning if needed for Plotly */
        }

            #googleSignInButton {
        background-color: #4285F4; /* Google blue */
        color: white;
        border: none;
        padding: 10px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        margin-right: 10px;
    }

    #googleSignInButton:hover {
        background-color: #3367D6;
    }

        /* Ratio Bar Styles */
        .ratio-item { margin-bottom: 12px; }
        .ratio-label { display: block; font-weight: 500; margin-bottom: 3px; font-size: 0.9em; color: #4b5563; }
        .ratio-value { display: inline-block; margin-bottom: 5px; font-size: 1.1em; font-weight: 600; color: #1f2937; }
        .ratio-bar-container { background-color: #e5e7eb; border-radius: 4px; overflow: hidden; height: 8px; width: 100%; }
        .ratio-bar { height: 100%; width: 0%; transition: width 0.5s ease-in-out; border-radius: 4px; }
        /* Define colors based on status */
        .ratio-bar.savings-rate { background-color: #ef4444; }
        .ratio-bar.savings-rate.ok { background-color: #f59e0b; }
        .ratio-bar.savings-rate.good { background-color: #10b981; }
        .ratio-bar.emergency-coverage { background-color: #ef4444; }
        .ratio-bar.emergency-coverage.ok { background-color: #f59e0b; }
        .ratio-bar.emergency-coverage.good { background-color: #10b981; }
        .ratio-bar.dti-ratio { background-color: #10b981; }
        .ratio-bar.dti-ratio.warning { background-color: #f59e0b; }
        .ratio-bar.dti-ratio.high { background-color: #ef4444; }

         /* Debt Table Styles */
        #debtsTable {
            width: 100%;
            margin-top: 10px;
            border-collapse: collapse;
            border: 1px solid #d1d5db; /* Add a light outer border */
            border-radius: 8px; /* Optional: soften corners */
            overflow: hidden; /* Helps with border-radius */
        }
        /* Shared styles for headers and data cells */
        #debtsTable th, #debtsTable td {
            padding: 8px 12px; /* Increased padding slightly for better spacing */
            border-bottom: 1px solid #e5e7eb; /* Keep bottom border between rows */
            border-right: 1px solid #e5e7eb; /* Add vertical borders between columns */
            font-size: 0.9em; /* Keep same font size for both headers and data */
            /* Remove default text-align here to control per column/header */
        }
        /* Remove right border from the last column */
        #debtsTable th:last-child,
        #debtsTable td:last-child {
            border-right: none;
        }
        /* Remove bottom border from the last row */
        #debtsTable tbody tr:last-child td {
             border-bottom: none;
        }


        /* Header styles */
        #debtsTable th {
            font-weight: 700; /* Make headers bold */
            color: #374151; /* Set header color */
            background-color: #f9fafb;
            text-align: left; /* Default header alignment (keep this) */
            cursor: pointer; /* Indicate clickable for popups */
        }
        /* Align specific headers right to match data */
         #debtsTable th.balance-header,
         #debtsTable th.min-pmt-header {
             text-align: right;
         }

        /* Data cell default alignment (most columns left, normal weight) */
        #debtsTable td {
            text-align: left;
            font-weight: normal;
        }

        /* Specific data column styling for alignment and bolding (set by JS adding these classes) */
        #debtsTable td.balance-col {
             text-align: right; /* Align Balance data right */
             font-weight: 700; /* Make Balance data bold */
        }
         #debtsTable td.rate-col {
             /* text-align: left; is default td alignment */
             font-weight: 700; /* Make Rate data bold */
         }
         #debtsTable td.min-pmt-col {
             text-align: right; /* Align Min. Payment data right */
             font-weight: 700; /* Make Min. Payment data bold */
         }

        /* Debt Table Styles */
        #debtsTable { /* ... existing styles ... */ }
        #debtsTable th, #debtsTable td { /* ... existing styles ... */ }
        #debtsTable th {
            font-weight: 500;
            color: #6b7280;
            background-color: #f9fafb;
            text-align: left; /* Default header alignment (keep this) */
            cursor: pointer;
        }
        /* --- ADD THESE NEW RULES --- */
        #debtsTable th.balance-header {
            text-align: right; /* Align Balance header right */
        }
        #debtsTable th.min-pmt-header {
            text-align: right; /* Align Min. Pmt header right */
        }
        /* --- END NEW RULES --- */
        #debtsTable tr:last-child td { /* ... existing styles ... */ }
        #debtsTable td { /* ... existing styles ... */ }
        #debtsTable td.balance-col { /* ... existing styles ... */ }
        #debtsTable td.rate-col { /* ... existing styles ... */ }
        #debtsTable td.min-pmt-col { /* ... existing styles ... */ }
        
        /* Progress Bar Styles */
        .progress-bar-container { background-color: #e5e7eb; border-radius: 6px; overflow: hidden; height: 20px; margin-top: 5px; margin-bottom: 10px; }
        .progress-bar { background-color: #4f46e5; height: 100%; width: 0%; transition: width 0.5s ease-in-out; text-align: center; color: white; font-size: 0.8em; line-height: 20px; font-weight: 500; }
        .goal-status { font-weight: 500; color: #1f2937; }

        /* Recommendations List Styles */
        #recommendationsList { list-style: none; padding-left: 0; margin-top: 10px; }
        #recommendationsList li { margin-bottom: 10px; line-height: 1.6; font-family: 'Inter', sans-serif; font-size: 0.95em; padding-left: 1.5em; position: relative; }
        #recommendationsList li::before { content: '✓'; color: #10b981; position: absolute; left: 0; font-weight: bold; }
        #recommendationsList li.warning::before { content: '!'; color: #f59e0b; }
        #recommendationsList li.critical::before { content: '!!'; color: #ef4444; }

        /* Modals */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); padding-top: 60px; }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 25px; border: 1px solid #888; width: 80%; max-width: 700px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); }
        .close-button { color: #aaa; float: right; font-size: 32px; line-height: 1; font-weight: bold; cursor: pointer; }
        .close-button:hover, .close-button:focus { color: black; text-decoration: none; }

        /* Loading / Error / Initial Messages */
        #loadingSpinner, #errorMessage {
             display: none;
             position: fixed;
             top: 0; left: 0;
             width: 100%; height: 100%;
             z-index: 1050;
             background-color: rgba(255, 255, 255, 0.95);
             align-items: center;
             justify-content: center;
             padding: 1rem;
        }
         #errorMessage > div {
             background-color: #fee2e2;
             border: 1px solid #f87171;
             color: #b91c1c;
             padding: 1.5rem;
             border-radius: 0.5rem;
             max-width: 600px;
             box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
             text-align: center;
         }
         #errorMessage h3 { color: #991b1b; }
         #debugInfo {
             margin-top: 1rem; margin-bottom: 1rem;
             max-height: 200px; overflow-y: auto;
             text-align: left; background-color: #f3f4f6;
             padding: 0.75rem; border-radius: 0.375rem;
             border: 1px solid #d1d5db;
             font-size: 0.75rem;
             line-height: 1.2;
             color: #4b5563;
             white-space: pre-wrap;
             word-break: break-all;
         }
         #debugInfo strong { color: #1f2937; }
         #errorMessage button {
             background-color: #dc2626;
             color: white; padding: 0.5rem 1rem;
             border: none; border-radius: 0.375rem; cursor: pointer;
             font-size: 0.875rem; margin: 0 0.5rem;
             transition: background-color 0.2s;
         }
          #errorMessage button:hover { background-color: #b91c1c; }
          #errorMessage button.secondary-button { background-color: #d1d5db; color: #374151; }
          #errorMessage button.secondary-button:hover { background-color: #9ca3af; }

        #initialUploadPrompt { display: none; }
        #initialMessage { display: none; text-align: center; padding: 40px; font-size: 1.2em; color: #555; }
        #mainContent.hidden { display: none; }
        #mainContent { display: none; }

        /* Chat Interface Card */
        #chatInterfaceCard { display: none; }

        /* Chat Styles */
        #chatInterfaceCard { grid-column: 1 / -1; }
        .chat-container {
            display: flex; flex-direction: column; height: 550px;
            border: 1px solid #d1d5db; border-radius: 10px; overflow: hidden;
            background-color: #ffffff; box-shadow: inset 0 2px 4px rgba(0,0,0,0.03);
        }
        .chat-history {
            flex-grow: 1; padding: 1.5rem; overflow-y: auto;
            scrollbar-width: thin; scrollbar-color: #d1d5db transparent;
        }
        .chat-history::-webkit-scrollbar { width: 8px; }
        .chat-history::-webkit-scrollbar-track { background: transparent; }
        .chat-history::-webkit-scrollbar-thumb { background-color: #d1d5db; border-radius: 10px; border: 2px solid transparent; background-clip: content-box; }
        .chat-history::-webkit-scrollbar-thumb:hover { background-color: #9ca3af; }

        .chat-message { margin-bottom: 1.25rem; line-height: 1.6; display: flex; }
        .chat-message.user { justify-content: flex-end; }
        .chat-message.assistant { justify-content: flex-start; }
        .message-bubble {
             border-radius: 18px; padding: 0.8rem 1.1rem; max-width: 75%;
             box-shadow: 0 2px 4px rgba(0,0,0,0.05); word-wrap: break-word;
        }
        .chat-message.user .message-bubble {
            background: linear-gradient(135deg, #4f46e5 0%, #6366f1 100%); color: white;
            border-radius: 18px 18px 4px 18px;
        }
        .chat-message.assistant .message-bubble {
            background-color: #eef2ff; color: #374151;
            border: 1px solid #e0e7ff; border-radius: 18px 18px 18px 4px;
        }
        .chat-message.system .message-bubble {
            background-color: #f3f4f6; color: #6b7280; font-size: 0.85em;
            text-align: center; max-width: 100%; border-radius: 8px;
            padding: 0.5rem 1rem; border: 1px solid #e5e7eb;
            box-shadow: none;
        }
        .chat-message.system { justify-content: center; margin: 0.5rem 0; }

        .message-sender { display: none; }

        /* Chat Status & Input */
        .chat-status {
            font-size: 0.8rem; color: #6b7280; padding: 0.5rem 1rem;
            text-align: center; height: 25px;
            background-color: #f9fafb; border-top: 1px solid #e5e7eb;
            overflow: hidden; white-space: nowrap; text-overflow: ellipsis;
        }
        .typing-indicator { display: inline-block; }
        .typing-indicator span {
            height: 8px; width: 8px; margin: 0 2px;
            background-color: #9ca3af; border-radius: 50%;
            display: inline-block;
            animation: typing 1.4s infinite ease-in-out both;
        }
        .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
        .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }
        @keyframes typing {
            0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); }
        }

        .chat-input-area {
            border-top: 1px solid #e5e7eb; padding: 0.75rem 1rem;
            background-color: #f9fafb; display: flex; align-items: center; gap: 0.75rem;
        }
        .chat-input-area textarea {
            flex-grow: 1;
            padding: 0.7rem 1rem;
            border: 1px solid #d1d5db;
            border-radius: 20px;
            resize: none; /* Prevent manual resizing */
            font-size: 0.95rem;
            line-height: 1.4;
            height: 88px; /* Set the initial height */
            min-height: 88px; /* Add minimum height to prevent it from shrinking below this */
            max-height: 120px; /* Keep the max height from JS auto-grow */
            background-color: white;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            outline: none;
            overflow-y: auto; /* Ensure scrollbar appears if text exceeds height */
        }
        .chat-input-area textarea:focus {
            border-color: #4f46e5; box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
        }
        .chat-input-area button {
            padding: 0.6rem 1rem; white-space: nowrap; flex-shrink: 0;
            border-radius: 20px;
            background-color: #4f46e5; color: white; border: none; cursor: pointer;
            transition: background-color 0.2s;
            display: flex; align-items: center; justify-content: center;
        }
        .chat-input-area button:hover { background-color: #4338ca; }
        .chat-input-area button:disabled { background-color: #a5b4fc; cursor: not-allowed; }
        .chat-input-area button svg { width: 1.25rem; height: 1.25rem; }
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0; }

        /* Responsive */
        @media (max-width: 768px) {
            header { flex-direction: column; align-items: flex-start; }
            header h1 { margin-top: 10px; font-size: 1.8em; }
            header button { margin-left: 0; margin-top: 10px; }
            .grid-container { grid-template-columns: 1fr; }
            .main-container { margin: 1rem; padding: 1rem; }
        }

        /* Responsive */
        @media (max-width: 768px) {
            /* ... existing mobile styles ... */
        }

        /* ADD THIS NEW MEDIA QUERY FOR EVEN SMALLER SCREENS */
        @media (max-width: 500px) { /* Target screens/iframes up to 500px wide */
            /* Adjust Grid Minimum Width */
            .grid-container {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* Lower the minimum width */
                gap: 15px; /* Reduce gap slightly */
            }
    </style>
</head>

<body>
    <pre id="embeddedPsrData" style="display: none;">/* EMBEDDED_JSON_DATA_HERE */</pre>

    <div id="loadingSpinner" style="display: none;">
        <div class="text-center">
            <svg class="animate-spin h-10 w-10 text-indigo-600 mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="text-gray-700 text-lg">Loading your financial dashboard...</p>
        </div>
    </div>

    <div id="errorMessage" style="display: none;">
        <div>
            <h3 class="font-bold text-xl mb-3 header-font">Error Loading Dashboard</h3>
            <p id="errorText" class="mb-4">An error occurred.</p>
            <div id="debugInfo" class="mb-4 text-xs">Debug info will appear here...</div>
            <div class="flex justify-center space-x-3 mt-4">
                <button id="retryButton" class="action-button">Retry Loading</button>
                <button id="manualEntryButton" class="secondary-button">Use Demo Data</button>
            </div>
        </div>
    </div>

     <div id="initialUploadPrompt" style="display: none; text-align: center; padding: 60px 20px;">
         <div class="main-container" style="max-width: 600px; margin: auto;">
             <h2 class="header-font text-2xl mb-4 text-gray-700">Welcome to SmartWealth Navigator</h2>
             <p class="text-gray-600 mb-6">
                 📂 Please upload your saved PSR file to view your dashboard.
             </p>
             <button id="initialUploadButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-200 ease-in-out">
                 Upload PSR
             </button>
             <p class="text-sm text-gray-500 mt-4">
                 (If you haven't generated a report yet, please complete the initial form first.)
             </p>
         </div>
     </div>

    <div id="initialMessage" style="display: none;">
        Upload a PSR JSON file or parameter to view your dashboard.
    </div>

    <div id="mainContent" class="main-container" style="display: none;">
        <header>
            <img src="https://static.wixstatic.com/media/c3283f_a9271d9818ba414994d98950da749489~mv2.jpg" alt="SmartWealth Navigator Logo">
            <h1>SmartWealth Navigator</h1>
            {/* Keep fileInput hidden for potential demo/fallback if needed later, but it's not the primary flow */}
             <input type="file" id="fileInput" accept=".json" style="display: none;"> {/* Ensure hidden */}

            {/* Drive Authentication Buttons */}
            <button id="googleSignInButton" style="display: none;">Sign in with Google</button> {/* Initially hidden */}
            <button id="googleSignOutButton" style="display: none;">Sign Out</button> {/* Initially hidden */}

            {/* Drive File Management Buttons (initially hidden) */}
            <button id="loadFromDriveButton" style="display: none;">Load from Drive</button>
            <button id="saveToDriveButton" style="display: none;">Save to Drive</button> {/* Renamed/Replaced Save button */}

            {/* Optional: Keep a local download button as fallback/alternative if desired */}
             <button id="downloadLocalButton" style="display: none;">Download Local PSR</button> {/* Initially hidden */}

        </header>

        <div class="grid-container">
            <div class="dashboard-card">
                <h3 class="card-header">Quick Summary</h3>
                <div class="card-content">
                    <p><strong>User:</strong> <span id="userName">N/A</span></p>
                    <p><strong>Age:</strong> <span id="age">N/A</span></p>
                    <p><strong>Total Monthly Income:</strong> <span id="totalIncome">N/A</span></p>
                    <p><strong>Total Monthly Expenses:</strong> <span id="totalExpenses">N/A</span></p>
                    <p><strong>Monthly Net Flow:</strong> <span id="netFlow">N/A</span></p>
                </div>
            </div>
            <div class="dashboard-card" id="ratiosCard">
                <h3 class="card-header">Key Financial Ratios</h3>
                <div class="card-content">
                    <div class="ratio-item">
                        <span class="ratio-label cursor-pointer" data-desc="Income kept, not spent.">Savings Rate</span>
                        <span class="ratio-value" id="savingsRateValue">N/A</span>
                        <div class="ratio-bar-container"><div class="ratio-bar savings-rate" id="savingsRateBar"></div></div>
                    </div>
                    <div class="ratio-item">
                        <span class="ratio-label cursor-pointer" data-desc="Months cash covers bills.">Emergency Fund Coverage</span>
                        <span class="ratio-value" id="emergencyCoverageValue">N/A</span>
                        <div class="ratio-bar-container"><div class="ratio-bar emergency-coverage" id="emergencyCoverageBar"></div></div>
                    </div>
                    <div class="ratio-item">
                        <span class="ratio-label cursor-pointer" data-desc="Income used for debts.">Debt to Income (DTI)</span>
                        <span class="ratio-value" id="dtiRatioValue">N/A</span>
                        <div class="ratio-bar-container"><div class="ratio-bar dti-ratio" id="dtiRatioBar"></div></div>
                        <p style="font-size: 0.8em; color: #666;">(Using min. payments)</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="grid-container">
            <div class="dashboard-card">
                <h3 class="card-header">Savings Overview</h3>
                <div class="card-content">
                    <p><strong>Emergency Savings:</strong> <span id="emergencySavings">N/A</span></p>
                    <p><strong>General Savings:</strong> <span id="currentSavings">N/A</span></p>
                    <p><strong>Retirement Fund:</strong> <span id="retirementFund">N/A</span></p>
                </div>
            </div>
            <div class="dashboard-card" id="goalsCard">
                <h3 class="card-header cursor-pointer" data-desc="Distance to rainy day target.">Savings Goals Progress</h3>
                <div class="card-content">
                    <div id="emergencyGoalDisplay" style="display: none;">
                        <p><strong>Emergency Fund Goal:</strong> <span class="goal-status">N/A</span></p>
                        <div class="progress-bar-container"><div class="progress-bar" id="emergencyProgressBar"></div></div>
                    </div>
                    <div id="purchaseGoalDisplay" style="margin-top: 15px; display: none;">
                        <p><strong data-desc="Saved toward big buy.">Purchase Goal (<span id="purchaseGoalName">N/A</span>):</strong> <span class="goal-status">N/A</span></p>
                        <div class="progress-bar-container"><div class="progress-bar" id="purchaseProgressBar"></div></div>
                    </div>
                    <p id="noGoalsMessage" style="display: none;" class="text-gray-500 italic">
                        No specific savings goals identified.
                    </p>
                </div>
            </div>
        </div>

        <div class="grid-container">
            <div class="dashboard-card chart-card">
                <h3 class="card-header cursor-pointer" data-desc="Where income comes from.">Income Breakdown</h3>
                <div id="incomeChart" class="chart-container-div">
                    <p class="text-center text-gray-500 pt-10"></p>
                </div>
            </div>
            <div class="dashboard-card chart-card">
                <h3 class="card-header cursor-pointer" data-desc="Where money goes.">Expense Breakdown</h3>
                <div id="expenseChart" class="chart-container-div">
                    <p class="text-center text-gray-500 pt-10"></p>
                </div>
            </div>
        </div>

        <div class="grid-container">
            <div class="dashboard-card">
                <h3 class="card-header">Recommendations</h3>
                <div class="card-content">
                    <ul id="recommendationsList">
                        <li>Loading recommendations...</li>
                    </ul>
                </div>
            </div>
                                   <div class="dashboard-card">
                <h3 class="card-header">AI Analysis Summary</h3>
                <div class="card-content">
                    <div id="aiAnalysis" class="prose prose-sm max-w-none mb-4" style="white-space: pre-wrap;">
                        Loading analysis...
                    </div>
                    <button onclick="openModal('progressModal')" class="text-indigo-600 hover:underline text-sm font-medium">
                        View Full Progress History
                    </button>
                    <button id="saveSummaryBtn" class="bg-indigo-600 text-white text-sm font-medium px-3 py-1 rounded mt-2">
                        Save Summary to Report
                    </button>
                </div>
            </div>
        </div>

        <div class="grid-container">
            <div class="dashboard-card" id="debtsCard">
                <h3 class="card-header">Debt Overview</h3>
                <div class="card-content overflow-x-auto">
                    <table id="debtsTable">
                      <thead>
                            <tr>
                                <th>Type</th>
                                <th class="balance-header" data-desc="Total amount currently owed on this debt.">Balance</th> 
                                <th data-desc="Annual interest rate for this debt.">Rate (%)</th>
                                <th class="min-pmt-header" data-desc="Minimum monthly payment required for this debt.">Min. Pmt</th> 
                            </tr>
                        </thead>

                        <tbody>
                            <tr><td colspan="4" class="text-center p-4 text-gray-500">Loading debt data...</td></tr>
                        </tbody>
                    </table>
                    <p style="margin-top: 10px;"><strong data-desc="All debts owed.">Total Debt Balance:</strong> <span id="totalDebtBalance" class="font-semibold">N/A</span></p>
                    <p><strong data-desc="Minimum due monthly.">Total Min. Payments:</strong> <span id="totalMinPayments" class="font-semibold">N/A</span></p>
                </div>
            </div>
            <div class="dashboard-card">
                <h3 class="card-header">Financial Tools & Goals</h3>
                <div class="card-content">
                    <p><strong>Financial Tools:</strong> <span id="financialTools">N/A</span></p>
                    <p><strong>Challenges:</strong> <span id="challenges">N/A</span></p>
                    <p><strong>Upcoming Purchase Goal Detail:</strong> <span id="purchaseGoals">N/A</span></p>
                </div>
            </div>
        </div>

           <section id="chatInterfaceCard" class="dashboard-card" style="display: none;">
            <!-- MODIFIED HEADER WITH FLEX AND BUTTON -->
            <h3 class="card-header flex items-center justify-between">
                <span>Ask SmartWealth AI</span>
                <button id="generateAnalysisBtn" class="bg-green-600 hover:bg-green-700 text-white text-sm font-medium px-3 py-1 rounded">
                     Generate New Analysis
                </button>
            </h3>
            <!-- END MODIFIED HEADER -->
            <div class="chat-container">
                <div class="chat-history" id="chatHistory">
                    </div>
                <div class="chat-status flex justify-between items-center px-4" id="chatStatusContainer">
                 <span>
                     Tier: <strong id="chatTierDisplay">-</strong> |
                     Model: <span id="chatModelDisplay" class="text-xs">-</span>
                 </span>
                 <span id="chatThinkingIndicator" style="display: none; margin-left: auto; margin-right: auto;">
                     <div class="typing-indicator"><span style="background-color: #4f46e5;"></span><span style="background-color: #4f46e5;"></span><span style="background-color: #4f46e5;"></span></div> Thinking...
                 </span>
                 <span class="ml-auto"> Usage: <strong id="chatUsageDisplay">- / -</strong>
                 </span>
            </div>
            <!-- THIS IS THE CHAT INPUT AREA -->
            <div class="chat-input-area">
                <textarea id="chatInput" placeholder="Ask about your finances..." rows="1" disabled></textarea>
                <button id="chatSendButton" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">
                        <path d="M3.105 3.105a1.5 1.5 0 011.995-.04l8 4a1.5 1.5 0 010 2.87l-8 4a1.5 1.5 0 01-1.995-.04L1.6 13.89a1.5 1.5 0 01-.04-1.995l3-4a1.5 1.5 0 010-1.79l-3-4a1.5 1.5 0 01.04-1.995l1.5-1.5z" />
                    </svg>
                    <span class="sr-only">Send</span>
                </button>
            </div>
            <!-- END OF CHAT INPUT AREA -->
            </div> <!-- This closes the chat-container div -->
        </section>

        <footer class="text-center text-gray-500 text-sm py-6 mt-4 border-t border-gray-200">
            <p>SmartWealth Navigator © 2025 | Built by Socialeap™️</p>
            <p>Consult with a qualified financial advisor for personalized advice.</p>
        </footer>
    </div>

    <div id="progressModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('progressModal')">&times;</span>
            <h2>User Progress History</h2>
            <div id="progressContent" style="white-space: pre-wrap;">Loading history...</div>
        </div>
    </div>

    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('infoModal')">&times;</span>
            <p id="infoModalText" style="margin:0;"></p>
        </div>
    </div>

<script>
    // Ensure hidden if elements missing - this is already good, but rely on JS to manage
    // if(chatInterfaceCard) chatInterfaceCard.style.display = 'none';

    // --- Globals ---
    let dashboardData = {}; // Holds the main data object
    let chatMessages = []; // Holds chat history for API calls
    // Note: CHAT_MODEL is effectively determined by the backend based on tier,
    // but defining it here might be useful for frontend logic if needed later.
    // For now, rely on backend.
    const CHAT_MODEL = 'determined_by_backend'; // Placeholder

    const plotlyConfig = {
        displaylogo: false,
        responsive: true, // Added responsive config
        modeBarButtonsToRemove: ['sendDataToCloud', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale2d', 'resetScale2d', 'hoverClosestPie', 'toggleSpikelines', 'hoverCompareCartesian']
    };

    let currentUserId = null;
    let effectiveTier = 'basic'; // Default to basic
    let initialUsageInfo = null; // To store fetched usage/limit info for initial UI setup

    // --- Supabase Client (CONFIGURE THESE) ---
    // **IMPORTANT:** Ensure these are correct and your Supabase project is configured
    // with RLS policies that allow anon key reads on 'users' for fetchInitialUsage
    // and service key access in your Edge Function.
    const SUPABASE_URL = 'https://tfnwwpksieluzvxqdiiq.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRmbnd3cGtzaWVsdXp2eHFkaWlxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ1ODQ3MjgsImV4cCI6MjA2MDE2MDcyOH0.xbtjiQ65vCggjj35qtlCZ0S5mJa4muSZcHXhaU4qvrE';
    let supabase = null; // Initialize later

        // --- Google Drive Integration Constants ---
    const GOOGLE_CLIENT_ID = '351536963710-k1tqdl2v2ddnnb1hgda4r4gm40kpu2sa.apps.googleusercontent.com'; // Your Google Cloud Client ID
    // Scopes needed: Accessing userinfo (for display), reading/writing Drive files created by this app
    const GOOGLE_SCOPES = 'https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/drive.file';
    const PSR_MIME_TYPE = 'application/json'; // MIME type for your PSR file
    const PSR_FOLDER_NAME = 'SmartWealth Navigator Reports'; // Name of the folder to use in Drive

    // --- Google Drive Related Globals ---
    let googleAccessToken = null; // Store the current Google Access Token
    let googleTokenClient = null; // Store the GIS token client instance
    let googleUser = null; // Store basic user info (name, etc.)

    // --- Cached DOM Elements ---
    // Declare variables here, cache in DOMContentLoaded
    let loadingSpinner, errorMessageElement, mainContentElement, initialMessageElement, errorTextElement, debugInfoElement, fileInput, initialUploadPrompt, chatInterfaceCardElement;

    // --- Utility Functions ---
    function getSafe(fn, defaultVal = 'N/A') {
        try {
            const value = fn();
            // More robust check for empty/null/undefined/NaN/Infinity
            if (value === null || value === undefined || String(value).trim() === '' || (typeof value === 'number' && !isFinite(value))) {
                 return defaultVal;
            }
            return value;
        } catch (e) {
            // console.warn("getSafe caught error:", e.message); // Log getSafe errors if needed
            return defaultVal;
        }
    }

    function formatCurrency(value, hideNA = false) {
        const number = Number(getSafe(() => value, NaN)); // Use getSafe internally
        if (isNaN(number) || !isFinite(number)) return hideNA ? '' : 'N/A';
        return number.toLocaleString('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 0, maximumFractionDigits: 0 });
    }

    function formatPercentage(value, decimals = 1) {
         const number = Number(getSafe(() => value, NaN)); // Use getSafe internally
        if (isNaN(number) || !isFinite(number)) return 'N/A';
        return number.toLocaleString(undefined, { style: 'percent', minimumFractionDigits: decimals, maximumFractionDigits: decimals });
    }

    function updateElementText(id, value, formatter) {
        const element = document.getElementById(id);
        if (element) {
            try {
                const formattedValue = formatter ? formatter(value) : (value !== null && value !== undefined && String(value).trim() !== '' ? String(value) : 'N/A');
                element.textContent = formattedValue;
            } catch (e) {
                console.error(`Error formatting/updating text for element ID ${id}:`, e);
                element.textContent = 'Error'; // Indicate error on the UI
            }
        } // else { console.warn(`Element with ID ${id} not found for text update.`); } // Keep console warning optional
    }

    function updateElementHTML(id, value) {
        const element = document.getElementById(id);
        if (element) {
             try {
                // Use innerHTML carefully - ensure value is trusted or sanitized
                element.innerHTML = value !== null && value !== undefined && String(value).trim() !== '' ? String(value) : '';
            } catch (e) {
                 console.error(`Error updating HTML for element ID ${id}:`, e);
                 element.textContent = 'Error'; // Fallback to text on error
            }
        } // else { console.warn(`Element with ID ${id} not found for HTML update.`); }
    }

    // Helper function to parse URL parameters
    function parseUrlParams() {
        console.log("Parsing URL parameters...");
        try {
            const params = new URLSearchParams(window.location.search);
             // Check for data=null parameter (special case)
            if (params.has('data') && params.get('data') === 'null') {
                console.warn("URL parameter 'data=null' detected. Showing initial upload prompt.");
                // This case is handled by the main DOMContentLoaded flow after parsing
                return null; // Indicates special state, not lack of params
            }
            console.log("URL parameters found and parsed.");
            return params;
        } catch (e) {
            console.error("Error parsing URL parameters:", e);
            // Return empty params or re-throw? Let's return empty to allow auth check
            return new URLSearchParams(); // Return empty params on error
        }
    }

    // Function to parse all financial data from URL parameters
    function parseDataFromUrlParams(params) {
        console.log("Attempting to parse financial data from URL params...");
        if (!params || typeof params.get !== 'function') {
             console.log("No valid URL params object provided.");
             return null;
        }

        // Helper function to get and decode parameter values
        const getParam = (key) => {
            if (!params.has(key)) return null;
            const rawValue = params.get(key);
            if (rawValue === null || rawValue === undefined) return null;
            try {
                // Replace '+' with space before decoding, then decode
                return decodeURIComponent(rawValue.replace(/\+/g, ' ')).trim();
            } catch (e) {
                console.warn(`Error decoding parameter ${key}:`, e);
                return rawValue.trim(); // Return raw value if decode fails
            }
        };

        // Helper function to parse numeric values, returns defaultValue on error/empty
        const parseNumeric = (key, defaultValue = 0) => {
             const value = getParam(key);
            if (value === null || value === undefined || value === '') return defaultValue;
            // Remove currency symbols, commas, etc. before parsing
            const cleaned = String(value).replace(/[^0-9.-]+/g, '');
            const number = parseFloat(cleaned);
             if (isNaN(number) || !isFinite(number)) {
                 console.warn(`Could not parse numeric value for key "${key}" from "${value}". Using default ${defaultValue}.`);
                 return defaultValue;
             }
            return number;
        };

        // Log key parameters for debugging
        console.log("Debugging URL parameter parsing:");
        console.log("  userName:", getParam('userName'));
        console.log("  age:", getParam('age'));
        console.log("  mainJobIncome:", getParam('mainJobIncome'));
        console.log("  housing:", getParam('housing'));
        console.log("  groceriesessentials:", getParam('groceriesessentials'));
        console.log("  creditCardDebt:", getParam('creditCardDebt'));
         console.log("  aiAnalysis:", getParam('aiAnalysis'));
         console.log("  xtl:", getParam('xtl')); // Log xtl for debug
         console.log("  userID:", getParam('userID')); // Log userID for debug

        // Construct and return the data object based on URL parameters
        // Use getSafe or default values aggressively here
        const parsedData = {
            userInput: {
                personalInfo: {
                    userName: getParam('userName'), // Keep as string
                    age: parseNumeric('age')
                },
                income: {
                    mainJobIncome: parseNumeric('mainJobIncome'),
                    secondJob: parseNumeric('secondJobIncome'),
                    otherIncome: parseNumeric('otherIncome')
                },
                expenses: {
                    housing: parseNumeric('housing'),
                    transportation: parseNumeric('transportation'),
                    utilities: parseNumeric('utilities'),
                    groceriesEssentials: parseNumeric('groceriesessentials'),
                    insurance: parseNumeric('insurance'),
                    medical: parseNumeric('medical'),
                    care: parseNumeric('care'),
                    subscriptions: parseNumeric('subscriptions'),
                    taxes: parseNumeric('taxes')
                },
                savings: {
                    emergency: parseNumeric('emergencySavings'),
                    savings: parseNumeric('currentSavings'), // Assuming 'savings' is general savings
                    retirement: parseNumeric('retirementFund'),
                    emergencyFundTarget: parseNumeric('emergencyFundTarget'), // Optional explicit target
                    monthlySavingsGoal: parseNumeric('monthlySavingsGoal') // Optional explicit monthly goal
                },
                debts: [], // Debts will be populated below
                financials: {
                    financialTools: getParam('financialTools'),
                    challenges: getParam('challenges'),
                    upcomingPurchase: getParam('upcomingPurchases')
                }
            },
            aiOutput: {
                analysis: getParam('aiAnalysis') || 'Analysis not available.',
                recommendations: getParam('recommendations') || 'Recommendations not available.',
                userProgress: getParam('userProgressHistory') || 'No progress history available.'
            },
             // Add a field to store the parsed xtl and userID if needed later, but DON'T use userID for auth here
            metadata: {
                 xtl: getParam('xtl'),
                 rawUserIdParam: getParam('userID') // Store the raw userID param value
            }
        };

        // Populate Debts Array - Check for existence and parse
        try {
             const creditCardDebt = parseNumeric('creditCardDebt');
             if (creditCardDebt > 0) {
                 parsedData.userInput.debts.push({
                     type: "Credit Card",
                     balance: creditCardDebt,
                     interestRate: parseNumeric('creditCardRate', 22.5), // Default CC rate
                     minPayment: parseNumeric('creditCardMinPayment', Math.max(creditCardDebt * 0.03, 25)) // Default min payment logic
                 });
                 console.log("Added Credit Card Debt from param:", creditCardDebt);
             }

             const bankLoans = parseNumeric('bankLoans');
             if (bankLoans > 0) {
                 parsedData.userInput.debts.push({
                     type: "Bank Loans",
                     balance: bankLoans,
                     interestRate: parseNumeric('bankLoanRate', 6.5), // Default Bank Loan rate
                     minPayment: parseNumeric('bankLoanMinPayment', Math.max(bankLoans * 0.015, 50)) // Default min payment logic
                 });
                 console.log("Added Bank Loans from param:", bankLoans);
             }

             const studentLoans = parseNumeric('studentLoanDebt');
             if (studentLoans > 0) {
                 parsedData.userInput.debts.push({
                     type: "Student Loans",
                     balance: studentLoans,
                     interestRate: parseNumeric('studentLoanRate', 5.5), // Default Student Loan rate
                     minPayment: parseNumeric('studentLoanMinPayment', Math.max(studentLoans * 0.01, 50)) // Default min payment logic
                 });
                 console.log("Added Student Loans from param:", studentLoans);
             }

             const carLoans = parseNumeric('carLoanBalance');
             if (carLoans > 0) {
                 parsedData.userInput.debts.push({
                     type: "Car Loan",
                     balance: carLoans,
                     interestRate: parseNumeric('carLoanRate', 6.0), // Default Car Loan rate
                     minPayment: parseNumeric('carLoanMinPayment', Math.max(carLoans * 0.015, 100)) // Default min payment logic
                 });
                 console.log("Added Car Loan from param:", carLoans);
             }
        } catch (e) {
             console.error("Error populating debt array:", e);
             // Continue with potentially empty or partially filled debts array
        }


        console.log("Parsed data object created from URL params:", parsedData);
        return parsedData;
    }

    // --- Debugging & Error Handling ---
    function debugURLParameters() {
        if (!debugInfoElement) return; // Check if element exists
        const params = new URLSearchParams(window.location.search);
        let paramsText = '<strong>URL Params:</strong><br>';
        if (params.toString() === '') {
            paramsText += '<span style="color:gray;">None</span><br>';
        } else {
            paramsText += '<table style="width:100%; font-size:10px; border-collapse: collapse;"><thead><tr style="background:#eee;"><th style="border:1px solid #ccc; padding: 2px;">Param</th><th style="border:1px solid #ccc; padding: 2px;">Value</th></tr></thead><tbody>';
            for (const [key, value] of params.entries()) {
                // Truncate long values for display in debug box
                const displayValue = (value && value.length > 150) ? value.substring(0, 150) + '...' : (value || '<i style="color:gray;">(empty)</i>');
                paramsText += `<tr><td style="border:1px solid #ccc; padding: 2px; word-break:break-all;">${key}</td><td style="border:1px solid #ccc; padding: 2px; word-break:break-all;">${displayValue}</td></tr>`;
            }
            paramsText += '</tbody></table>';
        }
        // Append to existing debug info safely
        const currentDebugHTML = debugInfoElement.innerHTML;
        // Add params at the top, remove old params if present
        debugInfoElement.innerHTML = paramsText + '<hr style="margin: 5px 0;">' + currentDebugHTML.replace(/^<strong>URL Params:.*?<hr style="margin: 5px 0;">/s, '');
    }

    function handleError(message, error, isAccessError = false) {
        console.error("HANDLE ERROR TRIGGERED:", message, error);

        // Ensure elements exist before manipulating (using cached elements)
        errorTextElement = errorTextElement || document.getElementById('errorText'); // Fallback if cache failed
        debugInfoElement = debugInfoElement || document.getElementById('debugInfo');
        errorMessageElement = errorMessageElement || document.getElementById('errorMessage'); // Fallback

        // Populate error details
        if (errorTextElement) {
            errorTextElement.textContent = `${message}. See details below.`;
        } else {
            console.error("Error text element not found!");
        }
        if (debugInfoElement) {
            debugInfoElement.innerHTML = ''; // Clear previous debug info first
            debugURLParameters(); // Add URL parameters FIRST
            debugInfoElement.innerHTML += `<br><strong>Error Type:</strong> ${getSafe(() => error.name, 'N/A')}`;
            debugInfoElement.innerHTML += `<br><strong>Error Message:</strong><br><span style="color:red;">${getSafe(() => error.message, 'Unknown error')}</span>`;
            if (error?.stack) {
                // Make stack trace more readable
                debugInfoElement.innerHTML += `<br><strong>Stack Trace:</strong><br><code style="font-size:10px; white-space: pre-wrap; display: block; line-height:1.2;">${error.stack.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code>`;
            }
        } else {
            console.error("Debug info element not found!");
        }

        // Manage UI visibility
        hideAllMainContentAreas(); // Hide everything first

        if (errorMessageElement) {
            errorMessageElement.style.display = 'flex'; // Use flex for centering
            console.log("Error message shown by handleError.");

             // Adjust retry/demo buttons based on error type if needed
             const retryButton = document.getElementById('retryButton');
             const manualEntryButton = document.getElementById('manualEntryButton');
             if (isAccessError) {
                 if (retryButton) retryButton.style.display = 'none'; // Retry likely won't fix invalid access
                 if (manualEntryButton) manualEntryButton.style.display = 'inline-block'; // Offer demo
             } else {
                 if (retryButton) retryButton.style.display = 'inline-block'; // Offer retry for other errors
                 if (manualEntryButton) manualEntryButton.style.display = 'inline-block'; // Offer demo as alternative
             }

        } else {
            console.error("Error message element not found! Displaying alert fallback.");
            // Fallback alert if the error UI can't be shown
            alert(`Critical Application Error:\n\n${message}\n\nDetails: ${error?.message || 'Unknown error'}`);
        }
        // Disable chat on error
        enableChatInput(false);
        setChatStatus("Error occurred", false);
         if (chatInterfaceCardElement) chatInterfaceCardElement.style.display = 'none'; // Ensure chat is hidden
    }

    // --- Demo Data ---
    function useDemoData() {
        console.log("Using Demo Data");
         // Ensure error message is hidden before processing
        hideAllMainContentAreas();
        if (loadingSpinner) loadingSpinner.style.display = 'flex'; // Show spinner briefly

        // A more complete demo data structure matching potential real data
        const demoData = {
            userInput: {
                personalInfo: { userName: "Demo User", age: 35 },
                income: { mainJobIncome: 5500, secondJob: 1200, otherIncome: 300 },
                expenses: { housing: 1800, utilities: 250, transportation: 450, groceriesEssentials: 600, insurance: 350, medical: 150, care: 100, subscriptions: 80, taxes: 1100 },
                savings: { emergency: 8000, savings: 15000, retirement: 75000, emergencyFundTarget: 15000, monthlySavingsGoal: 500 },
                debts: [
                    { type: "Credit Card", balance: 4500, interestRate: 22.5, minPayment: 150 },
                    { type: "Student Loan", balance: 25000, interestRate: 5.5, minPayment: 280 },
                    { type: "Car Loan", balance: 12000, interestRate: 6.5, minPayment: 300 }
                ],
                financials: {
                    financialTools: "Budgeting App (YNAB), Credit Monitor (Credit Karma)",
                    challenges: "Saving consistently for down payment, Reducing high-interest CC debt",
                    upcomingPurchase: "#1) House Down Payment, $25000, 24 months" // Example matching regex
                }
            },
            aiOutput: {
                analysis: "Cash flow is positive ($1120/month). Emergency fund covers ~2 months of core expenses (target is 3-6). High DTI ratio (31%) primarily due to student/car loans, but CC debt is high interest. Good retirement savings.",
                recommendations: "- Prioritize paying off the 22.5% interest credit card.\n- Aim to increase emergency fund to $10,000 (3 months expenses).\n- Continue consistent retirement contributions.\n- Review subscription expenses for potential savings.",
                userProgress: "2024-12-01: Initial report generated (Demo Data).\n2025-03-15: Credit card balance reduced by $500. Emergency fund increased by $1000."
            }
        };

        // Use a timeout to simulate loading and ensure spinner is seen briefly
        setTimeout(() => {
            dashboardData = demoData; // Set global data
            chatMessages = []; // Clear chat history when loading demo data
            console.log("Rendering demo data...");
            processAndDisplayData(dashboardData); // Process the demo data
            // Hide spinner is handled by processAndDisplayData finally block
        }, 500); // Simulate a small delay
    }

    // --- Parse XTL Parameter for Authentication ---
    function parseXtlParameter(params) {
        console.log("Parsing XTL parameter...");
        if (!params || typeof params.get !== 'function') {
             console.warn("No URL params available for XTL parsing.");
             handleInvalidAccess("Missing URL parameters."); // Treat as invalid access
             return false; // Indicate failure
        }

        const xtlParam = params.get('xtl');
        let userIdFromXtl = null;
        let tierFromXtl = 'basic'; // Default assumption

        console.log("XTL parameter found:", xtlParam);

        if (xtlParam && xtlParam.length === 21) {
            try {
                // Extract the verification segment (characters 7-11, index 6-10)
                const verificationSegment = xtlParam.substring(6, 11);
                // Extract the user ID segment (characters 12-21, index 11-end)
                const userIdSegment = xtlParam.substring(11);

                console.log("Parsed XTL: verification segment =", verificationSegment, "user ID segment =", userIdSegment);

                // Validate both segments
                if (/^[a-zA-Z0-9]{5}$/.test(verificationSegment) && userIdSegment.length === 10) {
                    // Set tier based on verification segment
                    if (verificationSegment === '16j59') {
                        tierFromXtl = 'pro';
                        console.log("Verified pro tier access.");
                    } else if (verificationSegment === '83n45') {
                        tierFromXtl = 'basic';
                        console.log("Verified basic tier access.");
                    } else {
                        console.error("Unrecognized verification segment:", verificationSegment);
                        handleInvalidAccess("Invalid Access Code Segment in XTL");
                        return false; // Indicate failure
                    }

                    // Set the user ID since verification passed
                    userIdFromXtl = userIdSegment;
                    console.log("XTL parsing successful. User ID:", userIdFromXtl, "Tier:", tierFromXtl);

                    // Set globals
                    currentUserId = userIdFromXtl;
                    effectiveTier = tierFromXtl;

                    return true; // Indicate success

                } else {
                    console.error("Invalid XTL format: verification segment or user ID segment has wrong format");
                    handleInvalidAccess("Invalid XTL Format");
                    return false; // Indicate failure
                }
            } catch (e) {
                 console.error("Error processing XTL parameter:", e);
                 handleInvalidAccess("Error Processing XTL Parameter");
                 return false; // Indicate failure
            }
        } else {
            console.warn("XTL parameter missing or wrong length.");
            // This is not necessarily an *invalid access* scenario, but means no authenticated user
            // handleInvalidAccess("Missing or Invalid XTL Parameter"); // Decide if missing XTL is an error or just no auth
            console.log("No valid XTL parameter found. Proceeding without authenticated user.");
            currentUserId = null; // Ensure no user ID is set
            effectiveTier = 'basic'; // Default tier remains
            return false; // Indicate no authenticated user was found via XTL
        }
    }

    // Function to fetch initial usage for UI feedback and final access check
    async function fetchInitialUsage() {
        console.log("Fetching initial usage info...");

        // Ensure Supabase client is initialized
        if (!supabase) {
            console.warn("Supabase client not initialized before fetching usage. Attempting initialization.");
             try {
                if (typeof window.supabase === 'undefined' || !window.supabase?.createClient) {
                    throw new Error("Supabase library not loaded.");
                }
                const { createClient } = window.supabase;
                supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log("Supabase client initialized during fetch attempt.");
             } catch (err) {
                console.error("Error initializing Supabase during fetch:", err);
                initialUsageInfo = { error: "Could not initialize service connection." };
                 updateUIBasedOnAccess(); // Update UI to show error state
                 return; // Stop fetch process
             }
        }

        if (!currentUserId) {
            console.log("Skipping initial usage fetch: No user ID available (XTL not parsed or invalid).");
            initialUsageInfo = { error: "No valid user ID for access check." }; // Indicate why chat might not work
            updateUIBasedOnAccess(); // Update UI based on no user ID
            return; // Exit early
        }


        console.log(`Attempting to fetch user data for ID: ${currentUserId}`);

        try {
            // Using the ANON key here requires appropriate RLS on your 'users' table
            // to allow reading 'token_usage', 'last_token_reset', 'tier' for the user matching 'auth.uid()'
            // OR, if you're not using auth.uid() for matching, make sure RLS allows read access based on 'id' column
            const { data, error } = await supabase
                .from('SWN_Users')
                .select('token_usage, last_token_reset, tier')
                .eq('id', currentUserId) // Using the ID derived from XTL
                .maybeSingle();

            if (error && error.code !== 'PGRST116') { // PGRST116 is 'results in 0 rows'
                console.error("Error fetching initial usage:", error.message);
                initialUsageInfo = { error: `Error loading usage data: ${error.message}` };
                updateUIBasedOnAccess();
            } else if (data) {
                console.log("Initial usage data fetched:", data);
                // Note: The backend function is the source of truth for tier/limit/model based on header.
                // This fetch is primarily for displaying client-side usage info.
                // We'll use the tier determined by XTL for the frontend UI and backend header.
                const determinedLimit = (effectiveTier === 'pro') ? 500000 : 15000;

                const now = new Date();
                const lastReset = data.last_token_reset ? new Date(data.last_token_reset) : null;
                let currentUsage = Number(data.token_usage) || 0; // Ensure it's a number

                // Check if weekly reset is due (same logic as backend)
                let needsReset = !lastReset || (now.getTime() - lastReset.getTime()) / (1000 * 60 * 60 * 24) >= 7;

                // Reflect reset state for the frontend display calculation
                if (needsReset) {
                     console.log("Frontend usage calculation: Weekly reset detected.");
                     currentUsage = 0; // Show 0 usage if reset is pending/needed
                }


                initialUsageInfo = {
                    usage: currentUsage, // Usage from DB (or 0 if reset due)
                    limit: determinedLimit, // Limit based on frontend tier
                    model: (effectiveTier === 'pro') ? 'gpt-4o-mini' : 'gpt-3.5-turbo', // Model based on frontend tier
                    tier: effectiveTier, // Tier derived from XTL
                    actualDbTier: data.tier, // Tier stored in DB (for comparison/debug if needed)
                    lastReset: data.last_token_reset,
                    resetDue: needsReset,
                    userFoundInDb: true // Flag indicating the user exists in the DB
                };
                console.log("Initial Usage Info Calculated:", initialUsageInfo);
                updateUIBasedOnAccess(); // Update UI based on fetched info

            } else {
                // data is null and error is PGRST116 - User ID not found in DB
                console.warn(`User ID ${currentUserId} (from XTL) not found in users table during initial fetch.`);
                // This user will be registered on their first chat request by the updated backend.
                // For frontend display, show 0 usage but indicate user not found in initial fetch.
                 initialUsageInfo = {
                    usage: 0, // Assume 0 usage for a new user
                    limit: (effectiveTier === 'pro') ? 500000 : 10000,
                    model: (effectiveTier === 'pro') ? 'gpt-4o-mini' : 'gpt-3.5-turbo',
                    tier: effectiveTier,
                    actualDbTier: null, // Not found in DB
                    lastReset: null,
                    resetDue: true, // New user needs a reset timestamp set
                    userFoundInDb: false // Flag indicating the user does NOT exist in the DB yet
                 };
                 console.log("Initial Usage Info (User Not Found in DB) Calculated:", initialUsageInfo);
                updateUIBasedOnAccess(); // Update UI assuming a new user state
            }
        } catch (err) {
            console.error("Unexpected error fetching initial usage:", err);
            initialUsageInfo = { error: "Unexpected error loading usage data." };
            updateUIBasedOnAccess(); // Update UI with error
        }
    }

    function handleInvalidAccess(reason) {
        console.error("Access Denied or Invalid:", reason);
        currentUserId = null; // Explicitly nullify user ID
        effectiveTier = 'basic'; // Reset tier assumption
        initialUsageInfo = null; // Clear usage info

        // Use the central error handler to ensure visibility
        handleError(`Access Error: ${reason}`, new Error(reason), true); // Pass true for isAccessError
    }

  // --- Chat Functionality ---
    function initializeChat() { // Renamed from updateUIBasedOnAccess temporarily for clarity
        console.log("--- initializeChat START ---");

        // Cache chat elements here if not already done in DOMContentLoaded
        chatInterfaceCardElement = chatInterfaceCardElement || document.getElementById('chatInterfaceCard');
        const chatInput = document.getElementById('chatInput');
        const chatSendButton = document.getElementById('chatSendButton');
        const chatHistory = document.getElementById('chatHistory');

        if (!chatInput || !chatSendButton || !chatHistory || !chatInterfaceCardElement) {
            console.error("One or more Chat UI elements not found! Aborting chat initialization.");
            if (chatInterfaceCardElement) chatInterfaceCardElement.style.display = 'none';
            enableChatInput(false);
            setChatStatus("Chat UI elements missing", false);
            return;
        }

        // SIMPLIFIED CHECK: Ensure Supabase client exists and fetch is available
        const isReadyForChat = supabase && typeof fetch === 'function';
        console.log("Is environment ready for chat (Supabase client + fetch)?", isReadyForChat);

        // Determine if chat CAN be enabled based on user/usage (from global state)
        const canEnableChat = currentUserId && initialUsageInfo && !initialUsageInfo.error && (!initialUsageInfo.limit || initialUsageInfo.usage < initialUsageInfo.limit); // Check limit exists before comparing
        console.log("Can chat be enabled based on user/usage state?", canEnableChat);

        if (isReadyForChat && canEnableChat) {
            chatInterfaceCardElement.style.display = 'block'; // Show the card
            enableChatInput(true); // Enable input fields
            setChatStatus("Ready to chat", false); // Set status

            // Clear and rebuild chat history display based on chatMessages array
            chatHistory.innerHTML = '';
            if (chatMessages.length === 0) {
                // Add initial assistant message only if chat history is empty
                const initialMsgContent = "Hello! Ask me anything about the financial data shown on your dashboard.";
                addMessageToChat("Assistant", initialMsgContent, false);
                // Don't push initial greeting to history array unless you want it saved/resent
                // chatMessages.push({ role: "assistant", content: initialMsgContent });
            } else {
                // Restore previous messages from history array
                chatMessages.forEach(msg => addMessageToChat(msg.role.charAt(0).toUpperCase() + msg.role.slice(1), msg.content));
            }
            // Scroll to the latest message after loading history
            if (chatHistory.scrollHeight) { // Check scrollHeight is available
               chatHistory.scrollTop = chatHistory.scrollHeight;
            }


            // Ensure listeners are attached only once or re-attached correctly
            chatSendButton.removeEventListener('click', handleChatSubmit);
            chatInput.removeEventListener('keydown', handleChatEnterKey);
            chatInput.removeEventListener('input', autoGrowTextarea);

            chatSendButton.addEventListener('click', handleChatSubmit);
            chatInput.addEventListener('keydown', handleChatEnterKey);
            chatInput.addEventListener('input', autoGrowTextarea);
            // Safely attempt initial height adjustment
            try {
               autoGrowTextarea({ target: chatInput }); // Adjust height initially
            } catch(e) { console.warn("Initial autoGrowTextarea failed", e); }


            console.log("Chat UI initialized and enabled.");

        } else {
            // Chat cannot be enabled - figure out why and set status
            console.log("Chat setup skipped or disabled. Reasons:", {
                 isReadyForChat: isReadyForChat,
                 canEnableChat: canEnableChat,
                 hasUserId: !!currentUserId,
                 hasUsageInfo: !!initialUsageInfo,
                 usageInfoError: initialUsageInfo?.error,
                 limitReached: initialUsageInfo && initialUsageInfo.limit && initialUsageInfo.usage >= initialUsageInfo.limit, // Check limit exists
            });
            if (chatInterfaceCardElement) chatInterfaceCardElement.style.display = 'none'; // Ensure hidden
            enableChatInput(false);

            // Set appropriate status message
            if (!initialUsageInfo) {
                 setChatStatus("Loading access info...", true);
            } else if (initialUsageInfo.error) {
                 setChatStatus("Chat unavailable - Access Error", false);
            } else if (!isReadyForChat) {
                 setChatStatus("Chat unavailable - Service Offline", false);
            } else if (!currentUserId) {
                 setChatStatus("Chat unavailable - Authentication needed", false);
            } else if (initialUsageInfo.limit && initialUsageInfo.usage >= initialUsageInfo.limit) { // Check limit exists
                 setChatStatus("Weekly token limit reached", false);
                 if (chatInterfaceCardElement) chatInterfaceCardElement.style.display = 'block'; // Show card but disabled
            } else {
                  setChatStatus("Chat unavailable", false); // Generic fallback
            }
        }
        console.log("--- initializeChat END ---");
    }

    // This function now updates the chat status display info AND calls initializeChat
    // This function now updates the chat status display info AND calls initializeChat
    // This function now updates the chat status display info AND calls initializeChat
    function updateUIBasedOnAccess() {
        console.log("Executing updateUIBasedOnAccess to update Tier/Usage display info START");
        console.log("  currentUserId:", currentUserId);
        console.log("  effectiveTier:", effectiveTier);
        console.log("  initialUsageInfo:", initialUsageInfo); // Log the state of the data object

        // Get references to the new display elements inside the chat status bar
        const tierDisplay = document.getElementById('chatTierDisplay');
        const modelDisplay = document.getElementById('chatModelDisplay');
        const usageDisplay = document.getElementById('chatUsageDisplay');

        console.log("  Found chat status elements:", {
            tierDisplay: !!tierDisplay, // Check if element was found (true/false)
            modelDisplay: !!modelDisplay,
            usageDisplay: !!usageDisplay
        });


        // Default display values
        let tierText = 'Loading...'; // Use 'Loading...' as an explicit state
        let modelText = '-';
        let usageText = '- / -';

        if (initialUsageInfo) { // Check if initialUsageInfo object exists at all
             console.log("  initialUsageInfo exists.");
             if (!initialUsageInfo.error) { // Check if there was an error fetching info
                   console.log("  initialUsageInfo has no error.");
                   // We have valid usage info
                    const usage = initialUsageInfo.usage !== undefined ? initialUsageInfo.usage : NaN;
                    const limit = initialUsageInfo.limit !== undefined ? initialUsageInfo.limit : NaN;

                    // Use the tier/model from initialUsageInfo if available, fallback to effectiveTier
                    tierText = getSafe(() => initialUsageInfo.tier, effectiveTier);
                    modelText = getSafe(() => initialUsageInfo.model, 'N/A'); // Model is set by backend based on tier

                    console.log("  Calculated raw values:", { usage, limit, tierText, modelText });


                    if (!isNaN(usage) && isFinite(usage) && !isNaN(limit) && isFinite(limit)) {
                         usageText = `${Math.floor(usage).toLocaleString()} / ${Math.floor(limit).toLocaleString()}`; // Floor usage/limit for display
                    } else {
                         usageText = 'ErrorCalculating'; // Indicate if usage/limit numbers are invalid
                    }

                    if(initialUsageInfo.resetDue) usageText += " (Reset Pending)";
                    if(!initialUsageInfo.userFoundInDb) tierText += " (New)"; // Append note if needed (e.g., 'basic (New)')

                    console.log("  Formatted text values:", { tierText, modelText, usageText });

             } else {
                   // Error loading usage info
                    tierText = 'ErrorFetch'; // Indicate error state
                    modelText = 'ErrorFetch';
                    usageText = 'ErrorFetch';
                    console.warn("  Displaying Error state due to initialUsageInfo.error:", initialUsageInfo.error);
             }
        } else if (!currentUserId) {
            // No valid user ID available (XTL parsing failed or missing)
            tierText = 'NoUser'; // Indicate no user
            modelText = 'NoUser';
            usageText = 'NoUser';
             console.log("  No currentUserId available.");
        } else {
             // initialUsageInfo is null/undefined, but user ID is present.
             // This means fetchInitialUsage hasn't completed yet or failed silently before setting initialUsageInfo.error.
             console.log("  initialUsageInfo is null/undefined, user ID present. Still loading?");
             // The "Loading..." defaults set initially will cover this.
             tierText = 'Loading...'; // Explicitly show loading state
             modelText = 'Loading...';
             usageText = 'Loading...';
        }

        // Update the text content of the new spans in the chat status bar
        if (tierDisplay) tierDisplay.textContent = tierText;
        else console.error("Chat tier display element (#chatTierDisplay) not found - critical for status display."); // Changed warn to error for clarity

        if (modelDisplay) modelDisplay.textContent = modelText;
        else console.error("Chat model display element (#chatModelDisplay) not found - critical for status display."); // Changed warn to error

        console.log("  Attempting to update Usage display with:", usageText); // <-- LOG BEFORE SETTING TEXT
        if (usageDisplay) {
            usageDisplay.textContent = usageText; // <-- This line updates the usage display
            console.log("  Successfully updated Usage display."); // <-- LOG AFTER SETTING TEXT
        } else {
            console.error("Chat usage display element (#chatUsageDisplay) not found - critical for status display.");
        }

        console.log("  Finished updating chat status elements."); // <-- LOG AFTER ALL ELEMENTS ARE HANDLED


        // Update any pro-specific UI elements (e.g., buttons) based on the effectiveTier
        const proFeatureButton = document.getElementById('proFeatureButton'); // Assuming you have such a button
        if (proFeatureButton) {
            proFeatureButton.style.display = (effectiveTier === 'pro') ? 'inline-block' : 'none';
        } else { console.warn("Pro feature button element not found."); } // Keep as warn


        // Trigger chat initialization/update AFTER usage info is processed and displayed
        // This ensures the chat UI visibility/state (enabled/disabled) reflects the latest access status
        console.log("  Calling initializeChat() from updateUIBasedOnAccess.");
        initializeChat(); // This remains crucial

        console.log("Executing updateUIBasedOnAccess END");
    }
    
    // --- Main Data Processing & Display Function ---
    function processAndDisplayData(data) {
        console.log("--- processAndDisplayData START ---", data);
        // Basic validation of the data structure
        if (!data || typeof data !== 'object' || !data.userInput) {
            console.error("Invalid data structure received by processAndDisplayData", data);
            handleError("Invalid data format for processing. Cannot display dashboard.", new Error("Data structure is missing 'userInput'."));
            return; // Stop processing
        }
        dashboardData = data; // Update global reference

        try {
            console.log("1. Calculating totals...");
            const totals = calculateTotals(data);
            console.log("Totals calculated:", totals);

            console.log("2. Calculating ratios...");
            const ratios = calculateRatios(data, totals);
            console.log("Ratios calculated:", ratios);

            console.log("3. Updating basic info UI...");
            updateReportBasics(data, totals);
            console.log("Basic info UI updated.");

            console.log("4. Updating ratios UI...");
            updateRatiosDisplay(ratios);
            console.log("Ratios UI updated.");

            console.log("5. Updating goals UI...");
            updateGoalsDisplay(data, totals);
            console.log("Goals UI updated.");

            console.log("6. Updating debts UI...");
            console.log("  About to call updateDebtsDisplay...");
            updateDebtsDisplay(data, totals);
            console.log("Debts UI updated.");

            console.log("7. Scheduling chart rendering...");
            // Use requestAnimationFrame to ensure DOM is ready for Plotly
            requestAnimationFrame(() => {
                console.log("7a. Executing chart rendering (inside requestAnimationFrame)...");
                try {
                    renderCharts(data);
                    console.log("Charts rendered successfully.");
                } catch (chartError) {
                    console.error("--- Error during renderCharts ---", chartError);
                    // Display error within the chart divs
                    const incomeChartDiv = document.getElementById('incomeChart');
                    const expenseChartDiv = document.getElementById('expenseChart');
                    incomeChartDiv.innerHTML  = '';
                    expenseChartDiv.innerHTML = '';

                    if(incomeChartDiv) incomeChartDiv.innerHTML = `<p class="text-red-600 text-center p-4">Error loading income chart:<br>${getSafe(() => chartError.message, 'Unknown chart error')}</p>`;
                    if(expenseChartDiv) expenseChartDiv.innerHTML = `<p class="text-red-600 text-center p-4">Error loading expense chart:<br>${getSafe(() => chartError.message, 'Unknown chart error')}</p>`;
                }
            });

            console.log("8. Updating AI display UI...");
            updateUIDisplayFromAI(data);
            console.log("AI display UI updated.");

             console.log("9. Re-checking chat access now that data is loaded…");
       updateUIBasedOnAccess();      // <<< Add this crucial second call
       console.log("Chat initialization (second pass) updated UI based on data.");

            console.log("10. Making main content visible...");
            hideAllMainContentAreas(); // Hide other states
            if (mainContentElement) {
                mainContentElement.style.display = 'block'; // Use block display (or grid if appropriate)
                mainContentElement.classList.remove('hidden'); // Ensure class is removed if used
                console.log("Main content should now be visible.");
            } else {
                 console.error("Main content element not found!");
                 handleError("Critical: Main content element not found.", new Error("DOM element #mainContent is missing."));
            }

        } catch (processingError) {
            console.error("--- processAndDisplayData ERROR ---", processingError);
            handleError("Error processing or displaying data", processingError);
        } finally {
            // Ensure spinner is hidden regardless of success/failure within the try block
            console.log("Executing finally block in processAndDisplayData.");
            if (loadingSpinner) {
                loadingSpinner.style.display = 'none';
                console.log("Spinner hidden by processAndDisplayData finally block.");
            } else {
                console.warn("Spinner element not found in finally block.");
            }
            console.log("--- processAndDisplayData END ---");
        }
    }

    // --- Calculation Functions ---
    function calculateTotals(data) {
        console.log("Calculating totals...");
        const totals = {
            totalIncome: 0, totalExpenses: 0, netFlow: 0,
            totalDebt: 0, totalSavings: 0, totalMinPayments: 0,
            monthlyCoreExpenses: 0 // Added for emergency fund calc
        };

        try {
            const income = getSafe(() => data.userInput.income, {});
            const expenses = getSafe(() => data.userInput.expenses, {});
            const savings = getSafe(() => data.userInput.savings, {});
            const debts = getSafe(() => data.userInput.debts, []);

            // Income: Sum known income types
            totals.totalIncome = (Number(getSafe(() => income.mainJobIncome)) || 0) + (Number(getSafe(() => income.secondJob)) || 0) + (Number(getSafe(() => income.otherIncome)) || 0);

            // Expenses & Core Expenses: Iterate through expenses object
            // Define core expenses - ADJUST THESE KEYS TO MATCH YOUR DATA EXACTLY
             // Assuming min payments from debts are *not* included in expenses object directly
            const coreExpenseKeys = ['housing', 'utilities', 'transportation', 'groceriesEssentials', 'insurance', 'medical', 'care', 'subscriptions', 'taxes']; // Removed 'minPayments' here

            for (const key in expenses) {
                const value = Number(getSafe(() => expenses[key])) || 0;
                totals.totalExpenses += value;
                // Check if the expense key is considered 'core'
                if (coreExpenseKeys.includes(key)) {
                    totals.monthlyCoreExpenses += value;
                }
            }

            // Debts: Sum balance and minimum payments from the debts array
            if (Array.isArray(debts)) {
                debts.forEach(debt => {
                    totals.totalDebt += Number(getSafe(() => debt.balance)) || 0;
                    const minPayment = Number(getSafe(() => debt.minPayment)) || 0;
                    totals.totalMinPayments += minPayment;
                });
            }

            // Add total minimum debt payments to total expenses and core expenses
            totals.totalExpenses += totals.totalMinPayments;
            totals.monthlyCoreExpenses += totals.totalMinPayments; // Min payments are usually core

            totals.netFlow = totals.totalIncome - totals.totalExpenses;

            // Savings: Sum known savings types
            totals.totalSavings = (Number(getSafe(() => savings.emergency)) || 0) + (Number(getSafe(() => savings.savings)) || 0) + (Number(getSafe(() => savings.retirement)) || 0);

             console.log("Totals calculation successful.");
        } catch (e) {
             console.error("Error during calculateTotals:", e);
             // Return partial totals or re-throw? Returning partial is more robust
             return totals; // Return whatever was calculated before the error
        }

        return totals;
    }

    function calculateRatios(data, totals) {
        console.log("Calculating ratios...");
        const ratios = { savingsRate: 0, emergencyCoverage: 0, dtiRatio: 0 };

         // Check if totals are valid before calculating ratios
         if (typeof totals !== 'object' || isNaN(totals.totalIncome) || isNaN(totals.totalExpenses) || isNaN(totals.totalMinPayments) || isNaN(totals.monthlyCoreExpenses)) {
             console.error("Invalid totals provided for ratio calculation.");
             return ratios; // Return zero ratios
         }

        try {
            const savingsInput = getSafe(() => data.userInput.savings, {});

            // Savings Rate: Use explicit monthly goal if available, otherwise use positive net flow proxy
            const monthlySavingsGoal = Number(getSafe(() => savingsInput.monthlySavingsGoal));
            // Use the goal if defined AND positive, otherwise use net flow (but cap at 0 if net flow is negative)
            const contribution = (monthlySavingsGoal > 0) ? monthlySavingsGoal : Math.max(0, totals.netFlow);

            if (totals.totalIncome > 0) {
                // Savings rate = (Amount Saved Per Month / Gross Monthly Income)
                ratios.savingsRate = (contribution / totals.totalIncome); // Rate as decimal
            } else {
                ratios.savingsRate = 0; // Avoid division by zero
            }

            // Emergency Fund Coverage (Months based on CORE expenses)
            const currentEmergencyFund = Number(getSafe(() => savingsInput.emergency)) || 0;
            if (totals.monthlyCoreExpenses > 0) {
                ratios.emergencyCoverage = currentEmergencyFund / totals.monthlyCoreExpenses; // Result in months
            } else if (totals.totalExpenses > 0) {
                // Fallback if core expenses somehow end up zero but total expenses > 0
                ratios.emergencyCoverage = currentEmergencyFund / totals.totalExpenses;
                console.warn("Using total expenses for emergency coverage calculation as core expenses were zero.")
            } else {
                ratios.emergencyCoverage = Infinity; // If no expenses, coverage is infinite (or handle as special case)
            }

            // Debt-to-Income (DTI) Ratio (using minimum payments from totals)
            // DTI = (Total Monthly Minimum Debt Payments / Gross Monthly Income)
            if (totals.totalIncome > 0) {
                ratios.dtiRatio = (totals.totalMinPayments / totals.totalIncome); // Rate as decimal
            } else {
                ratios.dtiRatio = 0; // Or Infinity if debts exist but income is zero? Define behavior.
            }
             console.log("Ratios calculation successful.");
        } catch (e) {
             console.error("Error during calculateRatios:", e);
             return ratios; // Return partial ratios or re-throw? Returning partial is more robust
        }


        return ratios;
    }

    // --- UI Update Functions ---
    function updateReportBasics(data, totals) {
        console.log("Updating report basics UI...");
        try {
            const personalInfo = getSafe(() => data.userInput.personalInfo, {});
            const savings = getSafe(() => data.userInput.savings, {});
            const financials = getSafe(() => data.userInput.financials, {});

            updateElementText('userName', getSafe(() => personalInfo.userName));
            updateElementText('age', getSafe(() => personalInfo.age)); // Assumes age is just a number
            updateElementText('totalIncome', totals.totalIncome, formatCurrency);
            updateElementText('totalExpenses', totals.totalExpenses, formatCurrency);
            updateElementText('netFlow', totals.netFlow, formatCurrency);

            // Update Savings Overview Card
            updateElementText('emergencySavings', getSafe(() => savings.emergency), formatCurrency);
            updateElementText('currentSavings', getSafe(() => savings.savings), formatCurrency); // Assumes 'savings' is general savings
            updateElementText('retirementFund', getSafe(() => savings.retirement), formatCurrency);

            // Update Financial Tools & Goals Card (specific fields)
            updateElementText('financialTools', getSafe(() => financials.financialTools));
            updateElementText('challenges', getSafe(() => financials.challenges));
            updateElementText('purchaseGoals', getSafe(() => financials.upcomingPurchase)); // Raw detail string here
            console.log("Report basics UI updated.");
        } catch (e) {
            console.error("Error updating report basics UI:", e);
        }
    }

    function updateRatiosDisplay(ratios) {
        console.log("Updating ratios display UI...");
        try {
            // Savings Rate
            const savingsRateValue = getSafe(() => ratios.savingsRate, 0);
            updateElementText('savingsRateValue', savingsRateValue, val => formatPercentage(val, 1));
            const savingsRatePercent = Math.min(100, Math.max(0, savingsRateValue * 100));
            const savingsBar = document.getElementById('savingsRateBar');
            if (savingsBar) {
                savingsBar.style.width = `${savingsRatePercent}%`;
                // Recommendation: Poor < 5%, Ok 5-10%, Good 10-15%, Excellent > 15% (Adjust thresholds as needed)
                savingsBar.className = `ratio-bar savings-rate ${savingsRateValue >= 0.10 ? 'good' : savingsRateValue >= 0.05 ? 'ok' : 'poor'}`; // Example thresholds
            } else { console.warn("Savings rate bar element not found."); }

            // Emergency Fund Coverage (Display in Months)
            const emergencyCoverageMonths = getSafe(() => ratios.emergencyCoverage, 0);
             const emergencyCoverageText = emergencyCoverageMonths === Infinity ? 'N/A (No Expenses)' : `${emergencyCoverageMonths.toFixed(1)} months`;
            updateElementText('emergencyCoverageValue', emergencyCoverageText);
            const emergencyBar = document.getElementById('emergencyCoverageBar');
            if (emergencyBar) {
                // Progress towards a target, e.g., 6 months. Cap at 100%. Handle Infinity.
                const targetMonths = 6;
                const emergencyProgressPercent = emergencyCoverageMonths === Infinity ? 100 : Math.min(100, Math.max(0, (emergencyCoverageMonths / targetMonths) * 100));
                emergencyBar.style.width = `${emergencyProgressPercent}%`;
                // Recommendation: Poor < 1 month, Ok 1-3 months, Good 3-6 months, Excellent > 6 months (Adjust thresholds)
                emergencyBar.className = `ratio-bar emergency-coverage ${emergencyCoverageMonths >= 3 ? 'good' : emergencyCoverageMonths >= 1 ? 'ok' : 'poor'}`;
            } else { console.warn("Emergency coverage bar element not found."); }


            // DTI Ratio
            const dtiRatioValue = getSafe(() => ratios.dtiRatio, 0);
            updateElementText('dtiRatioValue', dtiRatioValue, val => formatPercentage(val, 1));
            const dtiPercent = Math.min(100, Math.max(0, dtiRatioValue * 100));
            const dtiBar = document.getElementById('dtiRatioBar');
            if (dtiBar) {
                dtiBar.style.width = `${dtiPercent}%`;
                // General guideline: Good < 36%, Warning 36-43%, High > 43% (Adjust thresholds)
                dtiBar.className = `ratio-bar dti-ratio ${dtiRatioValue > 0.43 ? 'high' : dtiRatioValue >= 0.36 ? 'warning' : 'good'}`;
            } else { console.warn("DTI ratio bar element not found."); }
             console.log("Ratios display UI updated.");
        } catch (e) {
            console.error("Error updating ratios display UI:", e);
        }
    }

        function updateGoalsDisplay(data, totals) {
        console.log("Updating goals display UI...");
        try {
            const savingsInput = getSafe(() => data.userInput.savings, {});
            const financialsInput = getSafe(() => data.userInput.financials, {});
            const upcomingPurchaseString = getSafe(() => financialsInput.upcomingPurchase, '');

            const emergencyGoalDisplay = document.getElementById('emergencyGoalDisplay');
            const purchaseGoalDisplay = document.getElementById('purchaseGoalDisplay');
            const noGoalsMessage = document.getElementById('noGoalsMessage');
            let hasVisibleGoal = false;

            // --- Emergency Fund Goal ---
            const emergencyCurrent = Number(getSafe(() => savingsInput.emergency)) || 0;
            // Use target from data if available, otherwise default to 3 months CORE expenses
            const emergencyGoalTargetExplicit = Number(getSafe(() => savingsInput.emergencyFundTarget));
            const emergencyGoalTargetCalculated = totals.monthlyCoreExpenses > 0 ? totals.monthlyCoreExpenses * 3 : 0;
            // Prefer explicit target if valid (>0), else use calculated (>0), else target is 0
            const emergencyGoalTarget = (emergencyGoalTargetExplicit > 0) ? emergencyGoalTargetExplicit : (emergencyGoalTargetCalculated > 0 ? emergencyGoalTargetCalculated : 0);

            const emergencyProgressBar = document.getElementById('emergencyProgressBar');

            if (emergencyGoalTarget > 0 && emergencyGoalDisplay && emergencyProgressBar) {
                hasVisibleGoal = true;
                emergencyGoalDisplay.style.display = 'block';
                const progress = Math.min(100, Math.max(0, (emergencyCurrent / emergencyGoalTarget) * 100));
                emergencyProgressBar.style.width = `${progress}%`;
                emergencyProgressBar.textContent = `${progress.toFixed(0)}%`;
                const statusEl = emergencyGoalDisplay.querySelector('.goal-status');
                if (statusEl) statusEl.textContent = `Target: ${formatCurrency(emergencyGoalTarget)} (${formatPercentage(emergencyCurrent / emergencyGoalTarget, 0)} funded)`;
            } else if (emergencyGoalDisplay) {
                emergencyGoalDisplay.style.display = 'none'; // Hide if target is not valid
            } else { console.warn("Emergency goal elements not found."); }


            // --- Upcoming Purchase Goal (Attempt to parse first one) ---
            const purchaseProgressBar = document.getElementById('purchaseProgressBar');
            const purchaseGoalNameEl = document.getElementById('purchaseGoalName');

            // Check if all necessary elements exist before attempting to parse/display purchase goal
            if (upcomingPurchaseString && purchaseGoalDisplay && purchaseProgressBar && purchaseGoalNameEl) {
                 // Look for pattern like: #1) Name, $Amount[, X months] - make months optional
                 // Made regex slightly more robust to handle spaces, commas, dollar signs better
                 const match = upcomingPurchaseString.match(/#\d+\)\s*(.*?),\s*\$?\s*([\d,.]+)(?:,\s*\d+\s*months?)?/i); // Added case-insensitive flag
                 console.log("Purchase goal regex match:", match);

                if (match && match[1] && match[2]) {
                    const goalName = match[1].trim();
                    const goalAmountStr = match[2].replace(/,/g, '');
                    const goalAmount = parseFloat(goalAmountStr);
                    // Use general savings for progress unless specific goal savings provided in data
                    const generalSavings = Number(getSafe(() => savingsInput.savings)) || 0;

                    if (goalName && !isNaN(goalAmount) && goalAmount > 0) {
                        hasVisibleGoal = true;
                        purchaseGoalDisplay.style.display = 'block';
                        purchaseGoalNameEl.textContent = goalName;
                        // Calculate progress using general savings balance towards this goal amount
                        const progress = Math.min(100, Math.max(0, (generalSavings / goalAmount) * 100));
                        purchaseProgressBar.style.width = `${progress}%`;
                        purchaseProgressBar.textContent = `${progress.toFixed(0)}%`;
                        const statusEl = purchaseGoalDisplay.querySelector('.goal-status');
                        if (statusEl) statusEl.textContent = `Target: ${formatCurrency(goalAmount)} (${formatCurrency(generalSavings)} saved)`;
                    } else {
                        console.warn("Purchase goal parsed but name or amount invalid:", { goalName, goalAmount });
                        purchaseGoalDisplay.style.display = 'none'; // Hide if parsing results in invalid goal
                    }
                } else {
                     console.log("Upcoming purchase string does not match expected format, displaying raw text:", upcomingPurchaseString);
                     // If parsing fails, display the raw text in the Financial Tools & Goals card instead
                     // This is already done by updateReportBasics, so just hide this progress bar section
                    purchaseGoalDisplay.style.display = 'none';
                }
            } else if (purchaseGoalDisplay) { // Hide if no string or elements
                purchaseGoalDisplay.style.display = 'none';
                 if (!purchaseGoalDisplay) console.warn("Purchase goal display elements not found.");
            }

            // Show 'No goals' message only if neither goal section is visible
            if (noGoalsMessage) {
                noGoalsMessage.style.display = hasVisibleGoal ? 'none' : 'block';
            } else { console.warn("No goals message element not found.");}
             console.log("Goals display UI updated.");
        } catch (e) {
            console.error("Error updating goals display UI:", e);
        }
    }
    
     function updateDebtsDisplay(data, totals) {
        console.log("--- updateDebtsDisplay FUNCTION ENTERED ---"); // Very first log inside {}

        try { // Wrap the main logic in try block
            console.log("--- updateDebtsDisplay START ---");
            console.log("  Received data object:", data);
            console.log("  Received totals object:", totals);

            const debts = getSafe(() => data.userInput.debts, []); // Get debts array safely
            console.log("  Parsed debts array:", debts);
            console.log("  Is debts an array?", Array.isArray(debts));
            console.log("  Debts array length:", debts.length);


            const debtsTable = document.getElementById('debtsTable');
            if (!debtsTable) {
                console.error("Debt table element (#debtsTable) not found!");
                // Still attempt to update totals even if table is missing
                 // Update totals using the calculated totals object - ensure totals exist and are valid
                if (totals && typeof totals === 'object' && isFinite(totals.totalDebt) && isFinite(totals.totalMinPayments)) {
                     updateElementText('totalDebtBalance', totals.totalDebt, formatCurrency);
                     updateElementText('totalMinPayments', totals.totalMinPayments, formatCurrency);
                } else {
                     console.warn("Totals object invalid, skipping total debt display update.");
                     updateElementText('totalDebtBalance', 'N/A');
                     updateElementText('totalMinPayments', 'N/A');
                }
                console.log("--- updateDebtsDisplay END (Table not found) ---");
                return; // Exit function if table is missing
            }

            const debtsTableBody = debtsTable.getElementsByTagName('tbody')[0];
             if (!debtsTableBody) {
                 console.error("Debt table body element (tbody) not found inside #debtsTable!");
                 // Update totals even if tbody is missing
                 if (totals && typeof totals === 'object' && isFinite(totals.totalDebt) && isFinite(totals.totalMinPayments)) {
                     updateElementText('totalDebtBalance', totals.totalDebt, formatCurrency);
                     updateElementText('totalMinPayments', totals.totalMinPayments, formatCurrency);
                } else {
                     console.warn("Totals object invalid, skipping total debt display update.");
                     updateElementText('totalDebtBalance', 'N/A');
                     updateElementText('totalMinPayments', 'N/A');
                }
                 console.log("--- updateDebtsDisplay END (Tbody not found) ---");
                 return; // Exit function if tbody is missing
             }

            console.log("  Debt table body found.");
            debtsTableBody.innerHTML = ''; // Clear existing rows
            console.log("  Cleared existing table rows.");

            if (!Array.isArray(debts) || debts.length === 0) {
                console.log("  No debt data or debts array is not an array. Displaying 'No debt information'.");
                debtsTableBody.innerHTML = '<tr><td colspan="4" class="text-center text-gray-500 py-4">No debt information provided.</td></tr>';
            } else {
                console.log(`  Processing ${debts.length} debt items.`);
                debts.forEach((debt, index) => {
                    console.log(`    Processing debt item ${index}:`, debt);
                    // Inner try/catch already exists here for individual rows - keep it

                    try { // Existing inner try block
                        const row = debtsTableBody.insertRow();

                        // Use getSafe for potentially missing debt properties
                        const type = getSafe(() => debt.type, 'N/A');
                        const balance = getSafe(() => debt.balance); // Use getSafe for balance
                        const minPayment = getSafe(() => debt.minPayment); // Use getSafe for minPayment
                        const interestRate = getSafe(() => debt.interestRate, 0); // Default rate to 0 if missing

                        console.log(`      Values for row ${index}:`, { type, balance, minPayment, interestRate });
                        console.log(`      Formatted values:`, {
                             balance: formatCurrency(balance),
                             minPayment: formatCurrency(minPayment),
                             interestRate: (Number(interestRate)).toFixed(1) + '%'
                        });


                        // Correctly map data to the appropriate columns and add CSS classes
                        row.innerHTML = `
                            <td>${type}</td>                                          <!-- Column 1: Type -->
                            <td class="balance-col">${formatCurrency(balance)}</td>    <!-- Column 2: Balance -->
                            <td class="rate-col">${(Number(interestRate)).toFixed(1)}%</td>    <!-- Column 3: Rate -->
                            <td class="min-pmt-col">${formatCurrency(minPayment)}</td>    <!-- Column 4: Min Payment -->
                        `;
                         console.log(`      Row ${index} HTML set.`);
                    } catch (e) { // Existing inner catch block
                        console.error(`  Error adding debt row for item ${index}:`, debt, e);
                        // Add an error row if processing a specific debt item fails
                        const row = debtsTableBody.insertRow();
                         row.innerHTML = `<td colspan="4" class="text-center text-red-500">Error displaying data for this debt item.</td>`;
                    }
                });
                 console.log("  Finished processing debt items.");
            }

            // Update totals using the calculated totals object - ensure totals exist and are valid
            if (totals && typeof totals === 'object' && isFinite(totals.totalDebt) && isFinite(totals.totalMinPayments)) {
                console.log("  Updating total debt elements:", { totalDebt: totals.totalDebt, totalMinPayments: totals.totalMinPayments });
                 updateElementText('totalDebtBalance', totals.totalDebt, formatCurrency);
                 updateElementText('totalMinPayments', totals.totalMinPayments, formatCurrency);
            } else {
                 console.warn("  Totals object invalid or missing, skipping total debt display update.");
                 updateElementText('totalDebtBalance', 'N/A');
                 updateElementText('totalMinPayments', 'N/A');
            }
             console.log("--- updateDebtsDisplay END ---"); // Last log before function exits normally

        } catch (outerError) { // Outer catch block
            console.error("--- updateDebtsDisplay OUTER CATCH ERROR ---", outerError);
            // Optionally display a generic error message in the table body if it wasn't cleared
            if(debtsTableBody && debtsTableBody.innerHTML === '') {
                 debtsTableBody.innerHTML = '<tr><td colspan="4" class="text-center text-red-500 py-4">Error loading debt data. Check console.</td></tr>';
            } else if (debtsTableBody && debtsTableBody.innerHTML.includes('Loading debt data')) {
                // If still showing "Loading...", replace it
                 debtsTableBody.innerHTML = '<tr><td colspan="4" class="text-center text-red-500 py-4">Error loading debt data. Check console.</td></tr>';
            }
             // Update totals to N/A on error
             updateElementText('totalDebtBalance', 'N/A');
             updateElementText('totalMinPayments', 'N/A');
        }
        // Function implicitly ends here if no outer catch error, or returns above
         console.log("--- updateDebtsDisplay FUNCTION EXIT ---"); // Log right before the function truly exits
    }    
    
    function renderCharts(data) {
        console.log("--- renderCharts START ---");
        console.log("  Received data object for charts:", data);

        // Check if Plotly library is loaded
        if (typeof Plotly === 'undefined') {
            console.error("  Plotly library not found. Cannot render charts.");
            const incomeChartDiv = document.getElementById('incomeChart');
            const expenseChartDiv = document.getElementById('expenseChart');
            if(incomeChartDiv) incomeChartDiv.innerHTML = '<p class="text-red-600 text-center p-4">Error: Plotly library not loaded.</p>';
            if(expenseChartDiv) expenseChartDiv.innerHTML = '<p class="text-red-600 text-center p-4">Error: Plotly library not loaded.</p>';
            console.log("--- renderCharts END (Plotly not loaded) ---");
            return; // Exit function
        }
        console.log("  Plotly library found.");


        try {
            const incomeData = getSafe(() => data.userInput.income, {});
            const expenseData = getSafe(() => data.userInput.expenses, {});

            console.log("  Parsed income data:", incomeData);
            console.log("  Parsed expense data:", expenseData);


            // --- Filter and prepare income labels/values ---
            const incomeLabels = [];
            const incomeValues = [];
            Object.entries(incomeData).forEach(([key, value]) => {
                const numValue = Number(getSafe(() => value)); // Use getSafe for value
                if (numValue > 0) {
                    let label = key.replace(/([A-Z])/g, ' $1').replace(/^./, c => c.toUpperCase());
                    incomeLabels.push(label);
                    incomeValues.push(numValue);
                }
            });
            console.log("  Prepared income data for chart:", { labels: incomeLabels, values: incomeValues });

            // --- Filter and prepare expense labels/values ---
            const expenseLabels = [];
            const expenseValues = [];
            Object.entries(expenseData).forEach(([key, value]) => {
                const numValue = Number(getSafe(() => value)); // Use getSafe for value
                if (numValue > 0) {
                    let label = key.replace(/([A-Z])/g, ' $1').replace(/^./, c => c.toUpperCase());
                    if (key === 'groceriesEssentials') label = 'Groceries/Essentials';
                    expenseLabels.push(label);
                    expenseValues.push(numValue);
                }
            });
             console.log("  Prepared expense data for chart:", { labels: expenseLabels, values: expenseValues });


            const incomeChartDiv = document.getElementById('incomeChart');
            const expenseChartDiv = document.getElementById('expenseChart');

             console.log("  Found chart divs:", { incomeChartDiv: !!incomeChartDiv, expenseChartDiv: !!expenseChartDiv });

            // Common layout adjustments for Pie charts
          const commonPieLayout = {
    autosize: true,
    margin: { l: 40, r: 40, b: 60, t: 80 },   // extra space
    showlegend: true,
    legend: {
        orientation: "h",
        yanchor: "top",
        y: -0.20,                              // legend below the chart
        xanchor: "center",
        x: 0.5
    },
    paper_bgcolor: "rgba(0,0,0,0)",
    plot_bgcolor: "rgba(0,0,0,0)",
    font: { family: "Inter, sans-serif", size: 12, color: "#374151" },
    hoverlabel: { font: { family: "Inter, sans-serif", size: 12 } }
};

             console.log("  Common Pie Layout:", commonPieLayout);

            // Plotly config
             const plotlyConfig = {
                 displaylogo: false,
                 responsive: true, // Ensure responsive is true in config
                 modeBarButtonsToRemove: ['sendDataToCloud', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale2d', 'resetScale2d', 'hoverClosestPie', 'toggleSpikelines', 'hoverCompareCartesian']
             };
             console.log("  Plotly Config:", plotlyConfig);


            // Income Chart (Pie)
            if (incomeChartDiv) {
                console.log("  Processing Income Chart.");
                Plotly.purge(incomeChartDiv); // Clear previous chart first
                if (incomeValues.length > 0) {
                    console.log("  Income data found, attempting to plot.");
                    const incomeTrace = [{
                        values: incomeValues,
                        labels: incomeLabels,
                        type: 'pie',
                        hole: .4,
                        hoverinfo: 'label+percent+value',
                        textinfo: 'percent',
                        texttemplate: '%{percent}',
                        textposition: 'inside',
                        textfont_size: 11,
                        marker: {
                            colors: ['#10b981', '#34d399', '#6ee7b7', '#a7f3d0', '#d1fae5'],
                            line: { color: '#ffffff', width: 1 }
                        },
                        domain: { y: [0, 1] } // Domain should cover full height [0, 1]
                    }];
                    console.log("  Income Trace:", incomeTrace);
                    Plotly.newPlot(incomeChartDiv, incomeTrace, { ...commonPieLayout, title: { text: 'Income Sources', y:0.98, font: { size: 14, family: 'EB Garamond, serif', color: '#111827' } } }, plotlyConfig)
                        .then(() => { console.log("  Income Chart plotted successfully."); })
                        .catch((plotErr) => { console.error("  Error during Income Plotly.newPlot:", plotErr); incomeChartDiv.innerHTML = `<p class="text-red-600 text-center p-4">Error plotting income chart:<br>${getSafe(() => plotErr.message, 'Unknown plot error')}</p>`; });

                } else {
                    console.log("  No income data to plot. Displaying message.");
                    incomeChartDiv.innerHTML = '<p class="text-center text-gray-500 pt-10">No income data to display.</p>';
                    incomeChartDiv.innerHTML  = '';
                }
            } else { console.error("  Income chart div (#incomeChart) not found."); }


            // Expense Chart (Pie)
            if (expenseChartDiv) {
                 console.log("  Processing Expense Chart.");
                Plotly.purge(expenseChartDiv); // Clear previous chart
                if (expenseValues.length > 0) {
                    console.log("  Expense data found, attempting to plot.");
                    const expenseTrace = [{
                        values: expenseValues,
                        labels: expenseLabels,
                        type: 'pie',
                        hole: .4,
                        hoverinfo: 'label+percent+value',
                        textinfo: 'percent',
                        texttemplate: '%{percent}',
                        textposition: 'inside',
                        textfont_size: 11,
                        marker: {
                            colors: ['#ef4444', '#f87171', '#fca5a5', '#fecaca', '#fb923c', '#fdba74', '#fed7aa', '#ffedd5', '#d1d5db', '#9ca3af', '#a78bfa', '#c4b5fd'],
                            line: { color: '#ffffff', width: 1 }
                        },
                        domain: { y: [0, 1] } // Domain should cover full height [0, 1]
                    }];
                     console.log("  Expense Trace:", expenseTrace);
                    Plotly.newPlot(expenseChartDiv, expenseTrace, { ...commonPieLayout, title: { text: 'Expense Categories', y:0.98, font: { size: 14, family: 'EB Garamond, serif', color: '#111827' } } }, plotlyConfig)
                        .then(() => { console.log("  Expense Chart plotted successfully."); })
                        .catch((plotErr) => { console.error("  Error during Expense Plotly.newPlot:", plotErr); expenseChartDiv.innerHTML = `<p class="text-red-600 text-center p-4">Error plotting expense chart:<br>${getSafe(() => plotErr.message, 'Unknown plot error')}</p>`; });

                } else {
                    console.log("  No expense data to plot. Displaying message.");
                    expenseChartDiv.innerHTML = '<p class="text-center text-gray-500 pt-10">No expense data to display.</p>';
                    expenseChartDiv.innerHTML = '';
                }
            } else { console.error("  Expense chart div (#expenseChart) not found."); }

             console.log("--- renderCharts END ---"); // Last log before function exits
        } catch (chartError) {
            console.error("--- renderCharts OUTER CATCH ERROR ---", chartError);
            // Display generic error in chart divs if a general error occurred above Plotly.newPlot
            const incomeChartDiv = document.getElementById('incomeChart');
            const expenseChartDiv = document.getElementById('expenseChart');
             if(incomeChartDiv) incomeChartDiv.innerHTML = `<p class="text-red-600 text-center p-4">Error loading chart.</p>`;
             if(expenseChartDiv) expenseChartDiv.innerHTML = `<p class="text-red-600 text-center p-4">Error loading chart.</p>`;
            // Rethrow the error so it can be caught by the caller in requestAnimationFrame
            // throw new Error(`Chart rendering failed: ${getSafe(() => chartError.message, 'Unknown error')}`); // Don't re-throw, just log
        }
    }

    function updateUIDisplayFromAI(data) {
        console.log("Updating AI display UI...");
        try {
            const aiOutput            = getSafe(() => data.aiOutput, {});
            const analysisEl          = document.getElementById('aiAnalysis');
            const recommendationsList = document.getElementById('recommendationsList');
            const progressContentEl   = document.getElementById('progressContent');

            /* ---- AI analysis text ---- */
            // Using textContent first and then converting newlines for safety against unexpected HTML
            const rawAnalysis = getSafe(() => aiOutput.analysis, 'Analysis not available.');
            const formattedAnalysis = rawAnalysis
                .replace(/\\n/g, '\n')   // literal “\n” → newline
                .replace(/\n/g, '<br>'); // newline      → <br>
            if (analysisEl) updateElementHTML('aiAnalysis', formattedAnalysis);
             else { console.warn("AI analysis element not found."); }


            /* ---- Recommendations ---- */
            if (recommendationsList) {
                const rawRecs = getSafe(() => aiOutput.recommendations, '');
                const items = rawRecs
                    .split(/\r?\n/)
                    .map(t => t.trim())
                    .filter(Boolean);
                recommendationsList.innerHTML = items.length
                    ? items.map(txt => `<li>${txt}</li>`).join('')
                    : '<li class="text-gray-500">No recommendations available.</li>';
            } else { console.warn("Recommendations list element not found."); }

            /* ---- Progress history ---- */
            if (progressContentEl) {
                const rawProgress = getSafe(() => aiOutput.userProgress, 'No progress history available.');
                 const formattedProgress = rawProgress.replace(/\\n/g, '\n'); // literal “\n” → newline for modal pre-wrap
                progressContentEl.textContent = formattedProgress; // Use textContent for pre
            } else { console.warn("Progress content element not found."); }
            console.log("AI display UI updated.");
        } catch (e) {
            console.error("Error updating AI display UI:", e);
        }
    }

    // --- Chat Functionality ---
    // --- Chat Functionality ---
    function initializeChat() { // Renamed from updateUIBasedOnAccess temporarily for clarity
        console.log("--- initializeChat START ---");

        // Cache chat elements here if not already done
        chatInterfaceCardElement = chatInterfaceCardElement || document.getElementById('chatInterfaceCard');
        const chatInput = document.getElementById('chatInput');
        const chatSendButton = document.getElementById('chatSendButton');
        const chatHistory = document.getElementById('chatHistory');

        if (!chatInput || !chatSendButton || !chatHistory || !chatInterfaceCardElement) {
            console.error("One or more Chat UI elements not found! Aborting chat initialization.");
            if (chatInterfaceCardElement) chatInterfaceCardElement.style.display = 'none';
            enableChatInput(false);
            setChatStatus("Chat UI elements missing", false);
            return;
        }

        // SIMPLIFIED CHECK: Ensure Supabase client exists and fetch is available
        const isReadyForChat = supabase && typeof fetch === 'function';
        console.log("Is environment ready for chat (Supabase client + fetch)?", isReadyForChat);

        // Determine if chat CAN be enabled based on user/usage (from global state)
        const canEnableChat = currentUserId && initialUsageInfo && !initialUsageInfo.error && initialUsageInfo.usage < initialUsageInfo.limit;
        console.log("Can chat be enabled based on user/usage state?", canEnableChat);

        if (isReadyForChat && canEnableChat) {
            chatInterfaceCardElement.style.display = 'block'; // Show the card
            enableChatInput(true); // Enable input fields
            setChatStatus("Ready to chat", false); // Set status

            // Clear and rebuild chat history display based on chatMessages array
            chatHistory.innerHTML = '';
            if (chatMessages.length === 0) {
                // Add initial assistant message only if chat history is empty
                const initialMsgContent = "Hello! Ask me anything about the financial data shown on your dashboard.";
                addMessageToChat("Assistant", initialMsgContent, false);
                // Don't push initial greeting to history array unless you want it saved/resent
                // chatMessages.push({ role: "assistant", content: initialMsgContent });
            } else {
                // Restore previous messages from history array
                chatMessages.forEach(msg => addMessageToChat(msg.role.charAt(0).toUpperCase() + msg.role.slice(1), msg.content));
            }
            // Scroll to the latest message after loading history
            chatHistory.scrollTop = chatHistory.scrollHeight;

            // Ensure listeners are attached only once or re-attached correctly
            chatSendButton.removeEventListener('click', handleChatSubmit);
            chatInput.removeEventListener('keydown', handleChatEnterKey);
            chatInput.removeEventListener('input', autoGrowTextarea);

            chatSendButton.addEventListener('click', handleChatSubmit);
            chatInput.addEventListener('keydown', handleChatEnterKey);
            chatInput.addEventListener('input', autoGrowTextarea);
            autoGrowTextarea({ target: chatInput }); // Adjust height initially

            console.log("Chat UI initialized and enabled.");

        } else {
            // Chat cannot be enabled - figure out why and set status
            console.log("Chat setup skipped or disabled. Reasons:", {
                 isReadyForChat,
                 canEnableChat,
                 hasUserId: !!currentUserId,
                 hasUsageInfo: !!initialUsageInfo,
                 usageInfoError: initialUsageInfo?.error,
                 limitReached: initialUsageInfo && initialUsageInfo.usage >= initialUsageInfo.limit
            });
            if (chatInterfaceCardElement) chatInterfaceCardElement.style.display = 'none'; // Ensure hidden
            enableChatInput(false);

            // Set appropriate status message
            if (!initialUsageInfo) {
                 setChatStatus("Loading access info...", true);
            } else if (initialUsageInfo.error) {
                 setChatStatus("Chat unavailable - Access Error", false);
            } else if (!isReadyForChat) {
                 setChatStatus("Chat unavailable - Service Offline", false);
            } else if (!currentUserId) {
                 setChatStatus("Chat unavailable - Authentication needed", false);
            } else if (initialUsageInfo.usage >= initialUsageInfo.limit) {
                 setChatStatus("Weekly token limit reached", false);
                 if (chatInterfaceCardElement) chatInterfaceCardElement.style.display = 'block'; // Show card but disabled
            } else {
                  setChatStatus("Chat unavailable", false); // Generic fallback
            }
        }
        console.log("--- initializeChat END ---");
    }

    function handleChatEnterKey(event) {
        if (event.key === 'Enter' && !event.shiftKey) { // Send on Enter, allow Shift+Enter for newline
            event.preventDefault(); // Prevent default newline insertion
            handleChatSubmit(); // Trigger send action
        }
    }

    function autoGrowTextarea(event) {
        const textarea = event.target;
        textarea.style.height = 'auto'; // Temporarily shrink to base height
        // Calculate the desired height: at least 88px, based on scrollHeight, max 120px
        const minHeight = 88; // Define minimum height here
        const maxHeight = 120; // Define maximum height here (matches CSS)
        textarea.style.height = Math.min(Math.max(textarea.scrollHeight, minHeight), maxHeight) + 'px'; // <-- MODIFIED CALCULATION
    }

    function enableChatInput(enabled) {
        const chatInput = document.getElementById('chatInput');
        const chatSendButton = document.getElementById('chatSendButton');
        if (chatInput && chatSendButton) {
            chatInput.disabled = !enabled;
            chatSendButton.disabled = !enabled;
            chatInput.placeholder = enabled ? "Ask about your finances..." : "Chat unavailable";
            // Adjust visual state
            chatInput.style.opacity = enabled ? '1' : '0.6';
            chatSendButton.style.opacity = enabled ? '1' : '0.6';
            chatSendButton.style.cursor = enabled ? 'pointer' : 'not-allowed';
             if (!enabled) chatInput.value = ''; // Clear input if disabling
        } else {
            console.warn("Could not find chat input or send button to enable/disable.");
        }
    }

    function addMessageToChat(sender, message, isError = false) {
        const chatHistory = document.getElementById('chatHistory');
        if (!chatHistory) {
            console.error("Chat history element not found.");
            return;
        }

        const messageContainer = document.createElement('div');
        // Sanitize sender string for class name just in case
        const senderClass = sender ? sender.toLowerCase().replace(/[^a-z0-9]/g, '') : 'system'; // Default to system
        messageContainer.classList.add('chat-message', senderClass);

        const bubble = document.createElement('div');
        bubble.classList.add('message-bubble');

        if (isError) { // Style error messages distinctly within the bubble
            bubble.style.backgroundColor = '#fee2e2'; // Tailwind red-100
            bubble.style.color = '#b91c1c'; // Tailwind red-700
            bubble.style.borderColor = '#fca5a5'; // Tailwind red-300
            bubble.style.borderWidth = '1px';
            bubble.style.borderStyle = 'solid';
        }

        // Basic Markdown-like link handling: [text](url) -> <a href="url">text</a>
        // Basic bold handling: **text** -> <strong>text</strong>
        // Convert newlines to <br> for HTML display
         // Basic sanitization: replace < and > to prevent simple injection
        const safeMessage = message.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        const formattedMessage = safeMessage
            .replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer" class="text-indigo-600 hover:underline font-medium">$1</a>')
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Handle bold
            .replace(/\n/g, '<br>'); // Convert newlines

        bubble.innerHTML = formattedMessage; // Assign the processed HTML
        messageContainer.appendChild(bubble);
        chatHistory.appendChild(messageContainer);

        // Scroll to the bottom smoothly
        chatHistory.scrollTo({ top: chatHistory.scrollHeight, behavior: 'smooth' });
    }

    function setChatStatus(message, isLoading = false) {
        const chatStatus = document.getElementById('chatStatus');
        if (!chatStatus) return;
        if (isLoading) {
            // Use the typing indicator HTML structure
            chatStatus.innerHTML = `<div class="typing-indicator"><span></span><span></span><span></span></div> ${message || 'Thinking...'}`;
        } else {
            chatStatus.textContent = message; // Display simple text message
            // Auto-clear status message after a few seconds unless it's an error or empty
            if (message && !/error|failed|unavailable|limit/i.test(message)) { // Don't auto-clear error or limit messages
                setTimeout(() => {
                    // Only clear if the message hasn't changed in the meantime
                    if (chatStatus.textContent === message) chatStatus.textContent = '';
                }, 4000);
            }
        }
    }

   async function sendToBackendChatFunction() {
        console.log("Attempting to send chat message to backend...");
        // Ensure dashboard data is loaded before proceeding
        if (!dashboardData?.userInput) {
            addMessageToChat("System", "Error: Financial data seems incomplete. Cannot process chat request.", true);
            setChatStatus("Error: Data missing", false);
            return;
        }
        // Ensure Supabase client is ready and we have a user ID/tier
         if (!supabase || typeof supabase.functions?.invoke !== 'function' || !currentUserId || !effectiveTier || !initialUsageInfo || initialUsageInfo.error || initialUsageInfo.usage >= initialUsageInfo.limit) {
             console.error("Chat prerequisites not met:", { supabaseReady: !!supabase, hasInvoke: typeof supabase?.functions?.invoke === 'function', hasUserId: !!currentUserId, hasTier: !!effectiveTier, hasUsageInfo: !!initialUsageInfo, usageError: initialUsageInfo?.error, limitReached: initialUsageInfo?.usage >= initialUsageInfo?.limit });
             addMessageToChat("System", "Error: Chat service is not available. Please check access or refresh the page.", true);
             setChatStatus("Chat unavailable", false);
             enableChatInput(false); // Ensure disabled
             return;
         }


        setChatStatus("Thinking...", true); // Show loading indicator
        enableChatInput(false); // Disable input while processing

        // --- Prepare Context String (More Comprehensive) ---
        let financialContext = `User: ${getSafe(() => dashboardData.userInput.personalInfo.userName)}, Age: ${getSafe(() => dashboardData.userInput.personalInfo.age)}\n`;
        // Use cached totals/ratios if they exist, otherwise recalculate (safer to recalculate)
        try {
             const totals = calculateTotals(dashboardData); // Recalculate for fresh context
             const ratios = calculateRatios(dashboardData, totals); // Calculate ratios for context
             financialContext += `Monthly Totals: Income: ${formatCurrency(totals.totalIncome)}, Expenses: ${formatCurrency(totals.totalExpenses)}, Net Flow: ${formatCurrency(totals.netFlow)}\n`;
             financialContext += `Savings Balances: Emergency: ${formatCurrency(getSafe(()=>dashboardData.userInput.savings.emergency))}, General: ${formatCurrency(getSafe(()=>dashboardData.userInput.savings.savings))}, Retirement: ${formatCurrency(getSafe(()=>dashboardData.userInput.savings.retirement))}\n`;
             financialContext += `Debt: Total Balance: ${formatCurrency(totals.totalDebt)}, Total Min Payments: ${formatCurrency(totals.totalMinPayments)}\n`;
             financialContext += `Ratios: Savings Rate: ${formatPercentage(ratios.savingsRate, 1)}, Emergency Coverage: ${ratios.emergencyCoverage === Infinity ? 'N/A' : ratios.emergencyCoverage.toFixed(1)} months, DTI: ${formatPercentage(ratios.dtiRatio, 1)}\n`;

             if (dashboardData.userInput.debts && dashboardData.userInput.debts.length > 0) {
                 financialContext += "Debts Breakdown:\n";
                 dashboardData.userInput.debts.forEach(d => {
                     financialContext += ` - ${getSafe(() => d.type, 'Debt')}: Bal ${formatCurrency(getSafe(() => d.balance))}, Rate ${getSafe(() => d.interestRate, 0)}%, Min Pmt ${formatCurrency(getSafe(() => d.minPayment))}\n`;
                 });
             }
        } catch (e) {
             console.error("Error generating financial context for chat:", e);
             financialContext += "Error generating detailed financial context.\n";
        }


        const priorAnalysis = getSafe(() => dashboardData.aiOutput.analysis);
        const priorRecs = getSafe(() => dashboardData.aiOutput.recommendations);

        // Add prior analysis/recs if they are not just placeholders
        if (priorAnalysis && !/not available|to be determined/i.test(priorAnalysis)) financialContext += `Prior Analysis Summary: ${priorAnalysis.substring(0, 500)}...\n`; // Limit length
        if (priorRecs && !/not available|to be determined/i.test(priorRecs)) financialContext += `Prior Recommendations Summary: ${priorRecs.substring(0, 500)}...\n`; // Limit length


        // --- Construct messages payload ---
        const maxHistory = 6; // Keep recent messages + system message
        // Ensure recentMessages are actual message objects with role and content
        const recentMessages = chatMessages.slice(-maxHistory).filter(msg => msg && msg.role && msg.content);
        const systemMessage = {
            role: "system",
            content: `You are SmartWealth AI, a helpful financial assistant. Use the provided financial context ONLY to answer the user's questions concisely and directly related to their financial situation. Do not provide generic financial advice unless asked. Financial Context:\n${financialContext}`
        };
        const messagesForBackend = [systemMessage, ...recentMessages];

        const functionName = 'smooth-function'; // Ensure this matches your deployed Supabase function name

        console.log(`Invoking Supabase function '${functionName}' for user ${currentUserId}, tier ${effectiveTier}.`);
        console.log("Messages sent to backend:", messagesForBackend);


        try {
            // Invoke the Supabase Function using fetch with proper headers
            const response = await fetch(`${SUPABASE_URL}/functions/v1/${functionName}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`, // Use ANON key for client-side function invocation
                    'x-user-id': currentUserId, // Crucial header
                    'x-user-tier': effectiveTier // Crucial header
                },
                body: JSON.stringify({
                    messages: messagesForBackend,
                    // model: CHAT_MODEL // Backend determines the model, don't send from client
                })
            }); // <<< fetch ends here

            // --- ADDED RESPONSE HANDLING ---
            if (!response.ok) {
                // Try to parse error from backend, provide fallback message
                let errorMsg = `Request failed with status ${response.status}`;
                try {
                    // Use .json() to get the error message sent from the Edge Function
                    const errorData = await response.json();
                    errorMsg = errorData?.error || errorMsg; // Use backend error message if available
                } catch (e) {
                    // If parsing error body fails, use the status text
                    errorMsg = response.statusText || errorMsg;
                    console.warn("Could not parse error response body:", e);
                }
                // Log the detailed error before throwing
                console.error(`Backend returned error: ${response.status} - ${errorMsg}`);
                throw new Error(errorMsg); // Throw error to be caught below
            }

            // Parse the successful response
            const result = await response.json();

            // Check the expected response structure from 'smooth-function'
            if (result && result.assistantResponse && typeof result.assistantResponse.content === 'string') {
                addMessageToChat("Assistant", result.assistantResponse.content);
                // Add the assistant response to the history array as well
                chatMessages.push({ role: "assistant", content: result.assistantResponse.content });
                setChatStatus("", false); // Clear "Thinking..." status

                // Re-fetch initial usage info after a successful chat message
                // This updates the frontend usage display. Use a slight delay.
                setTimeout(fetchInitialUsage, 1000); // Add small delay

            } else {
                // Handle cases where the response is OK (200) but the format isn't right
                console.error("Invalid response format from backend:", result);
                throw new Error("Received an invalid response format from the chat service.");
            }
            // --- END OF ADDED RESPONSE HANDLING ---

        } catch (err) { // Catch errors from fetch() or the handling block above
            console.error("Chat function invocation failed:", err);
            // Display the error message from the caught error
            addMessageToChat("System", "Error calling chat service: " + (err.message || "Unknown error"), true);
            setChatStatus("Error sending message", false);
        } finally {
            enableChatInput(true); // Re-enable input
            console.log("Chat request finished.");
        }
    }
    // --- Event Handlers & Button Initializers ---
    function handleChatSubmit() {
        const chatInput = document.getElementById('chatInput');
        if (!chatInput) return; // Safety check

        const userMessage = chatInput.value.trim();
        if (!userMessage || chatInput.disabled) return; // Don't send empty messages or if disabled

        addMessageToChat("User", userMessage);
        chatMessages.push({ role: "user", content: userMessage }); // Add user message to history array
        chatInput.value = ''; // Clear input field
        chatInput.style.height = 'auto'; // Reset height after send
        chatInput.style.height = '44px'; // Force back to original size (or autoGrow) - autoGrow listener will handle it

        sendToBackendChatFunction(); // Call backend function
    }

    // Helper function to show initial message when no data is found
    function showInitialPromptOrMessage(message = "Please sign in with Google to load or save your financial dashboard.") { // Updated default message
        console.log("Executing showInitialPromptOrMessage");
        hideAllMainContentAreas(); // Hide everything else first

        // Show the Google Sign-In button specifically
        const signInButton = document.getElementById('googleSignInButton');
         if (signInButton) {
             signInButton.style.display = 'inline-block';
         } else {
             console.error("Google Sign-In button not found!");
         }


        // Prefer showing the structured upload prompt if available (maybe as fallback)
        // if (initialUploadPrompt) { initialUploadPrompt.style.display = 'block'; console.log("Displayed initial upload prompt."); }
        // else
        if (initialMessageElement) {
             // Fallback to simple message if prompt not found
            initialMessageElement.textContent = message;
            initialMessageElement.style.display = 'block';
            console.log("Displayed fallback initial message element.");
        } else {
             console.warn("Could not find initial prompt or message elements.");
        }


        // Ensure chat is hidden if we revert to the initial state
        if (chatInterfaceCardElement) { chatInterfaceCardElement.style.display = 'none'; }
        enableChatInput(false); // Disable chat input as well
         setChatStatus("Sign in required", false); // Update initial status
    }
      
    // --- Modals ---
    function initModals() {
        console.log("Initializing modals...");
        // Close modal if clicking on the background overlay
        window.addEventListener('click', function(event) {
            const modals = document.getElementsByClassName('modal');
            for (let i = 0; i < modals.length; i++) {
                if (event.target == modals[i]) { // Check if the click target is the modal background itself
                    closeModal(modals[i].id); // Close the modal using its ID
                }
            }
        });
        // Add ESC key listener to close modals
        document.addEventListener('keydown', function(event) {
            if (event.key === "Escape") {
                const modals = document.getElementsByClassName('modal');
                for (let i = 0; i < modals.length; i++) {
                    if (modals[i].style.display === "block") {
                        closeModal(modals[i].id);
                        event.preventDefault(); // Prevent other escape handlers
                        break; // Only close one modal at a time
                    }
                }
            }
        });
         console.log("Modals initialized.");
    }

    function openModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            // Optional: Refresh modal content if dynamic before showing
            if(modalId === 'progressModal' && dashboardData?.aiOutput) {
                const progressContentEl = document.getElementById('progressContent');
                if(progressContentEl) {
                    const rawProgress = getSafe(() => dashboardData.aiOutput.userProgress, 'No progress history available.');
                    const formattedProgress = rawProgress.replace(/\\n/g, '\n');
                    progressContentEl.textContent = formattedProgress; // Use textContent for pre
                }
            }
            modal.style.display = "block";
        } else { console.warn(`Modal with ID ${modalId} not found.`); }
    }

    function closeModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = "none";
        }
    }

    /* --- Save Summary workflow --- */
    async function generateAndSaveSummary() {
        console.log("Generating and saving summary...");
        if (!dashboardData || !dashboardData.userInput) {
            alert("Please load financial data before generating a summary.");
            return;
        }
        // Check chat prerequisites for summary generation (uses same backend function)
         if (!supabase || typeof supabase.functions?.invoke !== 'function' || !currentUserId || !effectiveTier || !initialUsageInfo || initialUsageInfo.error || initialUsageInfo.usage >= initialUsageInfo.limit) {
             console.error("Summary generation prerequisites not met:", { supabaseReady: !!supabase, hasInvoke: typeof supabase?.functions?.invoke === 'function', hasUserId: !!currentUserId, hasTier: !!effectiveTier, hasUsageInfo: !!initialUsageInfo, usageError: initialUsageInfo?.error, limitReached: initialUsageInfo?.usage >= initialUsageInfo?.limit });
             addMessageToChat("System", "Error: Cannot generate summary. Service is unavailable or limit reached.", true);
             setChatStatus("Summary failed", false);
             return;
         }


        try {
            setChatStatus("Generating & Saving Summary…", true);
            enableChatInput(false); // Disable input during this operation

            // --- Prepare context for summary generation ---
            let summaryContext = `Generate a concise financial analysis summary (around 100-150 words) and 3-5 key recommendations based on the following user data. Focus on strengths, weaknesses (like debt or low savings), and actionable steps. Use simple language. Include a timestamp in the summary text.\n\nUser: ${getSafe(() => dashboardData.userInput.personalInfo.userName)}\n`;
            // Use cached totals/ratios if they exist, otherwise recalculate (safer to recalculate)
             try {
                 const totals = calculateTotals(dashboardData);
                 const ratios = calculateRatios(dashboardData, totals);
                 summaryContext += `Income: ${formatCurrency(totals.totalIncome)}, Expenses: ${formatCurrency(totals.totalExpenses)}, Net: ${formatCurrency(totals.netFlow)}\n`;
                 summaryContext += `Savings: ${formatCurrency(totals.totalSavings)}, Debt: ${formatCurrency(totals.totalDebt)}\n`;
                 summaryContext += `Key Ratios: Savings Rate: ${formatPercentage(ratios.savingsRate)}, DTI: ${formatPercentage(ratios.dtiRatio)}, Emergency: ${ratios.emergencyCoverage === Infinity ? 'N/A' : ratios.emergencyCoverage.toFixed(1)} months\n`;
                 summaryContext += `Challenges: ${getSafe(()=>dashboardData.userInput.financials.challenges)}\n`;
                 summaryContext += `Goals: ${getSafe(()=>dashboardData.userInput.financials.upcomingPurchase)}\n`;
                 summaryContext += `Full Data Object: ${JSON.stringify(dashboardData.userInput, null, 2)}\n`; // Provide full data for better analysis
             } catch (e) {
                 console.error("Error generating summary context:", e);
                 summaryContext += "Error generating detailed financial context.\n";
             }


            // --- Call the specific Supabase function for SUMMARY ---
            // NOTE: This assumes your backend function 'smooth-function' is capable
            // of handling a specific instruction/message structure to trigger summary generation
            // vs conversational chat. You might need a separate function for this,
            // or modify 'smooth-function' to detect a 'generate_summary' flag or specific prompt.
            // For this example, I'll structure the prompt to guide the AI.
            // A dedicated function 'generate-financial-summary' would be cleaner if you have one.

            const messagesForSummary = [
                 { role: "system", content: summaryContext },
                 { role: "user", content: "Generate the financial analysis summary and recommendations based on the data provided in the system message. Format the summary first, then list recommendations starting with '- '." }
            ];

            const functionName = 'smooth-function'; // Or your dedicated summary function name

            console.log(`Invoking Supabase function '${functionName}' for summary generation.`);


            const response = await fetch(`${SUPABASE_URL}/functions/v1/${functionName}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                    'x-user-id': currentUserId, // Crucial header
                    'x-user-tier': effectiveTier // Crucial header
                },
                body: JSON.stringify({
                    messages: messagesForSummary,
                    // model: CHAT_MODEL // Backend determines model
                })
            });

            const result = await response.json();

            if (!response.ok) {
                let errorMsg = `Summary generation failed with status ${response.status}`;
                 try {
                     const errorData = await response.json();
                     errorMsg = errorData?.error || errorMsg;
                 } catch (e) { /* ignore parse error */ }
                throw new Error(errorMsg);
            }

            // --- Update UI and Data Object ---
            if (result && result.assistantResponse && typeof result.assistantResponse.content === 'string') {
                const fullText = result.assistantResponse.content;
                // Attempt to split into analysis and recommendations
                 const recsMarker = fullText.indexOf('- '); // Simple check for start of recommendations
                 let analysis = fullText;
                 let recommendations = '';

                 if (recsMarker > -1) {
                      analysis = fullText.substring(0, recsMarker).trim();
                      recommendations = fullText.substring(recsMarker).trim();
                 }
                 // Ensure analysis isn't empty if split happened awkwardly
                 if (analysis === '' && fullText.length > 0) analysis = fullText;


                // Update the aiOutput section of your main data object
                if (dashboardData && dashboardData.aiOutput) {
                    dashboardData.aiOutput.analysis = analysis; // Use parsed analysis
                    dashboardData.aiOutput.recommendations = recommendations; // Use parsed recommendations

                    // Add a timestamp and note to progress history
                    const now = new Date();
                    const progressUpdate = `\n${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}: AI Summary generated.`;
                    dashboardData.aiOutput.userProgress = (dashboardData.aiOutput.userProgress || '') + progressUpdate;

                    updateUIDisplayFromAI(dashboardData); // Refresh the AI section display
                    setChatStatus("Summary saved to report ✅", false);
                    addMessageToChat("System", "A new AI summary has been generated and saved to the report data.");
                } else {
                     console.error("dashboardData or aiOutput structure missing for saving summary.");
                     throw new Error("Could not save summary to internal data.");
                }
                 // Re-fetch usage after summary generation
                 setTimeout(fetchInitialUsage, 1000); // Add small delay


            } else {
                console.error("Summary function returned an unexpected format:", result);
                throw new Error("Received an invalid response format from the summary service.");
            }

        } catch (err) {
            console.error("Summary generation/saving failed:", err);
            addMessageToChat("System", "Couldn't generate or save summary: " + (err.message || "Unknown error"), true);
            setChatStatus("Summary failed", false);
        } finally {
            enableChatInput(true); // Re-enable input
             setChatStatus("", false); // Clear status message after a delay
        }
    }

        /* --- Generate New Analysis Workflow --- */
    async function generateAndDisplayNewSummary() {
        console.log("Generating and displaying new analysis/recommendations...");

        if (!dashboardData || !dashboardData.userInput) {
            alert("Please load financial data before generating an analysis.");
            return;
        }

        // Check chat prerequisites (same as chat/save summary)
         if (!supabase || typeof supabase.functions?.invoke !== 'function' || !currentUserId || !effectiveTier || !initialUsageInfo || initialUsageInfo.error || initialUsageInfo.usage >= initialUsageInfo.limit) {
             console.error("Analysis generation prerequisites not met:", { supabaseReady: !!supabase, hasInvoke: typeof supabase?.functions?.invoke === 'function', hasUserId: !!currentUserId, hasTier: !!effectiveTier, hasUsageInfo: !!initialUsageInfo, usageError: initialUsageInfo?.error, limitReached: initialUsageInfo?.usage >= initialUsageInfo?.limit });
             addMessageToChat("System", "Error: Cannot generate analysis. Service is unavailable or limit reached.", true);
             setChatStatus("Analysis failed", false);
             return;
         }

        const generateButton = document.getElementById('generateAnalysisBtn');
        const saveButton = document.getElementById('saveSummaryBtn'); // Also disable save while generating

        try {
            setChatStatus("Generating Analysis...", true);
            enableChatInput(false); // Disable chat input during generation
            if (generateButton) generateButton.disabled = true;
            if (saveButton) saveButton.disabled = true; // Disable save button

            // --- Prepare Comprehensive Context for AI ---
            let fullContext = `Generate a financial analysis summary (around 100-150 words) and 3-5 key recommendations based on the following user's financial data AND their conversation history. Focus on strengths, weaknesses (like debt or low savings), actionable steps discussed in chat, and incorporate information from the prior analysis if relevant. Use simple language. Format the summary first, then list recommendations starting with '- '. Include a timestamp in the summary text.\n\n`;

            // Add financial data context
            fullContext += `--- Financial Data ---\n`;
            try {
                const totals = calculateTotals(dashboardData); // Recalculate for fresh context
                const ratios = calculateRatios(dashboardData, totals); // Calculate ratios for context
                fullContext += `User: ${getSafe(() => dashboardData.userInput.personalInfo.userName)}, Age: ${getSafe(() => dashboardData.userInput.personalInfo.age)}\n`;
                fullContext += `Monthly Totals: Income: ${formatCurrency(totals.totalIncome)}, Expenses: ${formatCurrency(totals.totalExpenses)}, Net Flow: ${formatCurrency(totals.netFlow)}\n`;
                fullContext += `Savings Balances: Emergency: ${formatCurrency(getSafe(()=>dashboardData.userInput.savings.emergency))}, General: ${formatCurrency(getSafe(()=>dashboardData.userInput.savings.savings))}, Retirement: ${formatCurrency(getSafe(()=>dashboardData.userInput.retirement))}\n`;
                fullContext += `Debt: Total Balance: ${formatCurrency(totals.totalDebt)}, Total Min Payments: ${formatCurrency(totals.totalMinPayments)}\n`;
                fullContext += `Ratios: Savings Rate: ${formatPercentage(ratios.savingsRate, 1)}, Emergency Coverage: ${ratios.emergencyCoverage === Infinity ? 'N/A' : ratios.emergencyCoverage.toFixed(1)} months, DTI: ${formatPercentage(ratios.dtiRatio, 1)}\n`;
                 if (dashboardData.userInput.debts && dashboardData.userInput.debts.length > 0) {
                     fullContext += "Debts Breakdown:\n";
                     dashboardData.userInput.debts.forEach(d => {
                         fullContext += ` - ${getSafe(() => d.type, 'Debt')}: Bal ${formatCurrency(getSafe(() => d.balance))}, Rate ${getSafe(() => d.interestRate, 0)}%, Min Pmt ${formatCurrency(getSafe(() => d.minPayment))}\n`;
                     });
                 }
                 fullContext += `Challenges: ${getSafe(()=>dashboardData.userInput.financials.challenges)}\n`;
                 fullContext += `Goals: ${getSafe(()=>dashboardData.userInput.financials.upcomingPurchase)}\n`;
                 const priorAnalysis = getSafe(() => dashboardData.aiOutput.analysis);
                 const priorRecs = getSafe(() => dashboardData.aiOutput.recommendations);
                 if (priorAnalysis && !/not available|to be determined/i.test(priorAnalysis)) fullContext += `Prior Dashboard Analysis: ${priorAnalysis.substring(0, 500)}...\n`; // Include prior analysis
                 if (priorRecs && !/not available|to be determined/i.test(priorRecs)) fullContext += `Prior Dashboard Recommendations: ${priorRecs.substring(0, 500)}...\n`; // Include prior recommendations

            } catch (e) {
                console.error("Error generating financial context for analysis:", e);
                fullContext += "Error generating detailed financial context.\n";
            }

            // Add chat history context
            fullContext += `\n--- Chat History ---\n`;
            if (chatMessages.length > 0) {
                 // Include relevant parts of chat history, possibly summarizing it if very long
                 const chatHistoryContext = chatMessages
                    .map(msg => `${msg.role.toUpperCase()}: ${msg.content}`) // Format messages
                    .slice(-15) // Limit to last 15 messages to keep context manageable
                    .join('\n');
                 fullContext += chatHistoryContext;
            } else {
                 fullContext += "No chat history in this session.\n";
            }
             fullContext += `\n---\n`;


            // --- Construct messages payload for backend (using the full context in a system message) ---
            const messagesForBackend = [
                 { role: "system", content: fullContext },
                 // A user message prompting the AI to perform the task based on the system context
                 { role: "user", content: "Generate the financial analysis summary and recommendations based on the provided financial data and chat history. Format the summary first, then list recommendations starting with '- '." }
            ];


            const functionName = 'smooth-function'; // Assuming smooth-function can handle this prompt structure

            console.log(`Invoking Supabase function '${functionName}' for analysis generation.`);
            console.log("Context sent to backend:", messagesForBackend[0].content); // Log context
            console.log("Prompt sent to backend:", messagesForBackend[1].content); // Log prompt


            const response = await fetch(`${SUPABASE_URL}/functions/v1/${functionName}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                    'x-user-id': currentUserId, // Crucial header
                    'x-user-tier': effectiveTier // Crucial header
                },
                body: JSON.stringify({
                    messages: messagesForBackend,
                    // model: CHAT_MODEL // Backend determines model
                })
            });

            // --- Handle Backend Response ---
            if (!response.ok) {
                let errorMsg = `Analysis generation failed with status ${response.status}`;
                 try {
                     const errorData = await response.json();
                     errorMsg = errorData?.error || errorMsg;
                 } catch (e) { /* ignore parse error */ }
                console.error(`Backend returned error during analysis generation: ${response.status} - ${errorMsg}`);
                throw new Error(errorMsg);
            }

            const result = await response.json();

            // Expecting the backend to return the generated text in assistantResponse.content
            if (result && result.assistantResponse && typeof result.assistantResponse.content === 'string') {
                const fullText = result.assistantResponse.content;

                // Attempt to split the AI's response into Analysis and Recommendations
                const recsMarker = fullText.indexOf('- '); // Look for the start of recommendations
                let analysis = fullText;
                let recommendations = '';

                if (recsMarker > -1) {
                     // If '-' is found, split into analysis (before '-') and recommendations (from '-')
                     analysis = fullText.substring(0, recsMarker).trim();
                     recommendations = fullText.substring(recsMarker).trim();
                }
                // Fallback: If splitting resulted in an empty analysis but there was text, use the full text as analysis
                if (analysis === '' && fullText.length > 0) {
                     analysis = fullText;
                     recommendations = ''; // Clear recommendations if splitting failed
                }


                console.log("AI Analysis Generated:", analysis);
                console.log("AI Recommendations Generated:", recommendations);


                // --- Update UI and Data Object ---
                if (dashboardData && dashboardData.aiOutput) {
                    dashboardData.aiOutput.analysis = analysis; // Update analysis
                    dashboardData.aiOutput.recommendations = recommendations; // Update recommendations

                    // Add a timestamp and note to user progress history
                    const now = new Date();
                    const progressUpdate = `\n${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}: New AI Analysis generated.`;
                    dashboardData.aiOutput.userProgress = (dashboardData.aiOutput.userProgress || '').trim() + progressUpdate; // Append to existing history

                    // Refresh the AI section display on the dashboard
                    updateUIDisplayFromAI(dashboardData);

                    setChatStatus("Analysis generated and updated ✅", false);
                    // Add a system message to chat history indicating the update
                    addMessageToChat("System", "A new financial analysis and recommendations have been generated and updated on your dashboard.");

                } else {
                     console.error("dashboardData or aiOutput structure missing for saving analysis/recs.");
                     throw new Error("Could not update dashboard data with generated analysis.");
                }

                 // Re-fetch usage info after generation (as this costs tokens)
                 setTimeout(fetchInitialUsage, 1000); // Add slight delay

            } else {
                console.error("Analysis function returned an unexpected format:", result);
                throw new Error("Received an invalid response format from the analysis service.");
            }

        } catch (err) {
            console.error("Analysis generation failed:", err);
            addMessageToChat("System", "Couldn't generate analysis: " + (err.message || "Unknown error"), true);
            setChatStatus("Analysis failed", false);
        } finally {
            enableChatInput(true); // Re-enable chat input
             if (generateButton) generateButton.disabled = false; // Re-enable button
             if (saveButton) saveButton.disabled = false; // Re-enable save button
             // setChatStatus("", false); // Clear status message after a delay - done by setChatStatus itself
        }
    }
    
    /* --- Info popup support --- */
    function showInfo(text) {
        const infoModalText = document.getElementById('infoModalText');
        const infoModal = document.getElementById('infoModal');
        if(infoModalText && infoModal) {
            infoModalText.textContent = text; // Use textContent for safety
            openModal('infoModal');
        } else {
            console.warn("Info modal elements not found.");
            alert(text); // Fallback to simple alert
        }
    }

    function initInfoPopups() {
        console.log("Initializing info popups...");
        // Use event delegation on a parent container for potentially dynamic elements
        const mainContainer = document.getElementById('mainContent');
        if (mainContainer) {
            mainContainer.addEventListener('click', function(event) {
                // Find the closest ancestor with data-desc attribute
                const targetElement = event.target.closest('[data-desc]');
                if (targetElement) {
                    const description = targetElement.dataset.desc;
                    if (description) {
                        showInfo(description);
                    }
                }
            });
            console.log("Info popups initialized via event delegation.");
        } else {
            console.warn("Main content container not found for info popup delegation.");
        }
    }

    // Function to bundle Supabase/Core initializations
    function initializeSupabaseAndCoreFeatures() {
        console.log("Initializing Supabase client and core features...");
        try {
            // Initialize Supabase client - Check if window.supabase is available first
            if (!supabase) {
                 if (typeof window.supabase === 'undefined' || !window.supabase?.createClient) {
                     console.error("Supabase library (supabase-js) is not loaded. Cannot initialize client.");
                     // Proceed without Supabase client - chat will be disabled
                 } else {
                     const { createClient } = window.supabase;
                     // Use ANON key for client-side initialization
                     supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                     console.log("Supabase client initialized successfully.");
                 }
            } else {
                 console.log("Supabase client already initialized.");
            }


            // Initialize buttons, modals, popups etc. - These should run regardless of Supabase
            if (typeof initSaveButton === 'function') initSaveButton(); else console.warn("initSaveButton function not found.");
            if (typeof initUploadButton === 'function') initUploadButton(); else console.warn("initUploadButton function not found.");
            if (typeof initModals === 'function') initModals(); else console.warn("initModals function not found.");
            if (typeof initInfoPopups === 'function') initInfoPopups(); else console.warn("initInfoPopups function not found.");

            // Add listeners for error message buttons
            document.getElementById('retryButton')?.addEventListener('click', () => { location.reload(); });
            document.getElementById('manualEntryButton')?.addEventListener('click', useDemoData);
             // Setup save summary button
            document.getElementById('saveSummaryBtn')?.addEventListener('click', generateAndSaveSummary);
document.getElementById('generateAnalysisBtn')?.addEventListener('click', generateAndDisplayNewSummary);

            // Initial fetch for usage info and then update UI based on that access
            // This also handles initializing the chat UI
            fetchInitialUsage();


            // Ensure spinner is hidden finally if not already handled
            // This is also done by handleError and processAndDisplayData finally blocks,
            // but a final check here can't hurt if logic somehow bypasses others.
            // Removed this from here, let the specific flows manage the spinner.
            
        } catch (initError) {
            console.error("Error initializing Supabase/core features:", initError);
             // If core initialization fails, likely can't recover well. Use error handler.
             handleError("Core Initialization Failed", initError);
        }
    }

    // Helper function to show initial message when no data is found
    function showInitialPromptOrMessage(message = "Upload a PSR JSON file or parameter to view your dashboard.") {
        console.log("Executing showInitialPromptOrMessage");
        hideAllMainContentAreas(); // Hide everything else first

        // Prefer showing the structured upload prompt if available
        if (initialUploadPrompt) {
            initialUploadPrompt.style.display = 'block';
            console.log("Displayed initial upload prompt.");
        } else if (initialMessageElement) {
             // Fallback to simple message if prompt not found
            initialMessageElement.textContent = message;
            initialMessageElement.style.display = 'block';
            console.log("Displayed fallback initial message element.");
        } else {
             console.warn("Could not find initial prompt or message elements.");
        }

        // Ensure chat is hidden if we revert to the initial state
        if (chatInterfaceCardElement) {
            chatInterfaceCardElement.style.display = 'none';
        }
        enableChatInput(false); // Disable chat input as well
         setChatStatus("No data loaded", false);
    }

     // Helper to hide all potential main content/initial states
     function hideAllMainContentAreas() {
         if (loadingSpinner) loadingSpinner.style.display = 'none';
         if (errorMessageElement) errorMessageElement.style.display = 'none';
         if (mainContentElement) { mainContentElement.style.display = 'none'; mainContentElement.classList.add('hidden'); }
         if (initialMessageElement) initialMessageElement.style.display = 'none';
         if (initialUploadPrompt) initialUploadPrompt.style.display = 'none';
     }
    
    // --- MAIN Document Ready Event ---
    document.addEventListener('DOMContentLoaded', function() {
        console.log("DOM fully loaded. Initializing application...");

        // --- 1. Cache Global DOM Elements ---
        // Cache them safely, check for null later if needed
        loadingSpinner = document.getElementById('loadingSpinner');
        errorMessageElement = document.getElementById('errorMessage');
        mainContentElement = document.getElementById('mainContent');
        initialMessageElement = document.getElementById('initialMessage');
        initialUploadPrompt = document.getElementById('initialUploadPrompt');
        errorTextElement = document.getElementById('errorText');
        debugInfoElement = document.getElementById('debugInfo');
        fileInput = document.getElementById('fileInput');
        chatInterfaceCardElement = document.getElementById('chatInterfaceCard'); // Cache chat card


        // --- 2. Set Initial UI State ---
        // Hide all main content areas first, then show spinner
        hideAllMainContentAreas();
        if (loadingSpinner) {
            loadingSpinner.style.display = 'flex'; // Use flex for centering spinner
            console.log("Spinner shown.");
        } else {
             console.error("Loading spinner element not found!");
             // Cannot show spinner, proceed with caution
        }


        // --- 3. Initialization Flow ---
        try {
            // Get URL parameters once
            const params = parseUrlParams();

            // Check for the 'data=null' special case first
            if (params === null) {
                // parseUrlParams already logged warning.
                // Hide spinner and show the initial prompt state
                if (loadingSpinner) loadingSpinner.style.display = 'none';
                showInitialPromptOrMessage();
                initializeSupabaseAndCoreFeatures(); // Initialize other features (buttons, modals, maybe Supabase client)
                return; // Stop main initialization flow
            }

            // Parse the xtl parameter FIRST to get userId and effectiveTier
            const xtlParsedSuccessfully = parseXtlParameter(params);

            // Parse financial data from URL parameters regardless of XTL success
            dashboardData = parseDataFromUrlParams(params) || {}; // Use || {} to ensure it's an object

            // Initialize Supabase and core features (buttons, modals, etc.)
            // This also triggers fetchInitialUsage and subsequent chat initialization
            initializeSupabaseAndCoreFeatures();


            // Determine which main content state to show based on data and auth status
            if (Object.keys(dashboardData.userInput || {}).length > 0 && dashboardData.userInput.personalInfo) {
                 // Data was successfully parsed from URL params
                 console.log("Dashboard data parsed from URL. Processing and displaying.");
                 processAndDisplayData(dashboardData); // This handles showing mainContent and hiding spinner
            } else if (xtlParsedSuccessfully && currentUserId) {
                 // No dashboard data from URL, but XTL was valid.
                 // Show the main container structure as a shell, waiting for file upload.
                 console.log("No dashboard data in URL, but XTL valid. Showing empty main content shell.");
                 hideAllMainContentAreas();
                 if (mainContentElement) {
                    mainContentElement.style.display = 'block';
                    mainContentElement.classList.remove('hidden');
                 } else {
                     console.error("Main content element not found!");
                     handleError("Critical: Main content element not found.", new Error("DOM element #mainContent is missing."));
                 }
                 // Update UI elements to show "N/A" or default states explicitly
                 updateReportBasics({}, {}); // Pass empty objects to reset UI
                 updateRatiosDisplay({});
                 updateGoalsDisplay({}, {});
                 updateDebtsDisplay({}, {});
                 updateUIDisplayFromAI({});
                 renderCharts({}); // Attempt to render empty charts or messages

                 if (loadingSpinner) loadingSpinner.style.display = 'none'; // Hide spinner

            } else {
                 // No dashboard data from URL and no valid XTL.
                 console.log("No dashboard data or valid XTL. Showing initial prompt/message.");
                 if (loadingSpinner) loadingSpinner.style.display = 'none'; // Hide spinner
                 showInitialPromptOrMessage(); // Show the upload prompt or generic message
                 // Error message might already be showing if XTL parse failed (handleInvalidAccess)
            }


        } catch (error) {
            console.error("CRITICAL Error during initial setup:", error);
            // Use the central error handler for any unexpected errors during setup
            handleError("Critical Initialization Error", error);
        } finally {
            // The spinner hiding is now managed by the specific display paths (processAndDisplayData, handleError, showInitialPromptOrMessage).
            console.log("DOMContentLoaded finally block finished.");
        }
         window.addEventListener('resize', handleResize); // <-- ADD THIS LINE HERE
         console.log("Window resize listener added."); // <-- ADD THIS LOG HERE
    });

       // --- Google API Loading and Initialization ---
    // Load GIS (for authentication) and Gapi (for API calls) libraries
    function loadGoogleAPIs() {
        console.log("Loading Google APIs...");
        // Load GIS client library
        const scriptGIS = document.createElement('script');
        scriptGIS.src = 'https://accounts.google.com/gsi/client';
        scriptGIS.async = true;
        scriptGIS.defer = true;
        scriptGIS.onload = initializeGIS; // Initialize GIS once loaded
        document.head.appendChild(scriptGIS);

        // Load Gapi client library
        const scriptGapi = document.createElement('script');
        scriptGapi.src = 'https://apis.google.com/js/api.js';
        scriptGapi.async = true;
        scriptGapi.defer = true;
        scriptGapi.onload = handleGapiLoad; // Handle Gapi load
        document.head.appendChild(scriptGapi);
    }

    // Handle Gapi library load
    function handleGapiLoad() {
        console.log("Gapi library loaded.");
        // No immediate action here, gapi.client will be initialized later
        // after the user signs in and we get a token.
    }

    // Initialize GIS (Google Identity Services)
    function initializeGIS() {
        console.log("GIS library loaded. Initializing token client...");
        if (typeof google === 'undefined' || typeof google.accounts === 'undefined' || typeof google.accounts.oauth2 === 'undefined') {
             console.error("GIS library not available after load.");
             handleError("Google Sign-In Failed", new Error("Google Identity Services library did not load."));
             return;
        }

        try {
            googleTokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GOOGLE_CLIENT_ID,
                scope: GOOGLE_SCOPES,
                callback: handleGoogleTokenResponse, // Function to call when a token is received
            });
            console.log("GIS token client initialized.");

            // Once GIS is initialized, show the Sign-In button
             const signInButton = document.getElementById('googleSignInButton');
            if (signInButton) {
                 signInButton.style.display = 'inline-block'; // Show the sign-in button
                 // Add event listener for the sign-in button
                 signInButton.addEventListener('click', () => {
                     console.log("Sign in button clicked. Requesting token...");
                     if (googleTokenClient) {
                         googleTokenClient.requestAccessToken({ prompt: '' }); // Request token silently if possible, or prompt
                     } else {
                         console.error("Google token client not initialized.");
                         handleError("Google Sign-In Error", new Error("Google token client not ready."));
                     }
                 });
                 console.log("Google Sign-In button listener added.");
            } else {
                 console.error("Google Sign-In button element not found!");
            }

        } catch (e) {
             console.error("Error initializing GIS token client:", e);
             handleError("Google Sign-In Setup Failed", e);
        }
    }

    // Handle the response from the Google Token Client
    function handleGoogleTokenResponse(tokenResponse) {
        console.log("Google token response received:", tokenResponse);
        if (tokenResponse && tokenResponse.access_token) {
            googleAccessToken = tokenResponse.access_token;
            console.log("Access Token obtained:", googleAccessToken);

            // Inject the token into the gapi.client library
            if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined') {
                gapi.client.setToken({ access_token: googleAccessToken });
                console.log("Token set in gapi.client.");

                // Now that we have a token, load the Drive API library
                gapi.client.load('drive', 'v3', () => {
                    console.log("Google Drive API v3 loaded.");
                    // Drive API is ready to use now (gapi.client.drive)
                    updateDriveButtonVisibility(true); // Show Drive buttons, hide sign-in
                    fetchGoogleUserInfo(); // Fetch user info for display
                     // The main dashboard is likely already displayed, but chat/features might need re-init based on user ID/state
                    // The user ID for Supabase tracking is still managed by XTL or file upload data,
                    // not directly by Google Sign-In unless you link them.
                    // For now, keep Google sign-in separate from Supabase user ID for dashboard data/chat tracking.
                });

            } else {
                console.error("Gapi client not available to set token.");
                handleError("Google API Error", new Error("Google API client not fully loaded."));
            }

        } else {
            console.error("Google token response did not contain an access token.");
            handleError("Google Sign-In Failed", new Error("Could not obtain Google access token."));
        }
    }

    // Fetch basic Google User Info (optional, for displaying signed-in status)
    async function fetchGoogleUserInfo() {
        console.log("Fetching Google user info...");
        if (typeof gapi === 'undefined' || typeof gapi.client === 'undefined' || !gapi.client.getToken()) {
            console.warn("Gapi client not ready or no token to fetch user info.");
            return;
        }
        // Load the people API to get user info
        await gapi.client.load('oauth2', 'v2'); // Load OAuth2 API to get user info
        try {
            const response = await gapi.client.oauth2.userinfo.get();
            googleUser = response.result;
            console.log("Google User Info:", googleUser);
            // Optionally display user name
            // You might add an element like <span id="signedInUserDisplay"></span> in your HTML header
            const signedInUserDisplay = document.getElementById('signedInUserDisplay');
            if (signedInUserDisplay && googleUser?.name) {
                 signedInUserDisplay.textContent = `Signed in as: ${googleUser.name}`;
            }

        } catch (error) {
            console.error("Error fetching Google user info:", error);
        }
    }


    // Handle Google Sign Out
    function handleGoogleSignOut() {
        console.log("Signing out of Google...");
        if (googleAccessToken) {
            // Revoke the access token
            google.accounts.oauth2.revoke(googleAccessToken, () => {
                console.log("Google access token revoked.");
                // Clear token and user info
                googleAccessToken = null;
                googleUser = null;
                gapi.client.setToken(null); // Clear token in gapi.client
                console.log("Google sign out complete.");
                updateDriveButtonVisibility(false); // Hide Drive buttons, show sign-in
                 const signedInUserDisplay = document.getElementById('signedInUserDisplay');
                 if (signedInUserDisplay) signedInUserDisplay.textContent = ''; // Clear display
            });
        } else {
            console.log("No Google access token to revoke.");
            updateDriveButtonVisibility(false); // Just update visibility
        }
    }

    // Update visibility of Google Drive related buttons
    function updateDriveButtonVisibility(isSignedIn) {
        const signInButton = document.getElementById('googleSignInButton');
        const signOutButton = document.getElementById('googleSignOutButton');
        const loadButton = document.getElementById('loadFromDriveButton');
        const saveButton = document.getElementById('saveToDriveButton');
        const downloadLocalButton = document.getElementById('downloadLocalButton'); // Local download fallback

        if (signInButton) signInButton.style.display = isSignedIn ? 'none' : 'inline-block';
        if (signOutButton) signOutButton.style.display = isSignedIn ? 'inline-block' : 'none';
        if (loadButton) loadButton.style.display = isSignedIn ? 'inline-block' : 'none';
        if (saveButton) saveButton.style.display = isSignedIn ? 'inline-block' : 'none';
        // Optionally show local download button if signed in (as an alternative save)
        if (downloadLocalButton) downloadLocalButton.style.display = isSignedIn ? 'inline-block' : 'none';
    }
</script>

</body>
</html>

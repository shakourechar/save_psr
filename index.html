<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>SmartWealth Navigator - Enhanced Financial Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
     <!-- Updated CSP for Google APIs -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; frame-src content.googleapis.com; script-src 'self' 'unsafe-inline' cdn.tailwindcss.com cdn.plot.ly cdn.jsdelivr.net tfnwwpksieluzvxqdiiq.supabase.co accounts.google.com apis.google.com; style-src 'self' 'unsafe-inline' fonts.googleapis.com fonts.gstatic.com; font-src 'self' fonts.gstatic.com; img-src 'self' static.wixstatic.com data:; connect-src 'self' tfnwwpksieluzvxqdiiq.supabase.co https://tfnwwpksieluzvxqdiiq.supabase.co accounts.google.com apis.google.com https://www.googleapis.com; object-src 'none'; base-uri 'self'; form-action 'self';">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="./plotly.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- Add Google API loader script tags -->
    <!-- The `onload` attributes are crucial here for controlling load order -->
    <script src="https://accounts.google.com/gsi/client" async defer onload="initializeGIS"></script>
    <script src="https://apis.google.com/js/api.js" async defer onload="handleGapiLoad"></script>


    <style>
        /* Base Styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f5f7fa;
            color: #374151;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            min-width: 100vw;
            overflow-x: hidden;

        }
        /* Garamond for Headers */
        h1, h2, h3, h4, .header-font {
            font-family: 'EB Garamond', serif;
            color: #111827;
            font-weight: bold;
        }
        h1 { font-size: 1.8em; }
        h2 { font-size: 1.5em; }
        h3 { font-size: 1.2em; color: #333; }
        h4 { font-size: 1.1em; }

        /* Main Container */
        .main-container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 1.5rem 2rem;
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.07);
        }

        /* Header */
        header {
            display: flex;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #e5e7eb;
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
        }
        header img {
            height: 72px;
            margin-right: 15px;
            border-radius: 8px;
            object-fit: contain;
        }
        header h1 {
            color: #4f46e5;
            margin: 0;
            flex-grow: 1; /* Allow title to take available space */
            font-size: 2.2em;
            line-height: 1.2;
             /* Add some spacing to the right if buttons are present */
            margin-right: 10px;
        }

        /* Header Buttons */
        header button {
            margin-left: 10px; /* Space between buttons */
            padding: 0.6rem 1.2rem;
            background-color: #4f46e5;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            /* Add flex-shrink to prevent buttons from shrinking */
            flex-shrink: 0;
        }
        /* Custom colors for specific buttons */
        header button#uploadButton { background-color: #059669; } /* Green for Upload */
        header button#downloadLocalButton { background-color: #6b7280; } /* Gray for Download */
        header button#loadFromDriveButton { background-color: #10b981; } /* Green-like for Drive Load */
        header button#saveToDriveButton { background-color: #f59e0b; } /* Amber/Orange for Drive Save */

        header button:hover { background-color: #4338ca; }
        header button#uploadButton:hover { background-color: #047857; }
        header button#downloadLocalButton:hover { background-color: #4b5563; }
        header button#loadFromDriveButton:hover { background-color: #059669; }
        header button#saveToDriveButton:hover { background-color: #d97706; }

        #fileInput { display: none; }

        /* Add specific styles for Google related items - keeping Sign In button hidden by default, managed by JS */
         #googleSignInButton { display: none; } /* This button is managed by JS */
         #googleSignOutButton { background-color: #d1d5db; color: #374151; display: none;} /* Gray, managed by JS */
         #googleSignOutButton:hover { background-color: #9ca3af; }


         #signedInUserDisplay {
             margin-right: 10px;
             font-size: 0.9em;
             color: #4b5563;
             white-space: nowrap; /* Prevent wrapping */
             overflow: hidden;
             text-overflow: ellipsis; /* Add ellipsis if text overflows */
             max-width: 150px; /* Limit width */
             display: none; /* Managed by JS */
         }

        /* Grid Layout */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-bottom: 25px;
        }

        /* Dashboard Cards */
        .dashboard-card {
            background: #fff;
            padding: 1.5rem;
            border-radius: 10px;
            /* Updated Shadow for more prominence */
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            /* Slightly darker border */
            border: 1px solid #d1d5db; /* Using a slightly darker gray than #e5e7eb */
            display: flex;
            flex-direction: column;
            min-height: 160px;
        }

        /* Card Headers */
        .card-header {
            font-family: 'Inter', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            color: #374151;
            margin: -1.5rem -1.5rem 1.25rem -1.5rem;
            padding: 0.75rem 1.5rem;
            border-bottom: 1px solid #e5e7eb;
            background-color: #f9fafb;
            border-radius: 10px 10px 0 0;
        }
        .dashboard-card h3 {
             margin: 0 0 1rem 0;
             padding: 0; border: none; background: none;
        }

        .card-content { flex-grow: 1; font-size: 0.95em; }
        .card-content p { margin-bottom: 0.6rem; }
        .card-content p strong { font-weight: 500; color: #1f2937; margin-right: 5px; }

        /* Chart Card Specifics */
        .chart-card {
            min-height: 400px;
            overflow: hidden;
        }
        .chart-container-div {
            min-height: 400px; /* Keep this height */
            width: 100%; /* Keep width 100% */
            flex-grow: 1; /* Allow it to grow in flex container */
            display: flex; /* Keep flex display for centering */
            align-items: center; /* Keep centering */
            justify-content: center; /* Keep centering */
            padding: 15px; /* Keep padding */
            box-sizing: border-box; /* Keep box-sizing */
            overflow: hidden; /* Keep overflow hidden */
            /* Ensure no specific Plotly width/height overrides from parent */
            position: relative; /* Add relative positioning if needed for Plotly */
        }


        /* Ratio Bar Styles */
        .ratio-item { margin-bottom: 12px; }
        .ratio-label { display: block; font-weight: 500; margin-bottom: 3px; font-size: 0.9em; color: #4b5563; }
        .ratio-value { display: inline-block; margin-bottom: 5px; font-size: 1.1em; font-weight: 600; color: #1f2937; }
        .ratio-bar-container { background-color: #e5e7eb; border-radius: 4px; overflow: hidden; height: 8px; width: 100%; }
        .ratio-bar { height: 100%; width: 0%; transition: width 0.5s ease-in-out; border-radius: 4px; }
        /* Define colors based on status */
        .ratio-bar.savings-rate { background-color: #ef4444; }
        .ratio-bar.savings-rate.ok { background-color: #f59e0b; }
        .ratio-bar.savings-rate.good { background-color: #10b981; }
        .ratio-bar.emergency-coverage { background-color: #ef4444; }
        .ratio-bar.emergency-coverage.ok { background-color: #f59e0b; }
        .ratio-bar.emergency-coverage.good { background-color: #10b981; }
        .ratio-bar.dti-ratio { background-color: #10b981; }
        .ratio-bar.dti-ratio.warning { background-color: #f59e0b; }
        .ratio-bar.dti-ratio.high { background-color: #ef4444; }

         /* Debt Table Styles */
        #debtsTable {
            width: 100%;
            margin-top: 10px;
            border-collapse: collapse;
            border: 1px solid #d1d5db; /* Add a light outer border */
            border-radius: 8px; /* Optional: soften corners */
            overflow: hidden; /* Helps with border-radius */
        }
        /* Shared styles for headers and data cells */
        #debtsTable th, #debtsTable td {
            padding: 8px 12px; /* Increased padding slightly for better spacing */
            border-bottom: 1px solid #e5e7eb; /* Keep bottom border between rows */
            border-right: 1px solid #e5e7eb; /* Add vertical borders between columns */
            font-size: 0.9em; /* Keep same font size for both headers and data */
            /* Remove default text-align here to control per column/header */
        }
        /* Remove right border from the last column */
        #debtsTable th:last-child,
        #debtsTable td:last-child {
            border-right: none;
        }
        /* Remove bottom border from the last row */
        #debtsTable tbody tr:last-child td {
             border-bottom: none;
        }


        /* Header styles */
        #debtsTable th {
            font-weight: 700; /* Make headers bold */
            color: #374151; /* Set header color */
            background-color: #f9fafb;
            text-align: left; /* Default header alignment (keep this) */
            cursor: pointer; /* Indicate clickable for popups */
        }
        /* Align specific headers right to match data */
         #debtsTable th.balance-header,
         #debtsTable th.min-pmt-header {
             text-align: right;
         }

        /* Data cell default alignment (most columns left, normal weight) */
        #debtsTable td {
            text-align: left;
            font-weight: normal;
        }

        /* Specific data column styling for alignment and bolding (set by JS adding these classes) */
        #debtsTable td.balance-col {
             text-align: right; /* Align Balance data right */
             font-weight: 700; /* Make Balance data bold */
        }
         #debtsTable td.rate-col {
             /* text-align: left; is default td alignment */
             font-weight: 700; /* Make Rate data bold */
         }
         #debtsTable td.min-pmt-col {
             text-align: right; /* Align Min. Payment data right */
             font-weight: 700; /* Make Min. Payment data bold */
         }

        /* Debt Table Styles */
        #debtsTable { /* ... existing styles ... */ }
        #debtsTable th, #debtsTable td { /* ... existing styles ... */ }
        #debtsTable th {
            font-weight: 500;
            color: #6b7280;
            background-color: #f9fafb;
            text-align: left; /* Default header alignment (keep this) */
            cursor: pointer;
        }
        /* --- ADD THESE NEW RULES --- */
        #debtsTable th.balance-header {
            text-align: right; /* Align Balance header right */
        }
        #debtsTable th.min-pmt-header {
            text-align: right; /* Align Min. Pmt header right */
        }
        /* --- END NEW RULES --- */
        #debtsTable tr:last-child td { /* ... existing styles ... */ }
        #debtsTable td { /* ... existing styles ... */ }
        #debtsTable td.balance-col { /* ... existing styles ... */ }
        #debtsTable td.rate-col { /* ... existing styles ... */ }
        #debtsTable td.min-pmt-col { /* ... existing styles ... */ }


        /* Progress Bar Styles */
        .progress-bar-container { background-color: #e5e7eb; border-radius: 6px; overflow: hidden; height: 20px; margin-top: 5px; margin-bottom: 10px; }
        .progress-bar { background-color: #4f46e5; height: 100%; width: 0%; transition: width 0.5s ease-in-out; text-align: center; color: white; font-size: 0.8em; line-height: 20px; font-weight: 500; }
        .goal-status { font-weight: 500; color: #1f2937; }

        /* Recommendations List Styles */
        #recommendationsList { list-style: none; padding-left: 0; margin-top: 10px; }
        #recommendationsList li { margin-bottom: 10px; line-height: 1.6; font-family: 'Inter', sans-serif; font-size: 0.95em; padding-left: 1.5em; position: relative; }
        #recommendationsList li::before { content: '✓'; color: #10b981; position: absolute; left: 0; font-weight: bold; }
        #recommendationsList li.warning::before { content: '!'; color: #f59e0b; }
        #recommendationsList li.critical::before { content: '!!'; color: #ef4444; }

        /* Modals */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); padding-top: 60px; }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 25px; border: 1px solid #888; width: 80%; max-width: 700px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); }
        .close-button { color: #aaa; float: right; font-size: 32px; line-height: 1; font-weight: bold; cursor: pointer; }
        .close-button:hover, .close-button:focus { color: black; text-decoration: none; }
        #driveFileList a { cursor: pointer; color: #4f46e5; text-decoration: underline; }
         #driveFileList a:hover { text-decoration: none; }


        /* Loading / Error / Initial Messages */
        #loadingSpinner, #errorMessage {
             display: none;
             position: fixed;
             top: 0; left: 0;
             width: 100%; height: 100%;
             z-index: 1050;
             background-color: rgba(255, 255, 255, 0.95);
             align-items: center;
             justify-content: center;
             padding: 1rem;
        }
         #errorMessage > div {
             background-color: #fee2e2;
             border: 1px solid #f87171;
             color: #b91c1c;
             padding: 1.5rem;
             border-radius: 0.5rem;
             max-width: 600px;
             box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
             text-align: center;
         }
         #errorMessage h3 { color: #991b1b; }
         #debugInfo {
             margin-top: 1rem; margin-bottom: 1rem;
             max-height: 200px; overflow-y: auto;
             text-align: left; background-color: #f3f4f6;
             padding: 0.75rem; border-radius: 0.375rem;
             border: 1px solid #d1d5db;
             font-size: 0.75rem;
             line-height: 1.2;
             color: #4b5563;
             white-space: pre-wrap;
             word-break: break-all;
         }
         #debugInfo strong { color: #1f2937; }
         #errorMessage button {
             background-color: #dc2626;
             color: white; padding: 0.5rem 1rem;
             border: none; border-radius: 0.375rem; cursor: pointer;
             font-size: 0.875rem; margin: 0 0.5rem;
             transition: background-color 0.2s;
         }
          #errorMessage button:hover { background-color: #b91c1c; }
          #errorMessage button.secondary-button { background-color: #d1d5db; color: #374151; }
          #errorMessage button.secondary-button:hover { background-color: #9ca3af; }

        #initialUploadPrompt { display: none; }
        #initialMessage { display: none; text-align: center; padding: 40px; font-size: 1.2em; color: #555; }
        #mainContent.hidden { display: none; }
        #mainContent { display: none; }

        /* Chat Interface Card */
        #chatInterfaceCard { grid-column: 1 / -1; }

        /* Chat Styles */
        #chatInterfaceCard { display: none; } /* Default hidden, managed by JS */

        .chat-container {
            display: flex; flex-direction: column; height: 550px;
            border: 1px solid #d1d5db; border-radius: 10px; overflow: hidden;
            background-color: #ffffff; box-shadow: inset 0 2px 4px rgba(0,0,0,0.03);
        }
        .chat-history {
            flex-grow: 1; padding: 1.5rem; overflow-y: auto;
            scrollbar-width: thin; scrollbar-color: #d1d5db transparent;
        }
        .chat-history::-webkit-scrollbar { width: 8px; }
        .chat-history::-webkit-scrollbar-track { background: transparent; }
        .chat-history::-webkit-scrollbar-thumb { background-color: #d1d5db; border-radius: 10px; border: 2px solid transparent; background-clip: content-box; }
        .chat-history::-webkit-scrollbar-thumb:hover { background-color: #9ca3af; }

        .chat-message { margin-bottom: 1.25rem; line-height: 1.6; display: flex; }
        .chat-message.user { justify-content: flex-end; }
        .chat-message.assistant { justify-content: flex-start; }
        .message-bubble {
             border-radius: 18px; padding: 0.8rem 1.1rem; max-width: 75%;
             box-shadow: 0 2px 4px rgba(0,0,0,0.05); word-wrap: break-word;
        }
        .chat-message.user .message-bubble {
            background: linear-gradient(135deg, #4f46e5 0%, #6366f1 100%); color: white;
            border-radius: 18px 18px 4px 18px;
        }
        .chat-message.assistant .message-bubble {
            background-color: #eef2ff; color: #374151;
            border: 1px solid #e0e7ff; border-radius: 18px 18px 18px 4px;
        }
        .chat-message.system .message-bubble {
            background-color: #f3f4f6; color: #6b7280; font-size: 0.85em;
            text-align: center; max-width: 100%; border-radius: 8px;
            padding: 0.5rem 1rem; border: 1px solid #e5e7eb;
            box-shadow: none;
        }
        .chat-message.system { justify-content: center; margin: 0.5rem 0; }

        .message-sender { display: none; }

        /* Chat Status & Input */
        .chat-status {
            font-size: 0.8rem; color: #6b7280; padding: 0.5rem 1rem;
            text-align: center; height: 25px;
            background-color: #f9fafb; border-top: 1px solid #e5e7eb;
            overflow: hidden; white-space: nowrap; text-overflow: ellipsis;
        }
        .typing-indicator { display: inline-block; }
        .typing-indicator span {
            height: 8px; width: 8px; margin: 0 2px;
            background-color: #9ca3af; border-radius: 50%;
            display: inline-block;
            animation: typing 1.4s infinite ease-in-out both;
        }
        .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
        .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }
        @keyframes typing {
            0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); }
        }

        .chat-input-area {
            border-top: 1px solid #e5e7eb; padding: 0.75rem 1rem;
            background-color: #f9fafb; display: flex; align-items: center; gap: 0.75rem;
        }
        .chat-input-area textarea {
            flex-grow: 1;
            padding: 0.7rem 1rem;
            border: 1px solid #d1d5db;
            border-radius: 20px;
            resize: none; /* Prevent manual resizing */
            font-size: 0.95rem;
            line-height: 1.4;
            height: 88px; /* Set the initial height */
            min-height: 88px; /* Add minimum height to prevent it from shrinking below this */
            max-height: 120px; /* Keep the max height from JS auto-grow */
            background-color: white;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            outline: none;
            overflow-y: auto; /* Ensure scrollbar appears if text exceeds height */
        }
        .chat-input-area textarea:focus {
            border-color: #4f46e5; box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
        }
        .chat-input-area button {
            padding: 0.6rem 1rem; white-space: nowrap; flex-shrink: 0;
            border-radius: 20px;
            background-color: #4f46e5; color: white; border: none; cursor: pointer;
            transition: background-color 0.2s;
            display: flex; align-items: center; justify-content: center;
        }
        .chat-input-area button:hover { background-color: #4338ca; }
        .chat-input-area button:disabled { background-color: #a5b4fc; cursor: not-allowed; }
        .chat-input-area button svg { width: 1.25rem; height: 1.25rem; }
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0; }

        /* Responsive */
        @media (max-width: 768px) {
            header { flex-direction: column; align-items: flex-start; }
            header h1 { margin-top: 10px; font-size: 1.8em; }
             /* Adjust margin for buttons on smaller screens */
             /*header button { margin-left: 0; margin-top: 10px; margin-right: 10px; }*/
             /* Remove right margin from the last button in the header */
            /*header button:last-child { margin-right: 0; }*/

            /* Ensure button container wraps */
             header div {
                 display: flex;
                 flex-wrap: wrap;
                 gap: 10px; /* Space between buttons */
                 margin-top: 10px;
                 width: 100%; /* Ensure container takes full width */
             }
             header button {
                 margin: 0; /* Remove individual margins */
                 flex-grow: 1; /* Allow buttons to share space */
                 min-width: 120px; /* Minimum width for buttons */
             }
             #signedInUserDisplay {
                 order: -1; /* Place above buttons */
                 width: 100%;
                 text-align: center;
                 margin-bottom: 5px;
                 margin-right: 0; /* Remove right margin */
             }


            .grid-container { grid-template-columns: 1fr; }
            .main-container { margin: 1rem; padding: 1rem; }
        }

        /* ADD THIS NEW MEDIA QUERY FOR EVEN SMALLER SCREENS */
        @media (max-width: 500px) { /* Target screens/iframes up to 500px wide */
            /* Adjust Grid Minimum Width */
            .grid-container {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* Lower the minimum width */
                gap: 15px; /* Reduce gap slightly */
            }
             /* Further adjust header layout on very small screens */
             header {
                flex-direction: column;
                align-items: stretch; /* Stretch items */
            }
             header img { margin-right: 0; margin-bottom: 10px; max-width: 100%; height: auto; }
             header h1 { margin-right: 0; text-align: center; font-size: 1.6em; }
             /* Make buttons stack or distribute space */
             header div {
                 display: flex;
                 flex-wrap: wrap; /* Allow buttons container to wrap */
                 justify-content: center; /* Center buttons if they wrap */
                 gap: 10px; /* Space between wrapped buttons */
                 width: 100%; /* Ensure container takes full width */
                 margin-top: 10px;
             }
             header button { margin: 0; flex-grow: 1; min-width: 100px; padding: 0.5rem 1rem; font-size: 0.8em; } /* Allow buttons to grow slightly */
             #signedInUserDisplay {
                 order: -1; /* Place above buttons */
                 width: 100%;
                 text-align: center;
                 margin-bottom: 5px;
                 margin-right: 0; /* Remove right margin */
             }
        }
    </style>
</head>

<body>
    <pre id="embeddedPsrData" style="display: none;">/* EMBEDDED_JSON_DATA_HERE */</pre>

    <div id="loadingSpinner" style="display: none;">
        <div class="text-center">
            <svg class="animate-spin h-10 w-10 text-indigo-600 mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="text-gray-700 text-lg">Loading your financial dashboard...</p>
        </div>
    </div>

    <div id="errorMessage" style="display: none;">
        <div>
            <h3 class="font-bold text-xl mb-3 header-font">Error Loading Dashboard</h3>
            <p id="errorText" class="mb-4">An error occurred.</p>
            <div id="debugInfo" class="mb-4 text-xs">Debug info will appear here...</div>
            <div class="flex justify-center space-x-3 mt-4">
                <button id="retryButton" class="action-button">Retry Loading</button>
                <button id="manualEntryButton" class="secondary-button">Use Demo Data</button>
            </div>
        </div>
    </div>

     <div id="initialUploadPrompt" style="display: none; text-align: center; padding: 60px 20px;">
         <div class="main-container" style="max-width: 600px; margin: auto;">
             <h2 class="header-font text-2xl mb-4 text-gray-700">Welcome to SmartWealth Navigator</h2>
             <p class="text-gray-600 mb-6">
                 📂 Please upload your saved PSR file to view your dashboard.
             </p>
             <button id="initialUploadButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-200 ease-in-out">
                 Upload PSR
             </button>
              <p class="text-gray-600 mt-6 mb-4">Or load from Google Drive:</p>
              <!-- Add Google Sign-In/Load button for initial prompt -->
              <!-- This button's click listener will trigger the Google Sign-In/Load flow -->
              <button id="promptGoogleLoadButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-200 ease-in-out">
                  Sign in & Load from Drive
              </button>


             <p class="text-sm text-gray-500 mt-4">
                 (If you haven't generated a report yet, please complete the initial form first.)
             </p>
         </div>
     </div>

    <div id="initialMessage" style="display: none;">
        Upload a PSR JSON file or parameter to view your dashboard.
    </div>

    <div id="mainContent" class="main-container" style="display: none;">
        <header>
            <img src="https://static.wixstatic.com/media/c3283f_a9271d9818ba414994d98950da749489~mv2.jpg" alt="SmartWealth Navigator Logo">
            <h1>SmartWealth Navigator</h1>
             <!-- Button Container for better wrapping on small screens -->
            <div>
                 <!-- Display area for signed-in user name -->
                 <span id="signedInUserDisplay"></span>
                 <!-- Keep fileInput hidden -->
                 <input type="file" id="fileInput" accept=".json">

                 <!-- Local File Buttons -->
                 <button id="uploadButton">Upload PSR</button>
                 <button id="downloadLocalButton">Download PSR</button>

                 <!-- Google Drive Buttons (visibility managed by JS) -->
                 <!-- The click listeners for these initiate the Google flow if needed -->
                 <button id="loadFromDriveButton" style="display: none;">Open PSR→G-Drive</button>
                 <button id="saveToDriveButton" style="display: none;">Save PSR→G-Drive</button>
                 <!-- Google Sign-In and Sign-Out buttons (Managed by JS, typically hidden if Load/Save are present) -->
                  <button id="googleSignInButton" style="display: none;">Sign in with Google</button>
                  <button id="googleSignOutButton" style="display: none;">Sign Out</button>


            </div>
        </header>

        <div class="grid-container">
            <div class="dashboard-card">
                <h3 class="card-header">Quick Summary</h3>
                <div class="card-content">
                    <p><strong>User:</strong> <span id="userName">N/A</span></p>
                    <p><strong>Age:</strong> <span id="age">N/A</span></p>
                    <p><strong>Total Monthly Income:</strong> <span id="totalIncome">N/A</span></p>
                    <p><strong>Total Monthly Expenses:</strong> <span id="totalExpenses">N/A</span></p>
                    <p><strong>Monthly Net Flow:</strong> <span id="netFlow">N/A</span></p>
                </div>
            </div>
            <div class="dashboard-card" id="ratiosCard">
                <h3 class="card-header">Key Financial Ratios</h3>
                <div class="card-content">
                    <div class="ratio-item">
                        <span class="ratio-label cursor-pointer" data-desc="Income kept, not spent.">Savings Rate</span>
                        <span class="ratio-value" id="savingsRateValue">N/A</span>
                        <div class="ratio-bar-container"><div class="ratio-bar savings-rate" id="savingsRateBar"></div></div>
                    </div>
                    <div class="ratio-item">
                        <span class="ratio-label cursor-pointer" data-desc="Months cash covers bills.">Emergency Fund Coverage</span>
                        <span class="ratio-value" id="emergencyCoverageValue">N/A</span>
                        <div class="ratio-bar-container"><div class="ratio-bar emergency-coverage" id="emergencyCoverageBar"></div></div>
                    </div>
                    <div class="ratio-item">
                        <span class="ratio-label cursor-pointer" data-desc="Income used for debts.">Debt to Income (DTI)</span>
                        <span class="ratio-value" id="dtiRatioValue">N/A</span>
                        <div class="ratio-bar-container"><div class="ratio-bar dti-ratio" id="dtiRatioBar"></div></div>
                        <p style="font-size: 0.8em; color: #666;">(Using min. payments)</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="grid-container">
            <div class="dashboard-card">
                <h3 class="card-header">Savings Overview</h3>
                <div class="card-content">
                    <p><strong>Emergency Savings:</strong> <span id="emergencySavings">N/A</span></p>
                    <p><strong>General Savings:</strong> <span id="currentSavings">N/A</span></p>
                    <p><strong>Retirement Fund:</strong> <span id="retirementFund">N/A</span></p>
                </div>
            </div>
            <div class="dashboard-card" id="goalsCard">
                <h3 class="card-header cursor-pointer" data-desc="Distance to rainy day target.">Savings Goals Progress</h3>
                <div class="card-content">
                    <div id="emergencyGoalDisplay" style="display: none;">
                        <p><strong>Emergency Fund Goal:</strong> <span class="goal-status">N/A</span></p>
                        <div class="progress-bar-container"><div class="progress-bar" id="emergencyProgressBar"></div></div>
                    </div>
                    <div id="purchaseGoalDisplay" style="margin-top: 15px; display: none;">
                        <p><strong data-desc="Saved toward big buy.">Purchase Goal (<span id="purchaseGoalName">N/A</span>):</strong> <span class="goal-status">N/A</span></p>
                        <div class="progress-bar-container"><div class="progress-bar" id="purchaseProgressBar"></div></div>
                    </div>
                    <p id="noGoalsMessage" style="display: none;" class="text-gray-500 italic">
                        No specific savings goals identified.
                    </p>
                </div>
            </div>
        </div>

        <div class="grid-container">
            <div class="dashboard-card chart-card">
                <h3 class="card-header cursor-pointer" data-desc="Where income comes from.">Income Breakdown</h3>
                <div id="incomeChart" class="chart-container-div">
                    <p class="text-center text-gray-500 pt-10">Chart loading...</p>
                </div>
            </div>
            <div class="dashboard-card chart-card">
                <h3 class="card-header cursor-pointer" data-desc="Where money goes.">Expense Breakdown</h3>
                <div id="expenseChart" class="chart-container-div">
                    <p class="text-center text-gray-500 pt-10">Chart loading...</p>
                </div>
            </div>
        </div>

        <div class="grid-container">
            <div class="dashboard-card">
                <h3 class="card-header">Recommendations</h3>
                <div class="card-content">
                    <ul id="recommendationsList">
                        <li>Loading recommendations...</li>
                    </ul>
                </div>
            </div>
                                   <div class="dashboard-card">
                <h3 class="card-header">AI Analysis Summary</h3>
                <div class="card-content">
                    <div id="aiAnalysis" class="prose prose-sm max-w-none mb-4" style="white-space: pre-wrap;">
                        Loading analysis...
                    </div>
                    <button onclick="openModal('progressModal')" class="text-indigo-600 hover:underline text-sm font-medium">
                        View Full Progress History
                    </button>
                    <button id="saveSummaryBtn" class="bg-indigo-600 text-white text-sm font-medium px-3 py-1 rounded mt-2">
                        Save Summary to Report
                    </button>
                </div>
            </div>
        </div>

        <div class="grid-container">
            <div class="dashboard-card" id="debtsCard">
                <h3 class="card-header">Debt Overview</h3>
                <div class="card-content overflow-x-auto">
                    <table id="debtsTable">
                      <thead>
                            <tr>
                                <th>Type</th>
                                <th class="balance-header" data-desc="Total amount currently owed on this debt.">Balance</th>
                                <th data-desc="Annual interest rate for this debt.">Rate (%)</th>
                                <th class="min-pmt-header" data-desc="Minimum monthly payment required for this debt.">Min. Pmt</th>
                            </tr>
                        </thead>

                        <tbody>
                            <tr><td colspan="4" class="text-center p-4 text-gray-500">Loading debt data...</td></tr>
                        </tbody>
                    </table>
                    <p style="margin-top: 10px;"><strong data-desc="All debts owed.">Total Debt Balance:</strong> <span id="totalDebtBalance" class="font-semibold">N/A</span></p>
                    <p><strong data-desc="Minimum due monthly.">Total Min. Payments:</strong> <span id="totalMinPayments" class="font-semibold">N/A</span></p>
                </div>
            </div>
            <div class="dashboard-card">
                <h3 class="card-header">Financial Tools & Goals</h3>
                <div class="card-content">
                    <p><strong>Financial Tools:</strong> <span id="financialTools">N/A</span></p>
                    <p><strong>Challenges:</strong> <span id="challenges">N/A</span></p>
                    <p><strong>Upcoming Purchase Goal Detail:</strong> <span id="purchaseGoals">N/A</span></p>
                </div>
            </div>
        </div>

           <section id="chatInterfaceCard" class="dashboard-card" style="display: none;">
            <!-- MODIFIED HEADER WITH FLEX AND BUTTON -->
            <h3 class="card-header flex items-center justify-between">
                <span>Ask SmartWealth AI</span>
                <button id="generateAnalysisBtn" class="bg-green-600 hover:bg-green-700 text-white text-sm font-medium px-3 py-1 rounded">
                     Generate New Analysis
                </button>
            </h3>
            <!-- END MODIFIED HEADER -->
            <div class="chat-container">
                <div class="chat-history" id="chatHistory">
                    </div>
                <div class="chat-status flex justify-between items-center px-4" id="chatStatusContainer">
                 <span>
                     Tier: <strong id="chatTierDisplay">-</strong> |
                     Model: <span id="chatModelDisplay" class="text-xs">-</span>
                 </span>
                 <span id="chatThinkingIndicator" style="display: none; margin-left: auto; margin-right: auto;">
                     <div class="typing-indicator"><span style="background-color: #4f46e5;"></span><span style="background-color: #4f46e5;"></span><span style="background-color: #4f46e5;"></span></div> Thinking...
                 </span>
                 <span class="ml-auto"> Usage: <strong id="chatUsageDisplay">- / -</strong>
                 </span>
            </div>
            <!-- THIS IS THE CHAT INPUT AREA -->
            <div class="chat-input-area">
                <textarea id="chatInput" placeholder="Ask about your finances..." rows="1" disabled></textarea>
                <button id="chatSendButton" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">
                        <path d="M3.105 3.105a1.5 1.5 0 011.995-.04l8 4a1.5 1.5 0 010 2.87l-8 4a1.5 1.5 0 01-1.995-.04L1.6 13.89a1.5 1.5 0 01-.04-1.995l3-4a1.5 1.5 0 010-1.79l-3-4a1.5 1.5 0 01.04-1.995l1.5-1.5z" />
                    </svg>
                    <span class="sr-only">Send</span>
                </button>
            </div>
            <!-- END OF CHAT INPUT AREA -->
            </div> <!-- This closes the chat-container div -->
        </section>

        <footer class="text-center text-gray-500 text-sm py-6 mt-4 border-t border-gray-200">
            <p>SmartWealth Navigator © 2025 | Built by Socialeap™️</p>
            <p>Consult with a qualified financial advisor for personalized advice.</p>
        </footer>
    </div>

    <div id="progressModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('progressModal')">&times;</span>
            <h2>User Progress History</h2>
            <div id="progressContent" style="white-space: pre-wrap;">Loading history...</div>
        </div>
    </div>

    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('infoModal')">&times;</span>
            <p id="infoModalText" style="margin:0;"></p>
        </div>
    </div>

    <!-- Modal for listing files from Drive -->
    <div id="driveLoadModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('driveLoadModal')">&times;</span>
            <h2>Select File to Load</h2>
            <div id="driveFileList">Loading files...</div>
            <p id="driveLoadError" style="color: red;"></p>
        </div>
    </div>

<script>
   // --- VERY EARLY NAVIGATION DEBUGGING ---
console.log("Script execution started. Setting up early unload listener.");
window.addEventListener('beforeunload', (event) => {
    console.error("!!! EARLY BEFOREUNLOAD DETECTED - Potential unwanted navigation !!!");
    // Keep console log, but do NOT prevent default navigation unless explicitly needed later.
    // event.preventDefault();
    // event.returnValue = '';
});
console.log("Early beforeunload listener added (logging only).");
// --- END EARLY DEBUGGING ---

    // --- Globals ---
    let dashboardData = {}; // Holds the main data object
    let chatMessages = []; // Holds chat history for API calls
    // Note: CHAT_MODEL is effectively determined by the backend based on tier,
    // but defining it here might be useful for frontend logic if needed later.
    // For now, rely on backend.
    const CHAT_MODEL = 'determined_by_backend'; // Placeholder

    const plotlyConfig = {
        displaylogo: false,
        responsive: true, // Added responsive config
        modeBarButtonsToRemove: ['sendDataToCloud', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale2d', 'resetScale2d', 'hoverClosestPie', 'toggleSpikelines', 'hoverCompareCartesian']
    };

    let currentUserId = null; // User ID derived from XTL parameter or loaded file metadata
    let effectiveTier = 'basic'; // Tier derived from XTL parameter or loaded file metadata
    let initialUsageInfo = null; // To store fetched usage/limit info for initial UI setup

    // --- Supabase Client (CONFIGURE THESE) ---
    // **IMPORTANT:** Ensure these are correct and your Supabase project is configured
    // with RLS policies that allow anon key reads on 'SWN_Users' (using the 'id' column matching XTL)
    // and service key access in your Edge Function.
    const SUPABASE_URL = 'https://tfnwwpksieluzvxqdiiq.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRmbnd3cGtzaWVsdXp2eHFkaWlxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ1ODQ3MjgsImV4cCI6MjA2MDE2MDcyOH0.xbtjiQ65vCggjj35qtlCZ0S5mJa4muSZcHXhaU4qvrE';
    let supabase = null; // Initialize later

    // --- Google Drive Integration Constants ---
    const GOOGLE_CLIENT_ID = '351536963710-k1tqdl2v9ddnnb1hgda4r4gm40kpu2sa.apps.googleusercontent.com'; // Your Google Cloud Client ID
    // Scopes needed: Accessing userinfo (for display), reading/writing Drive files created by this app
    // 'https://www.googleapis.com/auth/drive.file' limits access to files created/opened by this app.
    const GOOGLE_SCOPES = 'https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/drive.file';
    const PSR_MIME_TYPE = 'application/json'; // MIME type for your PSR file
    // Using user ID for folder name makes it unique per user who signs into Drive
    const getDriveFolderName = () => currentUserId ? `SWN_${currentUserId}` : 'SmartWealth Navigator Reports'; // Fallback name if no user ID
    const PSR_FILE_NAME = 'my_financial_report.json'; // Standard file name to use within the folder

    // --- Google Drive Related Globals ---
    let googleAccessToken = null; // Store the current Google Access Token
    let googleTokenClient = null; // Store the GIS token client instance
    let googleUser = null; // Store basic user info (name, etc.)
    let driveFolderId = null; // Store the ID of the designated Drive folder

    // --- Cached DOM Elements ---
    // Declare variables here, cache in DOMContentLoaded
    let loadingSpinner, errorMessageElement, mainContentElement, initialMessageElement, initialUploadPrompt, errorTextElement, debugInfoElement, fileInput, chatInterfaceCardElement;
    // Drive related buttons
    let uploadButtonHeader, downloadLocalButton, loadFromDriveButton, saveToDriveButton, googleSignInButton, googleSignOutButton, signedInUserDisplayElement, promptGoogleLoadButton;


    // --- Utility Functions ---
    function getSafe(fn, defaultVal = 'N/A') {
        try {
            const value = fn();
            // More robust check for empty/null/undefined/NaN/Infinity
            if (value === null || value === undefined || String(value).trim() === '' || (typeof value === 'number' && !isFinite(value))) {
                 return defaultVal;
            }
            return value;
        } catch (e) {
            // console.warn("getSafe caught error:", e.message); // Log getSafe errors if needed
            return defaultVal;
        }
    }

    function formatCurrency(value, hideNA = false) {
        const number = Number(getSafe(() => value, NaN)); // Use getSafe internally
        if (isNaN(number) || !isFinite(number)) return hideNA ? '' : 'N/A';
        return number.toLocaleString('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 0, maximumFractionDigits: 0 });
    }

    function formatPercentage(value, decimals = 1) {
         const number = Number(getSafe(() => value, NaN)); // Use getSafe internally
        if (isNaN(number) || !isFinite(number)) return 'N/A';
        return number.toLocaleString(undefined, { style: 'percent', minimumFractionDigits: decimals, maximumFractionDigits: decimals });
    }

    function updateElementText(id, value, formatter) {
        const element = document.getElementById(id);
        if (element) {
            try {
                const formattedValue = formatter ? formatter(value) : (value !== null && value !== undefined && String(value).trim() !== '' ? String(value) : 'N/A');
                element.textContent = formattedValue;
            } catch (e) {
                console.error(`Error formatting/updating text for element ID ${id}:`, e);
                element.textContent = 'Error'; // Indicate error on the UI
            }
        } // else { console.warn(`Element with ID ${id} not found for text update.`); } // Keep console warning optional
    }

    function updateElementHTML(id, value) {
        const element = document.getElementById(id);
        if (element) {
             try {
                // Use innerHTML carefully - ensure value is trusted or sanitized
                element.innerHTML = value !== null && value !== undefined && String(value).trim() !== '' ? String(value) : '';
            } catch (e) {
                 console.error(`Error updating HTML for element ID ${id}:`, e);
                 element.textContent = 'Error'; // Fallback to text on error
            }
        } // else { console.warn(`Element with ID ${id} not found for HTML update.`); }
    }

    // Helper function to parse URL parameters
    function parseUrlParams() {
        console.log("Parsing URL parameters...");
        try {
            const params = new URLSearchParams(window.location.search);
             // Check for data=null parameter (special case)
            if (params.has('data') && params.get('data') === 'null') {
                console.warn("URL parameter 'data=null' detected. Showing initial upload prompt.");
                // This case is handled by the main DOMContentLoaded flow after parsing
                return null; // Indicates special state, not lack of params
            }
             // Return params object even if empty
            console.log("URL parameters found and parsed.");
            return params;
        } catch (e) {
            console.error("Error parsing URL parameters:", e);
            // Return empty params or re-throw? Let's return empty to allow auth check
            return new URLSearchParams(); // Return empty params on error
        }
    }

    // Function to parse all financial data from URL parameters
    function parseDataFromUrlParams(params) {
        console.log("Attempting to parse financial data from URL params...");
        if (!params || typeof params.get !== 'function') {
             console.log("No valid URL params object provided.");
             return null;
        }

        // Helper function to get and decode parameter values
        const getParam = (key) => {
            if (!params.has(key)) return null;
            const rawValue = params.get(key);
            if (rawValue === null || rawValue === undefined) return null;
            try {
                // Replace '+' with space before decoding, then decode
                return decodeURIComponent(rawValue.replace(/\+/g, ' ')).trim();
            } catch (e) {
                console.warn(`Error decoding parameter ${key}:`, e);
                return rawValue.trim(); // Return raw value if decode fails
            }
        };

        // Helper function to parse numeric values, returns defaultValue on error/empty
        const parseNumeric = (key, defaultValue = 0) => {
             const value = getParam(key);
            if (value === null || value === undefined || value === '') return defaultValue;
            // Remove currency symbols, commas, etc. before parsing
            const cleaned = String(value).replace(/[^0-9.-]+/g, '');
            const number = parseFloat(cleaned);
             if (isNaN(number) || !isFinite(number)) {
                 console.warn(`Could not parse numeric value for key "${key}" from "${value}". Using default ${defaultValue}.`);
                 return number; // Return NaN/Infinity if parsing resulted in them, let getSafe handle it later
             }
            return number;
        };

        // Log key parameters for debugging - Use the exact keys from the example URL
        console.log("Debugging URL parameter parsing:");
        console.log("  userName:", getParam('userName'));
        console.log("  age:", getParam('age'));
        console.log("  mainJobIncome:", getParam('mainJobIncome'));
        console.log("  secondJobIncome:", getParam('secondJobIncome')); // Corrected key name
        console.log("  otherIncome:", getParam('otherIncome'));
        console.log("  housing:", getParam('housing'));
        console.log("  transportation:", getParam('transportation'));
        console.log("  utilities:", getParam('utilities'));
        console.log("  groceriesessentials:", getParam('groceriesessentials')); // Corrected key name
        console.log("  insurance:", getParam('insurance'));
        console.log("  medical:", getParam('medical'));
        console.log("  care:", getParam('care'));
        console.log("  subscriptions:", getParam('subscriptions'));
        console.log("  taxes:", getParam('taxes'));
        console.log("  emergencySavings:", getParam('emergencySavings'));
        console.log("  currentSavings:", getParam('currentSavings'));
        console.log("  retirementFund:", getParam('retirementFund'));
        console.log("  creditCardDebt:", getParam('creditCardDebt'));
        console.log("  bankLoans:", getParam('bankLoans'));
        console.log("  studentLoanDebt:", getParam('studentLoanDebt')); // Corrected key name
        console.log("  carLoanBalance:", getParam('carLoanBalance')); // Corrected key name
        console.log("  financialTools:", getParam('financialTools'));
        console.log("  challenges:", getParam('challenges'));
        console.log("  upcomingPurchases:", getParam('upcomingPurchases')); // Corrected key name
        console.log("  aiAnalysis:", getParam('aiAnalysis'));
        console.log("  recommendations:", getParam('recommendations'));
        console.log("  userProgressHistory:", getParam('userProgressHistory')); // Corrected key name
         console.log("  userID:", getParam('userID')); // Log raw userID param


        // Construct and return the data object based on URL parameters
        // Use getSafe or default values aggressively here
        const parsedData = {
            userInput: {
                personalInfo: {
                    userName: getParam('userName'), // Keep as string
                    age: parseNumeric('age')
                },
                income: {
                    mainJobIncome: parseNumeric('mainJobIncome'),
                    secondJobIncome: parseNumeric('secondJobIncome'), // Use exact key
                    otherIncome: parseNumeric('otherIncome')
                },
                expenses: {
                    housing: parseNumeric('housing'),
                    transportation: parseNumeric('transportation'),
                    utilities: parseNumeric('utilities'),
                    groceriesessentials: parseNumeric('groceriesessentials'), // Use exact key
                    insurance: parseNumeric('insurance'),
                    medical: parseNumeric('medical'),
                    care: parseNumeric('care'),
                    subscriptions: parseNumeric('subscriptions'),
                    taxes: parseNumeric('taxes')
                },
                savings: {
                    emergencySavings: parseNumeric('emergencySavings'), // Use exact key
                    currentSavings: parseNumeric('currentSavings'), // Use exact key
                    retirementFund: parseNumeric('retirementFund'), // Use exact key
                    emergencyFundTarget: parseNumeric('emergencyFundTarget'), // Optional explicit target
                    monthlySavingsGoal: parseNumeric('monthlySavingsGoal') // Optional explicit monthly goal
                },
                debts: [], // Debts will be populated below
                financials: {
                    financialTools: getParam('financialTools'),
                    challenges: getParam('challenges'),
                    upcomingPurchases: getParam('upcomingPurchases') // Use exact key
                }
            },
            aiOutput: {
                analysis: getParam('aiAnalysis') || 'Analysis not available.',
                recommendations: getParam('recommendations') || 'Recommendations not available.',
                userProgressHistory: getParam('userProgressHistory') || 'No progress history available.' // Use exact key
            },
             // Add a field to store the parsed xtl and userID if needed later, but DON'T use userID param for auth here
            metadata: {
                 xtl: getParam('xtl'),
                 rawUserIdParam: getParam('userID'), // Store the raw userID param value
                 // Add placeolders for userId and tier, to be populated by parseXtlParameter or file load
                 userId: null,
                 tier: 'basic',
                 source: 'url_params' // Indicate data source
            }
        };

        // Populate Debts Array - Check for existence and parse - Use exact keys
        try {
             const creditCardDebt = parseNumeric('creditCardDebt'); // Use exact key
             if (creditCardDebt > 0 && isFinite(creditCardDebt)) {
                 parsedData.userInput.debts.push({
                     type: "Credit Card",
                     balance: creditCardDebt,
                     interestRate: parseNumeric('creditCardRate', 22.5), // Default CC rate
                     minPayment: parseNumeric('creditCardMinPayment', Math.max(creditCardDebt * 0.03, 25)) // Default min payment logic
                 });
                 console.log("Added Credit Card Debt from param:", creditCardDebt);
             }

             const bankLoans = parseNumeric('bankLoans'); // Use exact key
             if (bankLoans > 0 && isFinite(bankLoans)) {
                 parsedData.userInput.debts.push({
                     type: "Bank Loans",
                     balance: bankLoans,
                     interestRate: parseNumeric('bankLoanRate', 6.5), // Default Bank Loan rate
                     minPayment: parseNumeric('bankLoanMinPayment', Math.max(bankLoans * 0.015, 50)) // Default min payment logic
                 });
                 console.log("Added Bank Loans from param:", bankLoans);
             }

             const studentLoanDebt = parseNumeric('studentLoanDebt'); // Use exact key
             if (studentLoanDebt > 0 && isFinite(studentLoanDebt)) {
                 parsedData.userInput.debts.push({
                     type: "Student Loans",
                     balance: studentLoanDebt,
                     interestRate: parseNumeric('studentLoanRate', 5.5), // Default Student Loan rate
                     minPayment: parseNumeric('studentLoanMinPayment', Math.max(studentLoanDebt * 0.01, 50)) // Default min payment logic
                 });
                 console.log("Added Student Loans from param:", studentLoanDebt);
             }

             const carLoanBalance = parseNumeric('carLoanBalance'); // Use exact key
             if (carLoanBalance > 0 && isFinite(carLoanBalance)) {
                 parsedData.userInput.debts.push({
                     type: "Car Loan",
                     balance: carLoanBalance,
                     interestRate: parseNumeric('carLoanRate', 6.0), // Default Car Loan rate
                     minPayment: parseNumeric('carLoanMinPayment', Math.max(carLoanBalance * 0.015, 100)) // Default min payment logic
                 });
                 console.log("Added Car Loan from param:", carLoanBalance);
             }
        } catch (e) {
             console.error("Error populating debt array:", e);
             // Continue with potentially empty or partially filled debts array
        }


        console.log("Parsed data object created from URL params:", parsedData);
        return parsedData;
    }

    // Helper function to show initial message when no data is found
    function showInitialPromptOrMessage(message = "Upload a PSR JSON file or sign in with Google Drive to load your dashboard.") { // Updated default message
        console.log("Executing showInitialPromptOrMessage");
        hideAllMainContentAreas(); // Hide everything else first

        // Prefer showing the structured upload prompt if available
        if (initialUploadPrompt) {
            initialUploadPrompt.style.display = 'block';
             // Ensure the upload button listener is active for this state
            const initialUploadButton = document.getElementById('initialUploadButton');
            const promptGoogleLoadButton = document.getElementById('promptGoogleLoadButton'); // The Google Load button in the prompt

            if (initialUploadButton && fileInput) {
                 initialUploadButton.style.display = 'inline-block'; // Assuming it's part of the prompt div
            } else {
                 console.warn("Initial upload button or file input not found.");
            }
             // Ensure the Google Load button in the prompt is visible if GIS client is ready AND user is not signed in
             if (promptGoogleLoadButton && googleTokenClient) { // Check if GIS client is ready
                  promptGoogleLoadButton.style.display = googleAccessToken ? 'none' : 'inline-block'; // Show only when NOT signed in
             } else if (promptGoogleLoadButton) {
                  // Hide if GIS not ready yet
                  promptGoogleLoadButton.style.display = 'none';
             } else {
                  console.warn("Prompt Google Load button not found.");
             }


            console.log("Displayed initial upload prompt.");
        } else if (initialMessageElement) {
             // Fallback to simple message if prompt not found
            initialMessageElement.textContent = message;
            initialMessageElement.style.display = 'block';
            console.log("Displayed fallback initial message element.");
        } else {
             console.warn("Could not find initial prompt or message elements.");
        }

        // Ensure chat is hidden if we revert to the initial state
        if (chatInterfaceCardElement) { chatInterfaceCardElement.style.display = 'none'; }
        enableChatInput(false); // Disable chat input as well
         setChatStatus("No data loaded", false);
         // Update Drive button visibility based on current sign-in state
         updateDriveButtonVisibility(!!googleAccessToken); // This will hide header Drive buttons if not signed in
    }

     // Helper to hide all potential main content/initial states
     function hideAllMainContentAreas() {
         if (loadingSpinner) loadingSpinner.style.display = 'none';
         if (errorMessageElement) errorMessageElement.style.display = 'none';
         if (mainContentElement) { mainContentElement.style.display = 'none'; mainContentElement.classList.add('hidden'); }
         if (initialMessageElement) initialMessageElement.style.display = 'none';
         if (initialUploadPrompt) initialUploadPrompt.style.display = 'none';
         closeModal('driveLoadModal'); // Close the Drive load modal if open
         closeModal('progressModal'); // Close other modals too
         closeModal('infoModal');
     }


    // --- Debugging & Error Handling ---
    function debugURLParameters() {
        if (!debugInfoElement) return; // Check if element exists
        const params = new URLSearchParams(window.location.search);
        let paramsText = '<strong>URL Params:</strong><br>';
        if (params.toString() === '') {
            paramsText += '<span style="color:gray;">None</span><br>';
        } else {
            paramsText += '<table style="width:100%; font-size:10px; border-collapse: collapse;"><thead><tr style="background:#eee;"><th style="border:1px solid #ccc; padding: 2px;">Param</th><th style="border:1px solid #ccc; padding: 2px;">Value</th></tr></thead><tbody>';
            for (const [key, value] of params.entries()) {
                // Truncate long values for display in debug box
                const displayValue = (value && value.length > 150) ? value.substring(0, 150) + '...' : (value || '<i style="color:gray;">(empty)</i>');
                paramsText += `<tr><td style="border:1px solid #ccc; padding: 2px; word-break:break-all;">${key}</td><td style="border:1px solid #ccc; padding: 2px; word-break:break-all;">${displayValue}</td></tr>`;
            }
            paramsText += '</tbody></table>';
        }
        // Append to existing debug info safely
        const currentDebugHTML = debugInfoElement.innerHTML;
        // Add params at the top, remove old params if present
        debugInfoElement.innerHTML = paramsText + '<hr style="margin: 5px 0;">' + currentDebugHTML.replace(/^<strong>URL Params:.*?<hr style="margin: 5px 0;">/s, '');
    }

    function handleError(message, error, isAccessError = false) {
        console.error("HANDLE ERROR TRIGGERED:", message, error);

        // Ensure elements exist before manipulating (using cached elements)
        errorTextElement = errorTextElement || document.getElementById('errorText'); // Fallback if cache failed
        debugInfoElement = debugInfoElement || document.getElementById('debugInfo');
        errorMessageElement = errorMessageElement || document.getElementById('errorMessage'); // Fallback

        // Populate error details
        if (errorTextElement) {
            errorTextElement.textContent = `${message}. See details below.`;
        } else {
            console.error("Error text element not found!");
        }
        if (debugInfoElement) {
            debugInfoElement.innerHTML = ''; // Clear previous debug info first
            debugURLParameters(); // Add URL parameters FIRST
            debugInfoElement.innerHTML += `<br><strong>Error Type:</strong> ${getSafe(() => error.name, 'N/A')}`;
            debugInfoElement.innerHTML += `<br><strong>Error Message:</strong><br><span style="color:red;">${getSafe(() => error.message, 'Unknown error')}</span>`;
            if (error?.stack) {
                // Make stack trace more readable
                debugInfoElement.innerHTML += `<br><strong>Stack Trace:</strong><br><code style="font-size:10px; white-space: pre-wrap; display: block; line-height:1.2;">${error.stack.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code>`;
            }
             // Add more context like user ID, tier, data source
             debugInfoElement.innerHTML += `<br><strong>User ID:</strong> ${currentUserId || 'N/A'}`;
             debugInfoElement.innerHTML += `<br><strong>Effective Tier:</strong> ${effectiveTier || 'N/A'}`;
             debugInfoElement.innerHTML += `<br><strong>Data Source:</strong> ${getSafe(() => dashboardData?.metadata?.source, 'N/A')}`;
        } else {
            console.error("Debug info element not found!");
        }

        // Manage UI visibility
        hideAllMainContentAreas(); // Hide everything first

        if (errorMessageElement) {
            errorMessageElement.style.display = 'flex'; // Use flex for centering
            console.log("Error message shown by handleError.");

             // Adjust retry/demo buttons based on error type if needed
             const retryButton = document.getElementById('retryButton');
             const manualEntryButton = document.getElementById('manualEntryButton');
             if (isAccessError) {
                 if (retryButton) retryButton.style.display = 'none'; // Retry likely won't fix invalid access
                 if (manualEntryButton) manualEntryButton.style.display = 'inline-block'; // Offer demo
             } else {
                 if (retryButton) retryButton.style.display = 'inline-block'; // Offer retry for other errors
                 if (manualEntryButton) manualEntryButton.style.display = 'inline-block'; // Offer demo as alternative
             }

        } else {
            console.error("Error message element not found! Displaying alert fallback.");
            // Fallback alert if the error UI can't be shown
            alert(`Critical Application Error:\n\n${message}\n\nDetails: ${error?.message || 'Unknown error'}`);
        }
        // Disable chat on error
        enableChatInput(false);
        setChatStatus("Error occurred", false);
         if (chatInterfaceCardElement) chatInterfaceCardElement.style.display = 'none'; // Ensure chat is hidden
         // Update Drive button visibility to reflect error state (likely not signed in)
         updateDriveButtonVisibility(!!googleAccessToken); // Pass current token state
    }

    // --- Demo Data ---
    function useDemoData() {
        console.log("Using Demo Data");
         // Ensure error message is hidden before processing
        hideAllMainContentAreas();
        if (loadingSpinner) loadingSpinner.style.display = 'flex'; // Show spinner briefly

        // A more complete demo data structure matching potential real data
        const demoData = {
            userInput: {
                personalInfo: { userName: "Demo User", age: 35 },
                income: { mainJobIncome: 5500, secondJobIncome: 1200, otherIncome: 300 },
                expenses: { housing: 1800, utilities: 250, transportation: 450, groceriesessentials: 600, insurance: 350, medical: 150, care: 100, subscriptions: 80, taxes: 1100 },
                savings: { emergencySavings: 8000, currentSavings: 15000, retirementFund: 75000, emergencyFundTarget: 15000, monthlySavingsGoal: 500 },
                debts: [
                    { type: "Credit Card", balance: 4500, interestRate: 22.5, minPayment: 150 },
                    { type: "Student Loans", balance: 25000, interestRate: 5.5, minPayment: 280 },
                    { type: "Car Loan", balance: 12000, interestRate: 6.5, minPayment: 300 }
                ],
                financials: {
                    financialTools: "Budgeting App (YNAB), Credit Monitor (Credit Karma)",
                    challenges: "Saving consistently for down payment, Reducing high-interest CC debt",
                    upcomingPurchases: "#1) House Down Payment, $25000, 24 months" // Example matching regex
                }
            },
            aiOutput: {
                analysis: "Cash flow is positive ($1120/month). Emergency fund covers ~2 months of core expenses (target is 3-6). High DTI ratio (31%) primarily due to student/car loans, but CC debt is high interest. Good retirement savings.",
                recommendations: "- Prioritize paying off the 22.5% interest credit card.\n- Aim to increase emergency fund to $10,000 (3 months expenses).\n- Continue consistent retirement contributions.\n- Review subscription expenses for potential savings.",
                userProgressHistory: "2024-12-01: Initial report generated (Demo Data).\n2025-03-15: Credit card balance reduced by $500. Emergency fund increased by $1000."
            },
             // Add metadata for demo data - use a placeholder user ID
            metadata: {
                 userId: 'demo-user-123',
                 tier: 'basic',
                 source: 'demo_data'
            },
            chatHistory: [
                 { role: 'assistant', content: "Hello! Ask me anything about the financial data shown on your dashboard." }
            ]
        };

        // Use a timeout to simulate loading and ensure spinner is seen briefly
        setTimeout(() => {
            // IMPORTANT: When using demo data, we *reset* the Supabase user context
            currentUserId = demoData.metadata.userId;
            effectiveTier = demoData.metadata.tier;
            chatMessages = demoData.chatHistory; // Load demo chat history
            initialUsageInfo = { // Simulate usage info for demo user
                 usage: 0,
                 limit: (effectiveTier === 'pro' ? 500000 : 15000), // Use realistic limits for demo tier
                 model: (effectiveTier === 'pro') ? 'gpt-4o-mini' : 'gpt-3.5-turbo', // Use realistic models for demo tier
                 tier: effectiveTier,
                 actualDbTier: 'demo', // Indicate it's demo data
                 lastReset: new Date().toISOString(), // Simulate a recent reset
                 resetDue: false,
                 userFoundInDb: true // Simulate user exists (for chat enablement)
            };

            console.log("Rendering demo data...");
            processAndDisplayData(demoData); // Process the demo data
            // Hide spinner is handled by processAndDisplayData finally block
            // Button visibility updated by processAndDisplayData -> updateDriveButtonVisibility

        }, 500); // Simulate a small delay
    }

    // --- Parse XTL Parameter for Authentication ---
    function parseXtlParameter(params) {
        console.log("Parsing XTL parameter...");
        if (!params || typeof params.get !== 'function') {
             console.warn("No URL params available for XTL parsing.");
             // Do not treat missing params as invalid access here, just no XTL user
             currentUserId = null;
             effectiveTier = 'basic';
             return false; // Indicate failure
        }

        const xtlParam = params.get('xtl');
        let userIdFromXtl = null;
        let tierFromXtl = 'basic'; // Default assumption

        console.log("XTL parameter found:", xtlParam);

        if (xtlParam && xtlParam.length === 21) {
            try {
                // Extract the verification segment (characters 7-11, index 6-10)
                const verificationSegment = xtlParam.substring(6, 11);
                // Extract the user ID segment (characters 12-21, index 11-end)
                const userIdSegment = xtlParam.substring(11);

                console.log("Parsed XTL: verification segment =", verificationSegment, "user ID segment =", userIdSegment);

                // Validate both segments
                if (/^[a-zA-Z0-9]{5}$/.test(verificationSegment) && userIdSegment.length === 10) {
                    // Set tier based on verification segment
                    if (verificationSegment === '16j59') {
                        tierFromXtl = 'pro';
                        console.log("Verified pro tier access via XTL.");
                    } else if (verificationSegment === '83n45') {
                        tierFromXtl = 'basic';
                        console.log("Verified basic tier access via XTL.");
                    } else {
                        console.error("Unrecognized verification segment in XTL:", verificationSegment);
                        handleInvalidAccess("Invalid Access Code Segment in XTL"); // Treat as invalid access if segment is unknown
                        return false; // Indicate failure
                    }

                    // Set the user ID since verification passed
                    userIdFromXtl = userIdSegment;
                    console.log("XTL parsing successful. User ID:", userIdFromXtl, "Tier:", tierFromXtl);

                    // Set globals
                    currentUserId = userIdFromXtl;
                    effectiveTier = tierFromXtl;

                    return true; // Indicate success

                } else {
                    console.error("Invalid XTL format: verification segment or user ID segment has wrong format");
                    handleInvalidAccess("Invalid XTL Format"); // Treat as invalid access if format is wrong
                    return false; // Indicate failure
                }
            } catch (e) {
                 console.error("Error processing XTL parameter:", e);
                 handleInvalidAccess("Error Processing XTL Parameter"); // Treat as invalid access on processing error
                 return false; // Indicate failure
            }
        } else {
            console.warn("XTL parameter missing or wrong length. Proceeding without authenticated user via XTL.");
            // This is not an invalid access, just means no XTL user context
            // currentUserId and effectiveTier will remain null/basic from initial declaration
            return false; // Indicate no authenticated user was found via XTL
        }
    }

    // Function to fetch initial usage for UI feedback and final access check
    async function fetchInitialUsage() {
        console.log("Fetching initial usage info...");

        // Ensure Supabase client is initialized
        if (!supabase) {
            console.warn("Supabase client not initialized before fetching usage. Attempting initialization.");
             try {
                if (typeof window.supabase === 'undefined' || !window.supabase?.createClient) {
                    throw new Error("Supabase library not loaded.");
                }
                const { createClient } = window.supabase;
                supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log("Supabase client initialized during fetch attempt.");
             } catch (err) {
                console.error("Error initializing Supabase during fetch:", err);
                initialUsageInfo = { error: "Could not initialize service connection." };
                 updateUIBasedOnAccess(); // Update UI to show error state
                 return; // Stop fetch process
             }
        }

        if (!currentUserId) {
            console.log("Skipping initial usage fetch: No user ID available (XTL not parsed or invalid, or demo data not loaded).");
            initialUsageInfo = { error: "No valid user ID for access check." }; // Indicate why chat might not work
            updateUIBasedOnAccess(); // Update UI based on no user ID
            return; // Exit early
        }


        console.log(`Attempting to fetch user data for ID: ${currentUserId}`);

        try {
            // Using the ANON key here requires appropriate RLS on your 'SWN_Users' table
            // to allow reading 'token_usage', 'last_token_reset', 'tier' for the user matching 'id' column
            const { data, error } = await supabase
                .from('SWN_Users')
                .select('token_usage, last_token_reset, tier')
                .eq('id', currentUserId) // Using the ID derived from XTL or demo data
                .maybeSingle();

            if (error && error.code !== 'PGRST116') { // PGRST116 is 'results in 0 rows'
                console.error("Error fetching initial usage:", error.message);
                initialUsageInfo = { error: `Error loading usage data: ${error.message}` };
                updateUIBasedOnAccess();
            } else if (data) {
                console.log("Initial usage data fetched:", data);
                // Note: The backend function is the source of truth for tier/limit/model based on header.
                // This fetch is primarily for displaying client-side usage info.
                // We'll use the tier determined by XTL (effectiveTier) for the frontend UI and backend header,
                // but also show the DB tier for potential debugging if needed.
                const determinedLimit = (effectiveTier === 'pro') ? 500000 : 15000; // Client-side assumption for display

                const now = new Date();
                const lastReset = data.last_token_reset ? new Date(data.last_token_reset) : null;
                let currentUsage = Number(getSafe(() => data.token_usage, 0)) || 0; // Ensure it's a number, default to 0

                // Check if weekly reset is due (same logic as backend)
                let needsReset = !lastReset || (now.getTime() - lastReset.getTime()) / (1000 * 60 * 60 * 24) >= 7;

                // Reflect reset state for the frontend display calculation
                // Frontend display shows actual usage from DB, but notes if reset is pending/needed
                // currentUsage = 0; // <-- Reverted this - show actual usage


                initialUsageInfo = {
                    usage: currentUsage, // Usage from DB
                    limit: determinedLimit, // Limit based on frontend effective tier
                    model: (effectiveTier === 'pro') ? 'gpt-4o-mini' : 'gpt-3.5-turbo', // Model based on frontend effective tier
                    tier: effectiveTier, // Tier derived from XTL or loaded data (used for backend calls)
                    actualDbTier: data.tier, // Tier stored in DB (for comparison/debug)
                    lastReset: data.last_token_reset,
                    resetDue: needsReset,
                    userFoundInDb: true // Flag indicating the user exists in the DB
                };
                console.log("Initial Usage Info Calculated:", initialUsageInfo);
                updateUIBasedOnAccess(); // Update UI based on fetched info

            } else {
                // data is null and error is PGRST116 - User ID not found in DB
                console.warn(`User ID ${currentUserId} not found in SWN_Users table during initial fetch.`);
                // This user will be registered on their first chat request by the updated backend.
                // For frontend display, show 0 usage but indicate user not found in initial fetch.
                 initialUsageInfo = {
                    usage: 0, // Assume 0 usage for a new user
                    limit: (effectiveTier === 'pro') ? 500000 : 15000, // Use configured limits for display
                    model: (effectiveTier === 'pro') ? 'gpt-4o-mini' : 'gpt-3.5-turbo', // Use configured models for display
                    tier: effectiveTier, // Tier derived from XTL or loaded data
                    actualDbTier: null, // Not found in DB
                    lastReset: null,
                    resetDue: true, // New user needs a reset timestamp set on first use
                    userFoundInDb: false // Flag indicating the user does NOT exist in the DB yet
                 };
                 console.log("Initial Usage Info (User Not Found in DB) Calculated:", initialUsageInfo);
                updateUIBasedOnAccess(); // Update UI assuming a new user state
            }
        } catch (err) {
            console.error("Unexpected error fetching initial usage:", err);
            initialUsageInfo = { error: "Unexpected error loading usage data." };
            updateUIBasedOnAccess(); // Update UI with error
        }
    }

    function handleInvalidAccess(reason) {
        console.error("Access Denied or Invalid:", reason);
        currentUserId = null; // Explicitly nullify user ID
        effectiveTier = 'basic'; // Reset tier assumption
        initialUsageInfo = null; // Clear usage info

        // Use the central error handler to ensure visibility
        handleError(`Access Error: ${reason}`, new Error(reason), true); // Pass true for isAccessError
    }

    // This function now updates the chat status display info AND calls initializeChat
    function updateUIBasedOnAccess() {
        console.log("Executing updateUIBasedOnAccess to update Tier/Usage display info START");
        console.log("  currentUserId:", currentUserId);
        console.log("  effectiveTier:", effectiveTier);
        console.log("  initialUsageInfo:", initialUsageInfo); // Log the state of the data object

        // Get references to the new display elements inside the chat status bar
        const tierDisplay = document.getElementById('chatTierDisplay');
        const modelDisplay = document.getElementById('chatModelDisplay');
        const usageDisplay = document.getElementById('chatUsageDisplay');

        console.log("  Found chat status elements:", {
            tierDisplay: !!tierDisplay, // Check if element was found (true/false)
            modelDisplay: !!modelDisplay,
            usageDisplay: !!usageDisplay
        });


        // Default display values
        let tierText = 'Loading...'; // Use 'Loading...' as an explicit state
        let modelText = '-';
        let usageText = '- / -';

        if (initialUsageInfo) { // Check if initialUsageInfo object exists at all
             console.log("  initialUsageInfo exists.");
             if (!initialUsageInfo.error) { // Check if there was an error fetching info
                   console.log("  initialUsageInfo has no error.");
                   // We have valid usage info
                    const usage = initialUsageInfo.usage !== undefined ? initialUsageInfo.usage : NaN;
                    const limit = initialUsageInfo.limit !== undefined ? initialUsageInfo.limit : NaN;

                    // Use the tier/model from initialUsageInfo if available, fallback to effectiveTier
                    // initialUsageInfo.tier and model are determined by effectiveTier in fetchInitialUsage
                    tierText = (initialUsageInfo.tier || effectiveTier).charAt(0).toUpperCase() + (initialUsageInfo.tier || effectiveTier).slice(1); // Capitalize tier
                    modelText = initialUsageInfo.model || 'N/A';

                    console.log("  Calculated raw values:", { usage, limit, tierText, modelText });


                    if (!isNaN(usage) && isFinite(usage) && !isNaN(limit) && isFinite(limit)) {
                         usageText = `${Math.floor(usage).toLocaleString()} / ${Math.floor(limit).toLocaleString()}`; // Floor usage/limit for display
                    } else {
                         usageText = 'ErrorCalculating'; // Indicate if usage/limit numbers are invalid
                    }

                    if(initialUsageInfo.resetDue && initialUsageInfo.userFoundInDb) usageText += " (Reset Pending)"; // Only show reset pending if user is found
                    if(!initialUsageInfo.userFoundInDb && currentUserId) tierText += " (New User)"; // Append note if needed (e.g., 'basic (New)')

                    console.log("  Formatted text values:", { tierText, modelText, usageText });

             } else {
                   // Error loading usage info
                    tierText = 'ErrorFetch'; // Indicate error state
                    modelText = 'ErrorFetch';
                    usageText = 'ErrorFetch';
                    console.warn("  Displaying Error state due to initialUsageInfo.error:", initialUsageInfo.error);
             }
        } else if (!currentUserId) {
            // No valid user ID available (XTL parsing failed or missing, and no data loaded)
            tierText = 'No User'; // Indicate no user
            modelText = 'N/A';
            usageText = '- / -';
             console.log("  No currentUserId available.");
        } else {
             // initialUsageInfo is null/undefined, but user ID is present.
             // This means fetchInitialUsage hasn't completed yet or failed silently before setting initialUsageInfo.error.
             console.log("  initialUsageInfo is null/undefined, user ID present. Still loading?");
             // The "Loading..." defaults set initially will cover this.
             tierText = 'Loading...'; // Explicitly show loading state
             modelText = 'Loading...';
             usageText = 'Loading...';
        }

        // Update the text content of the new spans in the chat status bar
        if (tierDisplay) tierDisplay.textContent = tierText;
        else console.error("Chat tier display element (#chatTierDisplay) not found - critical for status display."); // Changed warn to error for clarity

        if (modelDisplay) modelDisplay.textContent = modelText;
        else console.error("Chat model display element (#chatModelDisplay) not found - critical for status display."); // Changed warn to error

        console.log("  Attempting to update Usage display with:", usageText); // <-- LOG BEFORE SETTING TEXT
        if (usageDisplay) {
            usageDisplay.textContent = usageText; // <-- This line updates the usage display
            console.log("  Successfully updated Usage display."); // <-- LOG AFTER SETTING TEXT
        } else {
            console.error("Chat usage display element (#chatUsageDisplay) not found - critical for status display.");
        }

        console.log("  Finished updating chat status elements."); // <-- LOG AFTER ALL ELEMENTS ARE HANDLED


        // Update any pro-specific UI elements (e.g., buttons) based on the effectiveTier
        const proFeatureButton = document.getElementById('proFeatureButton'); // Assuming you have such a button
        if (proFeatureButton) {
            proFeatureButton.style.display = (effectiveTier === 'pro') ? 'inline-block' : 'none';
        } else { console.warn("Pro feature button element not found."); } // Keep as warn


        // Trigger chat initialization/update AFTER usage info is processed and displayed
        // This ensures the chat UI visibility/state (enabled/disabled) reflects the latest access status
        console.log("  Calling initializeChat() from updateUIBasedOnAccess.");
        initializeChat(); // This remains crucial

        console.log("Executing updateUIBasedOnAccess END");
    }

    // --- Main Data Processing & Display Function ---
    function processAndDisplayData(data) {
        console.log("--- processAndDisplayData START ---", data);
        // Basic validation of the data structure
        if (!data || typeof data !== 'object' || !data.userInput || !data.userInput.personalInfo || Object.keys(getSafe(() => data.userInput.personalInfo, {})).length === 0) {
            console.error("Invalid or incomplete data structure received by processAndDisplayData", data);
            handleError("Invalid or incomplete data format for processing. Cannot display dashboard.", new Error("Data structure is missing 'userInput' or 'personalInfo'."));
            // Force initial prompt if data is invalid here? Or let handleError handle it?
            // Let handleError handle it, it hides everything and shows error modal.
            return; // Stop processing
        }
        dashboardData = data; // Update global reference

        // Update user context based on loaded data's metadata if available and valid
        // This should potentially merge/prioritize URL/XTL context vs file metadata
        // For now, stick to file metadata overriding, but ensure globals are set correctly
        if (dashboardData.metadata && typeof dashboardData.metadata.userId === 'string' && dashboardData.metadata.userId.length > 0) {
             console.log(`Updating user context from loaded data metadata: User ID = ${dashboardData.metadata.userId}, Tier = ${dashboardData.metadata.tier}`);
             currentUserId = dashboardData.metadata.userId;
             effectiveTier = getSafe(() => dashboardData.metadata.tier, 'basic');
             // Ensure tier is valid if provided, default to basic
             if (!['basic', 'pro'].includes(effectiveTier)) {
                 effectiveTier = 'basic';
                 console.warn("Invalid tier found in file metadata. Defaulting to basic.");
             }
             // Re-fetch usage info for the newly set user ID
             fetchInitialUsage(); // This will also call updateUIBasedOnAccess and initializeChat
        } else {
             console.warn("No user ID or tier found in loaded data metadata. Keeping current context (from XTL or default).");
             // If no metadata, rely on currentUserId/effectiveTier set by XTL or defaults
             // Ensure the dashboardData object gets the current user context before saving
             dashboardData.metadata = dashboardData.metadata || {};
             dashboardData.metadata.userId = currentUserId;
             dashboardData.metadata.tier = effectiveTier;
             dashboardData.metadata.source = dashboardData.metadata.source || 'unknown'; // Keep existing source if present

             updateUIBasedOnAccess(); // Ensure UI reflects current user/tier/usage state
        }

         // Load chat history from data if available
         chatMessages = Array.isArray(getSafe(() => dashboardData.chatHistory)) ? dashboardData.chatHistory.filter(msg => msg && msg.role && msg.content) : []; // Filter valid messages
         console.log(`Loaded ${chatMessages.length} chat messages from data.`);

        // Recalculate totals and ratios after loading new data
         const totals = calculateTotals(data);
         const ratios = calculateRatios(data, totals);


        try {
            console.log("1. Calculating totals...");
            // Totals already calculated above
            console.log("Totals calculated:", totals);

            console.log("2. Calculating ratios...");
             // Ratios already calculated above
            console.log("Ratios calculated:", ratios);

            console.log("3. Updating basic info UI...");
            updateReportBasics(data, totals);
            console.log("Basic info UI updated.");

            console.log("4. Updating ratios UI...");
            updateRatiosDisplay(ratios);
            console.log("Ratios UI updated.");

            console.log("5. Updating goals UI...");
            updateGoalsDisplay(data, totals);
            console.log("Goals UI updated.");

            console.log("6. Updating debts UI...");
            console.log("  About to call updateDebtsDisplay...");
            updateDebtsDisplay(data, totals);
            console.log("Debts UI updated.");

            console.log("7. Scheduling chart rendering...");
            // Use requestAnimationFrame to ensure DOM is ready for Plotly
            requestAnimationFrame(() => {
                console.log("7a. Executing chart rendering (inside requestAnimationFrame)...");
                try {
                    renderCharts(data, totals); // Pass totals for core expenses calculation if needed
                    console.log("Charts rendered successfully.");
                } catch (chartError) {
                    console.error("--- Error during renderCharts ---", chartError);
                    // Display error within the chart divs
                    const incomeChartDiv = document.getElementById('incomeChart');
                    const expenseChartDiv = document.getElementById('expenseChart');
                    if(incomeChartDiv) incomeChartDiv.innerHTML = `<p class="text-red-600 text-center p-4">Error loading income chart:<br>${getSafe(() => chartError.message, 'Unknown chart error')}</p>`;
                    if(expenseChartDiv) expenseChartDiv.innerHTML = `<p class="text-red-600 text-center p-4">Error loading expense chart:<br>${getSafe(() => chartError.message, 'Unknown chart error')}</p>`;
                }
            });

            console.log("8. Updating AI display UI...");
            updateUIDisplayFromAI(data);
            console.log("AI display UI updated.");

            // Chat initialization happens via updateUIBasedOnAccess which is called after metadata processing or in finally block

            console.log("9. Making main content visible...");
            hideAllMainContentAreas(); // Hide other states
            if (mainContentElement) {
                mainContentElement.style.display = 'block'; // Use block display (or grid if appropriate)
                mainContentElement.classList.remove('hidden'); // Ensure class is removed if used
                console.log("Main content should now be visible.");
            } else {
                 console.error("Main content element not found!");
                 handleError("Critical: Main content element not found.", new Error("DOM element #mainContent is missing."));
            }

        } // <-- This brace closes the 'try' block of processAndDisplayData

        catch (processingError) {
            console.error("--- processAndDisplayData ERROR ---", processingError);
            handleError("Error processing or displaying data", processingError);
        } finally {
            // Ensure spinner is hidden regardless of success/failure within the try block
            console.log("Executing finally block in processAndDisplayData.");
            if (loadingSpinner) {
                loadingSpinner.style.display = 'none';
                console.log("Spinner hidden by processAndDisplayData finally block.");
            } else {
                console.warn("Spinner element not found in finally block.");
            }
             // Ensure chat is initialized/updated after data processing is complete
            console.log("Calling initializeChat() from processAndDisplayData finally block.");
            initializeChat(); // This will read the updated chatMessages and user context

            // Update button visibility now that data is loaded
             updateDriveButtonVisibility(!!googleAccessToken); // Re-evaluate based on current token state
            console.log("--- processAndDisplayData END ---");
        }
    } // <-- This brace closes the processAndDisplayData function

    // --- Calculation Functions ---
    function calculateTotals(data) {
        console.log("Calculating totals...");
        const totals = {
            totalIncome: 0, totalExpenses: 0, netFlow: 0,
            totalDebt: 0, totalSavings: 0, totalMinPayments: 0,
            monthlyCoreExpenses: 0 // Added for emergency fund calc
        };

        try {
            const income = getSafe(() => data.userInput?.income, {});
            const expenses = getSafe(() => data.userInput?.expenses, {});
            const savings = getSafe(() => data.userInput?.savings, {});
            const debts = getSafe(() => data.userInput?.debts, []);

            // Income: Sum known income types
            totals.totalIncome = (Number(getSafe(() => income.mainJobIncome, 0)) || 0) + (Number(getSafe(() => income.secondJobIncome, 0)) || 0) + (Number(getSafe(() => income.otherIncome, 0)) || 0); // Corrected key


            // Expenses & Core Expenses: Iterate through expenses object
            // Define core expenses - ADJUST THESE KEYS TO MATCH YOUR DATA EXACTLY
             // Assuming min payments from debts are *not* included in expenses object directly
            const coreExpenseKeys = ['housing', 'utilities', 'transportation', 'groceriesessentials', 'insurance', 'medical', 'care', 'subscriptions', 'taxes']; // Corrected key

            for (const key in expenses) {
                const value = Number(getSafe(() => expenses[key], 0)) || 0;
                totals.totalExpenses += value;
                // Check if the expense key is considered 'core'
                if (coreExpenseKeys.includes(key)) {
                    totals.monthlyCoreExpenses += value;
                }
            }

            // Debts: Sum balance and minimum payments from the debts array
            if (Array.isArray(debts)) {
                debts.forEach(debt => {
                    totals.totalDebt += Number(getSafe(() => debt.balance, 0)) || 0;
                    const minPayment = Number(getSafe(() => debt.minPayment, 0)) || 0;
                    totals.totalMinPayments += minPayment;
                });
            }

            // Add total minimum debt payments to total expenses and core expenses
            totals.totalExpenses += totals.totalMinPayments;
            totals.monthlyCoreExpenses += totals.totalMinPayments; // Min payments are usually core

            totals.netFlow = totals.totalIncome - totals.totalExpenses;

            // Savings: Sum known savings types
            totals.totalSavings = (Number(getSafe(() => savings.emergencySavings, 0)) || 0) + (Number(getSafe(() => savings.currentSavings, 0)) || 0) + (Number(getSafe(() => savings.retirementFund, 0)) || 0); // Corrected keys

             console.log("Totals calculation successful.");
        } catch (e) {
             console.error("Error during calculateTotals:", e);
             // Return partial totals or re-throw? Returning partial is more robust
             return totals; // Return whatever was calculated before the error
        }

        return totals;
    }

    function calculateRatios(data, totals) {
        console.log("Calculating ratios...");
        const ratios = { savingsRate: 0, emergencyCoverage: 0, dtiRatio: 0 };

         // Check if totals are valid before calculating ratios
         if (typeof totals !== 'object' || isNaN(totals.totalIncome) || isNaN(totals.totalExpenses) || isNaN(totals.totalMinPayments) || isNaN(totals.monthlyCoreExpenses)) {
             console.error("Invalid totals provided for ratio calculation.");
             return ratios; // Return zero ratios
         }

        try {
            const savingsInput = getSafe(() => data.userInput?.savings, {});

            // Savings Rate: Use explicit monthly goal if available, otherwise use positive net flow proxy
            const monthlySavingsGoal = Number(getSafe(() => savingsInput.monthlySavingsGoal, 0));
            // Use the goal if defined AND positive, otherwise use net flow (but cap at 0 if net flow is negative)
            const contribution = (monthlySavingsGoal > 0) ? monthlySavingsGoal : Math.max(0, totals.netFlow);

            if (totals.totalIncome > 0) {
                // Savings rate = (Amount Saved Per Month / Gross Monthly Income)
                ratios.savingsRate = (contribution / totals.totalIncome); // Rate as decimal
            } else {
                ratios.savingsRate = 0; // Avoid division by zero
            }

            // Emergency Fund Coverage (Months based on CORE expenses)
            const currentEmergencyFund = Number(getSafe(() => savingsInput.emergencySavings, 0)) || 0; // Corrected key
            if (totals.monthlyCoreExpenses > 0) {
                ratios.emergencyCoverage = currentEmergencyFund / totals.monthlyCoreExpenses; // Result in months
            } else if (totals.totalExpenses > 0) {
                // Fallback if core expenses somehow end up zero but total expenses > 0
                ratios.emergencyCoverage = currentEmergencyFund / totals.totalExpenses;
                console.warn("Using total expenses for emergency coverage calculation as core expenses were zero.")
            } else {
                ratios.emergencyCoverage = Infinity; // If no expenses, coverage is infinite (or handle as special case)
            }

            // Debt-to-Income (DTI) Ratio (using minimum payments from totals)
            // DTI = (Total Monthly Minimum Debt Payments / Gross Monthly Income)
            if (totals.totalIncome > 0) {
                ratios.dtiRatio = (totals.totalMinPayments / totals.totalIncome); // Rate as decimal
            } else {
                ratios.dtiRatio = 0; // Or Infinity if debts exist but income is zero? Define behavior.
            }
             console.log("Ratios calculation successful.");
        } catch (e) {
             console.error("Error during calculateRatios:", e);
             return ratios; // Return partial ratios or re-throw? Returning partial is more robust
        }

        return ratios;
    }

    // --- UI Update Functions ---
    function updateReportBasics(data, totals) {
        console.log("Updating report basics UI...");
        try {
            const personalInfo = getSafe(() => data.userInput?.personalInfo, {});
            const savings = getSafe(() => data.userInput?.savings, {});
            const financials = getSafe(() => data.userInput?.financials, {});

            updateElementText('userName', getSafe(() => personalInfo.userName));
            updateElementText('age', getSafe(() => personalInfo.age)); // Assumes age is just a number
            updateElementText('totalIncome', totals.totalIncome, formatCurrency);
            updateElementText('totalExpenses', totals.totalExpenses, formatCurrency);
            updateElementText('netFlow', totals.netFlow, formatCurrency);

            // Update Savings Overview Card
            updateElementText('emergencySavings', getSafe(() => savings.emergencySavings), formatCurrency); // Corrected key
            updateElementText('currentSavings', getSafe(() => savings.currentSavings), formatCurrency); // Corrected key
            updateElementText('retirementFund', getSafe(() => savings.retirementFund), formatCurrency); // Corrected key

            // Update Financial Tools & Goals Card (specific fields)
            updateElementText('financialTools', getSafe(() => financials.financialTools));
            updateElementText('challenges', getSafe(() => financials.challenges));
            updateElementText('purchaseGoals', getSafe(() => financials.upcomingPurchases)); // Corrected key
            console.log("Report basics UI updated.");
        } catch (e) {
            console.error("Error updating report basics UI:", e);
        }
    }

    function updateRatiosDisplay(ratios) {
        console.log("Updating ratios display UI...");
        try {
            // Savings Rate
            const savingsRateValue = getSafe(() => ratios.savingsRate, 0);
            updateElementText('savingsRateValue', savingsRateValue, val => formatPercentage(val, 1));
            const savingsRatePercent = Math.min(100, Math.max(0, savingsRateValue * 100));
            const savingsBar = document.getElementById('savingsRateBar');
            if (savingsBar) {
                savingsBar.style.width = `${savingsRatePercent}%`;
                // Recommendation: Poor < 5%, Ok 5-10%, Good 10-15%, Excellent > 15% (Adjust thresholds as needed)
                savingsBar.className = `ratio-bar savings-rate ${savingsRateValue >= 0.10 ? 'good' : savingsRateValue >= 0.05 ? 'ok' : 'poor'}`; // Example thresholds
            } else { console.warn("Savings rate bar element not found."); }

            // Emergency Fund Coverage (Display in Months)
            const emergencyCoverageMonths = getSafe(() => ratios.emergencyCoverage, 0);
             const emergencyCoverageText = emergencyCoverageMonths === Infinity ? 'N/A (No Expenses)' : `${emergencyCoverageMonths.toFixed(1)} months`;
            updateElementText('emergencyCoverageValue', emergencyCoverageText);
            const emergencyBar = document.getElementById('emergencyCoverageBar');
            if (emergencyBar) {
                // Progress towards a target, e.g., 6 months. Cap at 100%. Handle Infinity.
                const targetMonths = 6; // This threshold could also come from data if available
                const emergencyProgressPercent = emergencyCoverageMonths === Infinity ? 100 : Math.min(100, Math.max(0, (emergencyCoverageMonths / targetMonths) * 100));
                emergencyBar.style.width = `${emergencyProgressPercent}%`;
                // Recommendation: Poor < 1 month, Ok 1-3 months, Good 3-6 months, Excellent > 6 months (Adjust thresholds)
                emergencyBar.className = `ratio-bar emergency-coverage ${emergencyCoverageMonths >= 3 ? 'good' : emergencyCoverageMonths >= 1 ? 'ok' : 'poor'}`;
            } else { console.warn("Emergency coverage bar element not found."); }


            // DTI Ratio
            const dtiRatioValue = getSafe(() => ratios.dtiRatio, 0);
            updateElementText('dtiRatioValue', dtiRatioValue, val => formatPercentage(val, 1));
            const dtiPercent = Math.min(100, Math.max(0, dtiRatioValue * 100));
            const dtiBar = document.getElementById('dtiRatioBar');
            if (dtiBar) {
                dtiBar.style.width = `${dtiPercent}%`;
                // General guideline: Good < 36%, Warning 36-43%, High > 43% (Adjust thresholds)
                dtiBar.className = `ratio-bar dti-ratio ${dtiRatioValue > 0.43 ? 'high' : dtiRatioValue >= 0.36 ? 'warning' : 'good'}`;
            } else { console.warn("DTI ratio bar element not found."); }
             console.log("Ratios display UI updated.");
        } catch (e) {
            console.error("Error updating ratios display UI:", e);
        }
    }

    function updateGoalsDisplay(data, totals) {
        console.log("Updating goals display UI...");
        try {
            const savingsInput = getSafe(() => data.userInput?.savings, {});
            const financialsInput = getSafe(() => data.userInput?.financials, {});
            const upcomingPurchaseString = getSafe(() => financialsInput.upcomingPurchases, ''); // Corrected key

            const emergencyGoalDisplay = document.getElementById('emergencyGoalDisplay');
            const purchaseGoalDisplay = document.getElementById('purchaseGoalDisplay');
            const noGoalsMessage = document.getElementById('noGoalsMessage');
            let hasVisibleGoal = false;

            // --- Emergency Fund Goal ---
            const emergencyCurrent = Number(getSafe(() => savingsInput.emergencySavings, 0)) || 0; // Corrected key
            // Use target from data if available, otherwise default to 3 months CORE expenses
            const emergencyGoalTargetExplicit = Number(getSafe(() => savingsInput.emergencyFundTarget, 0));
            const emergencyGoalTargetCalculated = totals.monthlyCoreExpenses > 0 ? totals.monthlyCoreExpenses * 3 : 0;
            // Prefer explicit target if valid (>0), else use calculated (>0), else target is 0
            const emergencyGoalTarget = (emergencyGoalTargetExplicit > 0) ? emergencyGoalTargetExplicit : (emergencyGoalTargetCalculated > 0 ? emergencyGoalTargetCalculated : 0);

            const emergencyProgressBar = document.getElementById('emergencyProgressBar');

            if (emergencyGoalTarget > 0 && emergencyGoalDisplay && emergencyProgressBar) {
                hasVisibleGoal = true;
                emergencyGoalDisplay.style.display = 'block';
                const progress = Math.min(100, Math.max(0, (emergencyCurrent / emergencyGoalTarget) * 100));
                emergencyProgressBar.style.width = `${progress}%`;
                emergencyProgressBar.textContent = `${progress.toFixed(0)}%`;
                const statusEl = emergencyGoalDisplay.querySelector('.goal-status');
                if (statusEl) statusEl.textContent = `Target: ${formatCurrency(emergencyGoalTarget)} (${formatPercentage(emergencyCurrent / emergencyGoalTarget, 0)} funded)`;
            } else if (emergencyGoalDisplay) {
                emergencyGoalDisplay.style.display = 'none'; // Hide if target is not valid or 0
            } else { console.warn("Emergency goal elements not found."); }


            // --- Upcoming Purchase Goal (Attempt to parse first one) ---
            const purchaseProgressBar = document.getElementById('purchaseProgressBar');
            const purchaseGoalNameEl = document.getElementById('purchaseGoalName');

            // Check if all necessary elements exist before attempting to parse/display purchase goal
            if (upcomingPurchaseString && purchaseGoalDisplay && purchaseProgressBar && purchaseGoalNameEl) {
                 // Look for pattern like: #1) Name, $Amount[, X months] - make months optional
                 // Made regex slightly more robust to handle spaces, commas, dollar signs better
                 const match = upcomingPurchaseString.match(/#\d+\)\s*(.*?),\s*\$?\s*([\d,.]+)(?:,\s*\d+\s*months?)?/i); // Added case-insensitive flag
                 console.log("Purchase goal regex match:", match);

                if (match && match[1] && match[2]) {
                    const goalName = match[1].trim();
                    const goalAmountStr = match[2].replace(/,/g, '');
                    const goalAmount = parseFloat(goalAmountStr);
                    // Use general savings for progress unless specific goal savings provided in data
                    const generalSavings = Number(getSafe(() => savingsInput.currentSavings, 0)) || 0; // Corrected key

                    if (goalName && !isNaN(goalAmount) && goalAmount > 0) {
                        hasVisibleGoal = true;
                        purchaseGoalDisplay.style.display = 'block';
                        purchaseGoalNameEl.textContent = goalName;
                        // Calculate progress using general savings balance towards this goal amount
                        const progress = Math.min(100, Math.max(0, (generalSavings / goalAmount) * 100));
                        purchaseProgressBar.style.width = `${progress}%`;
                        purchaseProgressBar.textContent = `${progress.toFixed(0)}%`;
                        const statusEl = purchaseGoalDisplay.querySelector('.goal-status');
                        if (statusEl) statusEl.textContent = `Target: ${formatCurrency(goalAmount)} (${formatCurrency(generalSavings)} saved)`;
                    } else {
                        console.warn("Purchase goal parsed but name or amount invalid:", { goalName, goalAmount });
                        purchaseGoalDisplay.style.display = 'none'; // Hide if parsing results in invalid goal
                    }
                } else {
                     console.log("Upcoming purchase string does not match expected format, displaying raw text:", upcomingPurchaseString);
                     // If parsing fails, display the raw text in the Financial Tools & Goals card instead
                     // This is already done by updateReportBasics, so just hide this progress bar section
                    purchaseGoalDisplay.style.display = 'none';
                }
            } else if (purchaseGoalDisplay) { // Hide if no string or elements
                purchaseGoalDisplay.style.display = 'none';
                 if (!purchaseGoalDisplay) console.warn("Purchase goal display elements not found.");
            }

            // Show 'No goals' message only if neither goal section is visible
            if (noGoalsMessage) {
                noGoalsMessage.style.display = hasVisibleGoal ? 'none' : 'block';
            } else { console.warn("No goals message element not found.");}
             console.log("Goals display UI updated.");
        } catch (e) {
            console.error("Error updating goals display UI:", e);
        }
    }

     function updateDebtsDisplay(data, totals) {
        console.log("--- updateDebtsDisplay FUNCTION ENTERED ---"); // Very first log inside {}

        try { // Wrap the main logic in try block
            console.log("--- updateDebtsDisplay START ---");
            console.log("  Received data object:", data);
            console.log("  Received totals object:", totals);

            const debts = getSafe(() => data.userInput?.debts, []); // Get debts array safely
            console.log("  Parsed debts array:", debts);
            console.log("  Is debts an array?", Array.isArray(debts));
            console.log("  Debts array length:", debts.length);


            const debtsTable = document.getElementById('debtsTable');
            if (!debtsTable) {
                console.error("Debt table element (#debtsTable) not found!");
                // Still attempt to update totals even if table is missing
                 // Update totals using the calculated totals object - ensure totals exist and are valid
                if (totals && typeof totals === 'object' && isFinite(totals.totalDebt) && isFinite(totals.totalMinPayments)) {
                     updateElementText('totalDebtBalance', totals.totalDebt, formatCurrency);
                     updateElementText('totalMinPayments', totals.totalMinPayments, formatCurrency);
                } else {
                     console.warn("Totals object invalid, skipping total debt display update.");
                     updateElementText('totalDebtBalance', 'N/A');
                     updateElementText('totalMinPayments', 'N/A');
                }
                console.log("--- updateDebtsDisplay END (Table not found) ---");
                return; // Exit function if table is missing
            }

            const debtsTableBody = debtsTable.getElementsByTagName('tbody')[0];
             if (!debtsTableBody) {
                 console.error("Debt table body element (tbody) not found inside #debtsTable!");
                 // Update totals even if tbody is missing
                 if (totals && typeof totals === 'object' && isFinite(totals.totalDebt) && isFinite(totals.totalMinPayments)) {
                     updateElementText('totalDebtBalance', totals.totalDebt, formatCurrency);
                     updateElementText('totalMinPayments', totals.totalMinPayments, formatCurrency);
                } else {
                     console.warn("Totals object invalid, skipping total debt display update.");
                     updateElementText('totalDebtBalance', 'N/A');
                     updateElementText('totalMinPayments', 'N/A');
                }
                 console.log("--- updateDebtsDisplay END (Tbody not found) ---");
                 return; // Exit function if tbody is missing
             }

            console.log("  Debt table body found.");
            debtsTableBody.innerHTML = ''; // Clear existing rows
            console.log("  Cleared existing table rows.");

            if (!Array.isArray(debts) || debts.length === 0) {
                console.log("  No debt data or debts array is not an array. Displaying 'No debt information'.");
                debtsTableBody.innerHTML = '<tr><td colspan="4" class="text-center text-gray-500 py-4">No debt information provided.</td></tr>';
            } else {
                console.log(`  Processing ${debts.length} debt items.`);
                debts.forEach((debt, index) => {
                    console.log(`    Processing debt item ${index}:`, debt);
                    // Inner try/catch already exists here for individual rows - keep it

                    try { // Existing inner try block
                        const row = debtsTableBody.insertRow();

                        // Use getSafe for potentially missing debt properties
                        const type = getSafe(() => debt.type, 'N/A');
                        const balance = getSafe(() => debt.balance, 0); // Use getSafe for balance with default 0
                        const minPayment = getSafe(() => debt.minPayment, 0); // Use getSafe for minPayment with default 0
                        const interestRate = getSafe(() => debt.interestRate, 0); // Default rate to 0 if missing

                        console.log(`      Values for row ${index}:`, { type, balance, minPayment, interestRate });
                        console.log(`      Formatted values:`, {
                             balance: formatCurrency(balance),
                             minPayment: formatCurrency(minPayment),
                             interestRate: (Number(interestRate)).toFixed(1) + '%'
                        });


                        // Correctly map data to the appropriate columns and add CSS classes
                        row.innerHTML = `
                            <td>${type}</td>                                          <!-- Column 1: Type -->
                            <td class="balance-col">${formatCurrency(balance)}</td>    <!-- Column 2: Balance -->
                            <td class="rate-col">${(Number(interestRate)).toFixed(1)}%</td>    <!-- Column 3: Rate -->
                            <td class="min-pmt-col">${formatCurrency(minPayment)}</td>    <!-- Column 4: Min Payment -->
                        `;
                         console.log(`      Row ${index} HTML set.`);
                    } catch (e) { // Existing inner catch block
                        console.error(`  Error adding debt row for item ${index}:`, debt, e);
                        // Add an error row if processing a specific debt item fails
                        const row = debtsTableBody.insertRow();
                         row.innerHTML = `<td colspan="4" class="text-center text-red-500">Error displaying data for this debt item.</td>`;
                    }
                });
                 console.log("  Finished processing debt items.");
            }

            // Update totals using the calculated totals object - ensure totals exist and are valid
            if (totals && typeof totals === 'object' && isFinite(totals.totalDebt) && isFinite(totals.totalMinPayments)) {
                console.log("  Updating total debt elements:", { totalDebt: totals.totalDebt, totalMinPayments: totals.totalMinPayments });
                 updateElementText('totalDebtBalance', totals.totalDebt, formatCurrency);
                 updateElementText('totalMinPayments', totals.totalMinPayments, formatCurrency);
            } else {
                 console.warn("  Totals object invalid or missing, skipping total debt display update.");
                 updateElementText('totalDebtBalance', 'N/A');
                 updateElementText('totalMinPayments', 'N/A');
            }
             console.log("--- updateDebtsDisplay END ---"); // Last log before function exits normally

        } catch (outerError) { // Outer catch block
            console.error("--- updateDebtsDisplay OUTER CATCH ERROR ---", outerError);
            // Optionally display a generic error message in the table body if it wasn't cleared
            if(debtsTableBody && debtsTableBody.innerHTML === '') {
                 debtsTableBody.innerHTML = '<tr><td colspan="4" class="text-center text-red-500 py-4">Error loading debt data. Check console.</td></tr>';
            } else if (debtsTableBody && debtsTableBody.innerHTML.includes('Loading debt data')) {
                // If still showing "Loading...", replace it
                 debtsTableBody.innerHTML = '<tr><td colspan="4" class="text-center text-red-500 py-4">Error loading debt data. Check console.</td></tr>';
            }
             // Update totals to N/A on error
             updateElementText('totalDebtBalance', 'N/A');
             updateElementText('totalMinPayments', 'N/A');
        }
        // Function implicitly ends here if no outer catch error, or returns above
         console.log("--- updateDebtsDisplay FUNCTION EXIT ---"); // Log right before the function truly exits
    }

    function renderCharts(data, totals) {
        console.log("--- renderCharts START ---");
        console.log("  Received data object for charts:", data);
        console.log("  Received totals object for charts:", totals);


        // Check if Plotly library is loaded
        if (typeof Plotly === 'undefined') {
            console.error("  Plotly library not found. Cannot render charts.");
            const incomeChartDiv = document.getElementById('incomeChart');
            const expenseChartDiv = document.getElementById('expenseChart');
            if(incomeChartDiv) incomeChartDiv.innerHTML = '<p class="text-red-600 text-center p-4">Error: Plotly library not loaded.</p>';
            if(expenseChartDiv) expenseChartDiv.innerHTML = '<p class="text-red-600 text-center p-4">Error: Plotly library not loaded.</p>';
            console.log("--- renderCharts END (Plotly not loaded) ---");
            return; // Exit function
        }
        console.log("  Plotly library found.");


        try {
            const incomeData = getSafe(() => data.userInput?.income, {});
            const expenseData = getSafe(() => data.userInput?.expenses, {});
            const totalMinPayments = Number(getSafe(() => totals?.totalMinPayments, 0)) || 0; // Get total min payments from totals, ensure number


            // --- Filter and prepare income labels/values ---
            const incomeLabels = [];
            const incomeValues = [];
            Object.entries(incomeData).forEach(([key, value]) => {
                const numValue = Number(getSafe(() => value, 0)); // Use getSafe for value with default 0
                if (numValue > 0 && isFinite(numValue)) {
                    let label = key.replace(/([A-Z])/g, ' $1').replace(/^./, c => c.toUpperCase());
                    // Customize common labels
                    if (key === 'mainJobIncome') label = 'Main Job';
                    if (key === 'secondJobIncome') label = 'Second Job'; // Corrected key
                    if (key === 'otherIncome') label = 'Other Income';

                    incomeLabels.push(label);
                    incomeValues.push(numValue);
                }
            });
            console.log("  Prepared income data for chart:", { labels: incomeLabels, values: incomeValues });

            // --- Filter and prepare expense labels/values ---
            const expenseLabels = [];
            const expenseValues = [];
            Object.entries(expenseData).forEach(([key, value]) => {
                const numValue = Number(getSafe(() => value, 0)); // Use getSafe for value with default 0
                if (numValue > 0 && isFinite(numValue)) {
                    let label = key.replace(/([A-Z])/g, ' $1').replace(/^./, c => c.toUpperCase());
                    // Customize common labels
                    if (key === 'groceriesessentials') label = 'Groceries/Essentials'; // Corrected key
                    if (key === 'taxes') label = 'Taxes'; // Assuming taxes from form are explicit taxes
                    if (key === 'housing') label = 'Housing';
                     if (key === 'transportation') label = 'Transportation';
                    if (key === 'utilities') label = 'Utilities';
                    if (key === 'insurance') label = 'Insurance';
                    if (key === 'medical') label = 'Medical';
                    if (key === 'care') label = 'Care'; // Childcare/Dependent Care?
                    if (key === 'subscriptions') label = 'Subscriptions';

                    expenseLabels.push(label);
                    expenseValues.push(numValue);
                }
            });

             // Explicitly add total minimum debt payments if > 0, assuming they are part of expenses
             // Check if 'Debt Payments' label already exists or if we should add a new category
             // A common category name might be "Debt Payments" or "Minimum Debt Payments"
             if (totalMinPayments > 0 && isFinite(totalMinPayments)) {
                 const debtLabel = 'Debt Payments';
                 // Check if any existing expense label is similar, maybe combine? Or add as new?
                 // For simplicity, let's add as a new distinct category
                 expenseLabels.push(debtLabel);
                 expenseValues.push(totalMinPayments);
                 console.log(`  Added Total Minimum Debt Payments (${totalMinPayments}) to expense data.`);
             } else {
                 console.log("  Total Minimum Debt Payments are zero or not finite, not adding to expense chart.");
             }

             console.log("  Prepared expense data for chart:", { labels: expenseLabels, values: expenseValues });


            const incomeChartDiv = document.getElementById('incomeChart');
            const expenseChartDiv = document.getElementById('expenseChart');

             console.log("  Found chart divs:", { incomeChartDiv: !!incomeChartDiv, expenseChartDiv: !!expenseChartDiv });

            // Common layout adjustments for Pie charts
          const commonPieLayout = {
    autosize: true,
    margin: { l: 40, r: 40, b: 80, t: 80 },   // extra space, increased bottom margin for legend
    showlegend: true,
    legend: {
        orientation: "h",
        yanchor: "top",
        y: -0.15,                              // legend below the chart
        xanchor: "center",
        x: 0.5
    },
    paper_bgcolor: "rgba(0,0,0,0)",
    plot_bgcolor: "rgba(0,0,0,0)",
    font: { family: "Inter, sans-serif", size: 12, color: "#374151" },
    hoverlabel: { font: { family: "Inter, sans-serif", size: 12 } }
};

             console.log("  Common Pie Layout:", commonPieLayout);

            // Plotly config
             const plotlyConfig = {
                 displaylogo: false,
                 responsive: true, // Ensure responsive is true in config
                 modeBarButtonsToRemove: ['sendDataToCloud', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale2d', 'resetScale2d', 'hoverClosestPie', 'toggleSpikelines', 'hoverCompareCartesian']
             };
             console.log("  Plotly Config:", plotlyConfig);


            // Income Chart (Pie)
            if (incomeChartDiv) {
                console.log("  Processing Income Chart.");
                Plotly.purge(incomeChartDiv); // Clear previous chart first
                if (incomeValues.length > 0) {
                    console.log("  Income data found, attempting to plot.");
                    const incomeTrace = [{
                        values: incomeValues,
                        labels: incomeLabels,
                        type: 'pie',
                        hole: .4,
                        hoverinfo: 'label+percent+value',
                        textinfo: 'percent',
                        texttemplate: '%{percent}',
                        textposition: 'inside',
                        textfont_size: 11,
                        marker: {
                            colors: ['#10b981', '#34d399', '#6ee7b7', '#a7f3d0', '#d1fae5'],
                            line: { color: '#ffffff', width: 1 }
                        },
                        domain: { x: [0, 1], y: [0, 1] } // Use domain to fill container
                    }];
                    console.log("  Income Trace:", incomeTrace);
                    Plotly.newPlot(incomeChartDiv, incomeTrace, { ...commonPieLayout, title: { text: 'Income Sources', y:0.98, font: { size: 14, family: 'EB Garamond, serif', color: '#111827' } } }, plotlyConfig)
                        .then(() => { console.log("  Income Chart plotted successfully."); })
                        .catch((plotErr) => { console.error("  Error during Income Plotly.newPlot:", plotErr); incomeChartDiv.innerHTML = `<p class="text-red-600 text-center p-4">Error plotting income chart:<br>${getSafe(() => plotErr.message, 'Unknown chart error')}</p>`; });

                } else {
                    console.log("  No income data to plot. Displaying message.");
                    incomeChartDiv.innerHTML = '<p class="text-center text-gray-500 pt-10">No income data to display.</p>';
                    // incomeChartDiv.innerHTML  = ''; // Keep the empty message div
                }
            } else { console.error("  Income chart div (#incomeChart) not found."); }


            // Expense Chart (Pie)
            if (expenseChartDiv) {
                 console.log("  Processing Expense Chart.");
                Plotly.purge(expenseChartDiv); // Clear previous chart
                if (expenseValues.length > 0) {
                    console.log("  Expense data found, attempting to plot.");
                    const expenseTrace = [{
                        values: expenseValues,
                        labels: expenseLabels,
                        type: 'pie',
                        hole: .4,
                        hoverinfo: 'label+percent+value',
                        textinfo: 'percent',
                        texttemplate: '%{percent}',
                        textposition: 'inside',
                        textfont_size: 11,
                        marker: {
                            colors: ['#ef4444', '#f87171', '#fca5a5', '#fecaca', '#fb923c', '#fdba74', '#fed7aa', '#ffedd5', '#d1d5db', '#9ca3af', '#a78bfa', '#c4b5fd'],
                            line: { color: '#ffffff', width: 1 }
                        },
                         domain: { x: [0, 1], y: [0, 1] } // Use domain to fill container
                    }];
                     console.log("  Expense Trace:", expenseTrace);
                    Plotly.newPlot(expenseChartDiv, expenseTrace, { ...commonPieLayout, title: { text: 'Expense Categories', y:0.98, font: { size: 14, family: 'EB Garamond, serif', color: '#111827' } } }, plotlyConfig)
                        .then(() => { console.log("  Expense Chart plotted successfully."); })
                        .catch((plotErr) => { console.error("  Error during Expense Plotly.newPlot:", plotErr); expenseChartDiv.innerHTML = `<p class="text-red-600 text-center p-4">Error plotting expense chart:<br>${getSafe(() => plotErr.message, 'Unknown chart error')}</p>`; });

                } else {
                    console.log("  No expense data to plot. Displaying message.");
                    expenseChartDiv.innerHTML = '<p class="text-center text-gray-500 pt-10">No expense data to display.</p>';
                     // expenseChartDiv.innerHTML = ''; // Keep the empty message div
                }
            } else { console.error("  Expense chart div (#expenseChart) not found."); }

             console.log("--- renderCharts END ---"); // Last log before function exits
        } catch (chartError) {
            console.error("--- renderCharts OUTER CATCH ERROR ---", chartError);
            // Display generic error in chart divs if a general error occurred above Plotly.newPlot
            const incomeChartDiv = document.getElementById('incomeChart');
            const expenseChartDiv = document.getElementById('expenseChart');
             if(incomeChartDiv) incomeChartDiv.innerHTML = `<p class="text-red-600 text-center p-4">Error loading chart.</p>`;
             if(expenseChartDiv) expenseChartDiv.innerHTML = `<p class-="text-red-600 text-center p-4">Error loading chart.</p>`;
            // Rethrow the error so it can be caught by the caller in requestAnimationFrame
            // throw new Error(`Chart rendering failed: ${getSafe(() => chartError.message, 'Unknown error')}`); // Don't re-throw, just log
        }
    }

    function updateUIDisplayFromAI(data) {
        console.log("Updating AI display UI...");
        try {
            const aiOutput            = getSafe(() => data.aiOutput, {});
            const analysisEl          = document.getElementById('aiAnalysis');
            const recommendationsList = document.getElementById('recommendationsList');
            const progressContentEl   = document.getElementById('progressContent');

            /* ---- AI analysis text ---- */
            // Using textContent first and then converting newlines for safety against unexpected HTML
            const rawAnalysis = getSafe(() => aiOutput.analysis, 'Analysis not available.');
            const formattedAnalysis = rawAnalysis
                .replace(/\\n/g, '\n')   // literal “\n” → newline
                .replace(/\n/g, '<br>'); // newline      → <br>
            if (analysisEl) updateElementHTML('aiAnalysis', formattedAnalysis);
             else { console.warn("AI analysis element not found."); }


            /* ---- Recommendations ---- */
            if (recommendationsList) {
                const rawRecs = getSafe(() => aiOutput.recommendations, '');
                const items = rawRecs
                    .split(/\r?\n/)
                    .map(t => t.trim())
                    .filter(Boolean);
                recommendationsList.innerHTML = items.length
                    ? items.map(txt => `<li>${txt}</li>`).join('')
                    : '<li class="text-gray-500">No recommendations available.</li>';
            } else { console.warn("Recommendations list element not found."); }

            /* ---- Progress history ---- */
            if (progressContentEl) {
                const rawProgress = getSafe(() => aiOutput.userProgressHistory, 'No progress history available.'); // Corrected key
                 const formattedProgress = rawProgress.replace(/\\n/g, '\n'); // literal “\n” → newline for modal pre-wrap
                progressContentEl.textContent = formattedProgress; // Use textContent for pre
            } else { console.warn("Progress content element not found."); }
            console.log("AI display UI updated.");
        } catch (e) {
            console.error("Error updating AI display UI:", e);
        }
    }

    // --- Chat Functionality ---
    // --- Chat Functionality ---
    function initializeChat() { // Renamed from updateUIBasedOnAccess temporarily for clarity
        console.log("--- initializeChat START ---");

        // Cache chat elements here if not already done
        chatInterfaceCardElement = chatInterfaceCardElement || document.getElementById('chatInterfaceCard');
        const chatInput = document.getElementById('chatInput');
        const chatSendButton = document.getElementById('chatSendButton');
        const chatHistory = document.getElementById('chatHistory');

        if (!chatInput || !chatSendButton || !chatHistory || !chatInterfaceCardElement) {
            console.error("One or more Chat UI elements not found! Aborting chat initialization.");
            if (chatInterfaceCardElement) chatInterfaceCardElement.style.display = 'none';
            enableChatInput(false);
            setChatStatus("Chat UI elements missing", false);
            return;
        }

        // SIMPLIFIED CHECK: Ensure Supabase client exists and fetch is available
        const isReadyForChat = supabase && typeof fetch === 'function';
        console.log("Is environment ready for chat (Supabase client + fetch)?", isReadyForChat);

        // Determine if chat CAN be enabled based on user/usage (from global state)
        const canEnableChat = currentUserId && initialUsageInfo && !initialUsageInfo.error && initialUsageInfo.usage < initialUsageInfo.limit;
        console.log("Can chat be enabled based on user/usage state?", canEnableChat);

        if (isReadyForChat && canEnableChat) {
            chatInterfaceCardElement.style.display = 'block'; // Show the card
            enableChatInput(true); // Enable input fields
            setChatStatus("Ready to chat", false); // Set status

            // Clear and rebuild chat history display based on chatMessages array
            chatHistory.innerHTML = '';
            if (chatMessages.length === 0) {
                // Add initial assistant message only if chat history is empty
                const initialMsgContent = "Hello! Ask me anything about the financial data shown on your dashboard.";
                addMessageToChat("Assistant", initialMsgContent, false);
                // Don't push initial greeting to history array unless you want it saved/resent
                // chatMessages.push({ role: "assistant", content: initialMsgContent });
            } else {
                // Restore previous messages from history array
                chatMessages.forEach(msg => addMessageToChat(msg.role.charAt(0).toUpperCase() + msg.role.slice(1), msg.content));
            }
            // Scroll to the latest message after loading history
            chatHistory.scrollTop = chatHistory.scrollHeight;

            // Ensure listeners are attached only once or re-attached correctly
            chatSendButton.removeEventListener('click', handleChatSubmit);
            chatInput.removeEventListener('keydown', handleChatEnterKey);
            chatInput.removeEventListener('input', autoGrowTextarea);

            chatSendButton.addEventListener('click', handleChatSubmit);
            chatInput.addEventListener('keydown', handleChatEnterKey);
            chatInput.addEventListener('input', autoGrowTextarea);
            autoGrowTextarea({ target: chatInput }); // Adjust height initially

            console.log("Chat UI initialized and enabled.");

        } else {
            // Chat cannot be enabled - figure out why and set status
            console.log("Chat setup skipped or disabled. Reasons:", {
                 isReadyForChat,
                 canEnableChat,
                 hasUserId: !!currentUserId,
                 hasUsageInfo: !!initialUsageInfo,
                 usageInfoError: initialUsageInfo?.error,
                 limitReached: initialUsageInfo && initialUsageInfo.usage >= initialUsageInfo.limit
            });
            if (chatInterfaceCardElement) chatInterfaceCardElement.style.display = 'none'; // Ensure hidden
            enableChatInput(false);

            // Set appropriate status message
            if (!initialUsageInfo) {
                 setChatStatus("Loading access info...", true);
            } else if (initialUsageInfo.error) {
                 setChatStatus("Chat unavailable - Access Error", false);
            } else if (!isReadyForChat) {
                 setChatStatus("Chat unavailable - Service Offline", false);
            } else if (!currentUserId) {
                 setChatStatus("Chat unavailable - Authentication needed", false);
            } else if (initialUsageInfo.usage >= initialUsageInfo.limit) {
                 setChatStatus("Weekly token limit reached", false);
                 if (chatInterfaceCardElement) chatInterfaceCardElement.style.display = 'block'; // Show card but disabled
            } else {
                  setChatStatus("Chat unavailable", false); // Generic fallback
            }
        }
        console.log("--- initializeChat END ---");
    }

    function handleChatEnterKey(event) {
        if (event.key === 'Enter' && !event.shiftKey) { // Send on Enter, allow Shift+Enter for newline
            event.preventDefault(); // Prevent default newline insertion
            handleChatSubmit(); // Trigger send action
        }
    }

    function autoGrowTextarea(event) {
        const textarea = event.target;
        textarea.style.height = 'auto'; // Temporarily shrink to base height
        // Calculate the desired height: at least 88px, based on scrollHeight, max 120px
        const minHeight = 88; // Define minimum height here
        const maxHeight = 120; // Define maximum height here (matches CSS)
        textarea.style.height = Math.min(Math.max(textarea.scrollHeight, minHeight), maxHeight) + 'px'; // <-- MODIFIED CALCULATION
    }

    function enableChatInput(enabled) {
        const chatInput = document.getElementById('chatInput');
        const chatSendButton = document.getElementById('chatSendButton');
        if (chatInput && chatSendButton) {
            chatInput.disabled = !enabled;
            chatSendButton.disabled = !enabled;
            chatInput.placeholder = enabled ? "Ask about your finances..." : "Chat unavailable";
            // Adjust visual state
            chatInput.style.opacity = enabled ? '1' : '0.6';
            chatSendButton.style.opacity = enabled ? '1' : '0.6';
            chatSendButton.style.cursor = enabled ? 'pointer' : 'not-allowed';
             if (!enabled) chatInput.value = ''; // Clear input if disabling
        } else {
            console.warn("Could not find chat input or send button to enable/disable.");
        }
    }

    function addMessageToChat(sender, message, isError = false) {
        const chatHistory = document.getElementById('chatHistory');
        if (!chatHistory) {
            console.error("Chat history element not found.");
            return;
        }

        const messageContainer = document.createElement('div');
        // Sanitize sender string for class name just in case
        const senderClass = sender ? sender.toLowerCase().replace(/[^a-z0-9]/g, '') : 'system'; // Default to system
        messageContainer.classList.add('chat-message', senderClass);

        const bubble = document.createElement('div');
        bubble.classList.add('message-bubble');

        if (isError) { // Style error messages distinctly within the bubble
            bubble.style.backgroundColor = '#fee2e2'; // Tailwind red-100
            bubble.style.color = '#b91c1c'; // Tailwind red-700
            bubble.style.borderColor = '#fca5a5'; // Tailwind red-300
            bubble.style.borderWidth = '1px';
            bubble.style.borderStyle = 'solid';
        }

        // Basic Markdown-like link handling: [text](url) -> <a href="url">text</a>
        // Basic bold handling: **text** -> <strong>text**
        // Convert newlines to <br> for HTML display
         // Basic sanitization: replace < and > to prevent simple injection
        const safeMessage = message.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        const formattedMessage = safeMessage
            .replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer" class="text-indigo-600 hover:underline font-medium">$1</a>')
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Handle bold
            .replace(/\n/g, '<br>'); // Convert newlines

        bubble.innerHTML = formattedMessage; // Assign the processed HTML
        messageContainer.appendChild(bubble);
        chatHistory.appendChild(messageContainer);

        // Scroll to the bottom smoothly
        chatHistory.scrollTo({ top: chatHistory.scrollHeight, behavior: 'smooth' });
    }

    function setChatStatus(message, isLoading = false) {
        const chatStatus = document.getElementById('chatStatusContainer'); // Use the container ID

        if (!chatStatus) {
            console.warn("Chat status container not found.");
            return;
        }

        const tierDisplay = document.getElementById('chatTierDisplay');
        const modelDisplay = document.getElementById('chatModelDisplay');
        const usageDisplay = document.getElementById('chatUsageDisplay');
        const thinkingIndicator = document.getElementById('chatThinkingIndicator');


        if (!tierDisplay || !modelDisplay || !usageDisplay || !thinkingIndicator) {
            console.warn("Chat status elements (tier, model, usage, indicator) not found.");
             // Fallback: just show the message if possible (this might not be ideal with the current HTML)
             // For the current HTML, we must manage the indicator vs static text.
             if(thinkingIndicator) thinkingIndicator.style.display = isLoading ? 'inline-block' : 'none';
             console.log("Set chat status (basic fallback): ", message, isLoading ? "(Loading)" : "(Idle)");
            return;
        }

        // Hide/show static text vs thinking indicator
        tierDisplay.style.display = isLoading ? 'none' : 'inline';
        modelDisplay.style.display = isLoading ? 'none' : 'inline';
        usageDisplay.style.display = isLoading ? 'none' : 'inline';
        thinkingIndicator.style.display = isLoading ? 'inline-block' : 'none';


        // Note: The actual text for tier, model, usage is updated by updateUIBasedOnAccess.
        // The message parameter here is mainly for setting the state (loading/ready/error)
        console.log("Set chat status: ", message, isLoading ? "(Loading)" : "(Idle)");

    }

   async function sendToBackendChatFunction() {
        console.log("Attempting to send chat message to backend...");
        // Ensure dashboard data is loaded before proceeding
        if (!dashboardData?.userInput) {
            addMessageToChat("System", "Error: Financial data seems incomplete. Cannot process chat request.", true);
            setChatStatus("Error: Data missing", false);
            return;
        }
        // Ensure Supabase client is ready and we have a user ID/tier
         if (!supabase || typeof supabase.functions?.invoke !== 'function' || !currentUserId || !effectiveTier || !initialUsageInfo || initialUsageInfo.error || initialUsageInfo.usage >= initialUsageInfo.limit) {
             console.error("Chat prerequisites not met:", { supabaseReady: !!supabase, hasInvoke: typeof supabase?.functions?.invoke === 'function', hasUserId: !!currentUserId, hasTier: !!effectiveTier, hasUsageInfo: !!initialUsageInfo, usageError: initialUsageInfo?.error, limitReached: initialUsageInfo?.usage >= initialUsageInfo?.limit });
             addMessageToChat("System", "Error: Chat service is not available. Please check access or refresh the page.", true);
             setChatStatus("Chat unavailable", false);
             enableChatInput(false); // Ensure disabled
             return;
         }


        setChatStatus("Thinking...", true); // Show loading indicator
        enableChatInput(false); // Disable input while processing

        // --- Prepare Context String (More Comprehensive) ---
        let financialContext = `User: ${getSafe(() => dashboardData.userInput.personalInfo.userName)}, Age: ${getSafe(() => dashboardData.userInput.personalInfo.age)}\n`;
        // Use cached totals/ratios if they exist, otherwise recalculate (safer to recalculate)
        try {
             const totals = calculateTotals(dashboardData); // Recalculate for fresh context
             const ratios = calculateRatios(dashboardData, totals); // Calculate ratios for context
             financialContext += `Monthly Totals: Income: ${formatCurrency(totals.totalIncome)}, Expenses: ${formatCurrency(totals.totalExpenses)}, Net Flow: ${formatCurrency(totals.netFlow)}\n`;
             financialContext += `Savings Balances: Emergency: ${formatCurrency(getSafe(()=>dashboardData.userInput.savings.emergencySavings))}, General: ${formatCurrency(getSafe(()=>dashboardData.userInput.savings.currentSavings))}, Retirement: ${formatCurrency(getSafe(()=>dashboardData.userInput.savings.retirementFund))}\n`; // Corrected keys
             financialContext += `Debt: Total Balance: ${formatCurrency(totals.totalDebt)}, Total Min Payments: ${formatCurrency(totals.totalMinPayments)}\n`;
             financialContext += `Ratios: Savings Rate: ${formatPercentage(ratios.savingsRate, 1)}, Emergency Coverage: ${ratios.emergencyCoverage === Infinity ? 'N/A' : ratios.emergencyCoverage.toFixed(1)} months, DTI: ${formatPercentage(ratios.dtiRatio, 1)}\n`;

             if (dashboardData.userInput.debts && dashboardData.userInput.debts.length > 0) {
                 financialContext += "Debts Breakdown:\n";
                 dashboardData.userInput.debts.forEach(d => {
                     financialContext += ` - ${getSafe(() => d.type, 'Debt')}: Bal ${formatCurrency(getSafe(() => d.balance))}, Rate ${getSafe(() => d.interestRate, 0)}%, Min Pmt ${formatCurrency(getSafe(() => d.minPayment))}\n`;
                 });
             }
        } catch (e) {
             console.error("Error generating financial context for chat:", e);
             financialContext += "Error generating detailed financial context.\n";
        }


        const priorAnalysis = getSafe(() => dashboardData.aiOutput.analysis);
        const priorRecs = getSafe(() => dashboardData.aiOutput.recommendations);

        // Add prior analysis/recs if they are not just placeholders
        if (priorAnalysis && !/not available|to be determined/i.test(priorAnalysis)) financialContext += `Prior Analysis Summary: ${priorAnalysis.substring(0, 500)}...\n`; // Limit length
        if (priorRecs && !/not available|to be determined/i.test(priorRecs)) financialContext += `Prior Recommendations Summary: ${priorRecs.substring(0, 500)}...\n`; // Limit length


        // --- Construct messages payload ---
        const maxHistory = 6; // Keep recent messages + system message
        // Ensure recentMessages are actual message objects with role and content
        const recentMessages = chatMessages.slice(-maxHistory).filter(msg => msg && msg.role && msg.content);
        const systemMessage = {
            role: "system",
            content: `You are SmartWealth AI, a helpful financial assistant. Use the provided financial context ONLY to answer the user's questions concisely and directly related to their financial situation. Do not provide generic financial advice unless asked. Financial Context:\n${financialContext}`
        };
        const messagesForBackend = [systemMessage, ...recentMessages];

        const functionName = 'smooth-function'; // Ensure this matches your deployed Supabase function name

        console.log(`Invoking Supabase function '${functionName}' for user ${currentUserId}, tier ${effectiveTier}.`);
        console.log("Messages sent to backend:", messagesForBackend);


        try {
            // Invoke the Supabase Function using fetch with proper headers
            const response = await fetch(`${SUPABASE_URL}/functions/v1/${functionName}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`, // Use ANON key for client-side function invocation
                    'x-user-id': currentUserId, // Crucial header
                    'x-user-tier': effectiveTier // Crucial header
                },
                body: JSON.stringify({
                    messages: messagesForBackend,
                    // model: CHAT_MODEL // Backend determines the model, don't send from client
                })
            }); // <<< fetch ends here

            // --- ADDED RESPONSE HANDLING ---
            if (!response.ok) {
                // Try to parse error from backend, provide fallback message
                let errorMsg = `Request failed with status ${response.status}`;
                try {
                    // Use .json() to get the error message sent from the Edge Function
                    const errorData = await response.json();
                    errorMsg = errorData?.error || errorMsg; // Use backend error message if available
                } catch (e) {
                    // If parsing error body fails, use the status text
                    errorMsg = response.statusText || errorMsg;
                    console.warn("Could not parse error response body:", e);
                }
                // Log the detailed error before throwing
                console.error(`Backend returned error: ${response.status} - ${errorMsg}`);
                throw new Error(errorMsg); // Throw error to be caught below
            }

            // Parse the successful response
            const result = await response.json();

            // Check the expected response structure from 'smooth-function'
            if (result && result.assistantResponse && typeof result.assistantResponse.content === 'string') {
                addMessageToChat("Assistant", result.assistantResponse.content);
                // Add the assistant response to the history array as well
                chatMessages.push({ role: "assistant", content: result.assistantResponse.content });
                setChatStatus("", false); // Clear "Thinking..." status

                // Re-fetch initial usage info after a successful chat message
                // This updates the frontend usage display. Use a slight delay.
                setTimeout(fetchInitialUsage, 1000); // Add small delay

            } else {
                // Handle cases where the response is OK (200) but the format isn't right
                console.error("Invalid response format from backend:", result);
                throw new Error("Received an invalid response format from the chat service.");
            }
            // --- END OF ADDED RESPONSE HANDLING ---

        } catch (err) { // Catch errors from fetch() or the handling block above
            console.error("Chat function invocation failed:", err);
            // Display the error message from the caught error
            addMessageToChat("System", "Error calling chat service: " + (err.message || "Unknown error"), true);
            setChatStatus("Error sending message", false);
        } finally {
            enableChatInput(true); // Re-enable input
            console.log("Chat request finished.");
        }
    }
    // --- Event Handlers & Button Initializers ---
    function handleChatSubmit() {
        const chatInput = document.getElementById('chatInput');
        if (!chatInput) return; // Safety check

        const userMessage = chatInput.value.trim();
        if (!userMessage || chatInput.disabled) return; // Don't send empty messages or if disabled

        addMessageToChat("User", userMessage);
        chatMessages.push({ role: "user", content: userMessage }); // Add user message to history array
        chatInput.value = ''; // Clear input field
        chatInput.style.height = 'auto'; // Reset height after send
        // chatInput.style.height = '44px'; // Removed hardcoded reset, autoGrow listener handles it

        sendToBackendChatFunction(); // Call backend function
    }


    function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) {
             console.log("File upload cancelled.");
             // If no file was selected, and no data was previously loaded,
             // ensure the initial prompt/message is still shown.
             if (!dashboardData || Object.keys(getSafe(() => dashboardData.userInput, {})).length === 0) { // More robust check for empty data
                 // Use a small timeout to avoid race conditions with other init logic
                 setTimeout(() => showInitialPromptOrMessage(), 50);
             } else {
                  // If data was loaded, just hide spinner if it was somehow visible
                 if (loadingSpinner) loadingSpinner.style.display = 'none';
             }
             return; // No file selected
        }

        console.log(`File selected: ${file.name}, Type: ${file.type}, Size: ${file.size} bytes`);

        // Ensure it's a JSON file (basic check)
        if (file.type !== 'application/json' && !file.name.toLowerCase().endsWith('.json')) {
            handleError("Invalid file type", new Error("Please upload a valid JSON file (.json)."));
            event.target.value = null; // Reset file input
             // Ensure previous state is restored or error is shown
            return;
        }

        // Show loading, hide others immediately
        hideAllMainContentAreas(); // Hide everything first
        if (loadingSpinner) loadingSpinner.style.display = 'flex'; // Show spinner

        const reader = new FileReader();
        reader.onload = function(e) {
            let uploadedData = null;
            try {
                uploadedData = JSON.parse(e.target.result);
                // Basic validation of uploaded structure - ensure userInput exists
                if (typeof uploadedData !== 'object' || uploadedData === null || !uploadedData.userInput || !uploadedData.userInput.personalInfo || Object.keys(getSafe(() => uploadedData.userInput.personalInfo, {})).length === 0) {
                    throw new Error("Invalid file content. Expected a JSON object with 'userInput' and 'personalInfo'.");
                }

                console.log("Successfully parsed uploaded JSON file.");

                // --- START MODIFIED LOGIC: Restore User ID and Tier from file, then fetch usage ---
                console.log("Checking uploaded file for user identity metadata...");
                // Prioritize explicit userId/tier from file metadata if available
                const fileUserId = getSafe(() => uploadedData.metadata?.userId, null);
                const fileUserTier = getSafe(() => uploadedData.metadata?.tier, null);

                if (fileUserId && fileUserId !== 'N/A' && fileUserId.length > 0) {
                    if(fileUserId !== currentUserId) console.warn(`Overriding current user ID (${currentUserId}) with ID from file metadata: ${fileUserId}`);
                    currentUserId = fileUserId;
                } else {
                    console.warn("Uploaded file metadata has no valid userId. Keeping current context:", currentUserId);
                }

                if (fileUserTier && ['basic', 'pro'].includes(fileUserTier)) {
                     if(fileUserTier !== effectiveTier) console.warn(`Overriding current tier (${effectiveTier}) with tier from file metadata: ${fileUserTier}`);
                     effectiveTier = fileUserTier;
                } else {
                     console.warn("Uploaded file metadata has no valid tier. Keeping current context or defaulting to basic:", effectiveTier);
                }

                 // Note: We do NOT restore initialUsageInfo from the file here.
                 // We will fetch the *current* usage from the DB next.
                // --- END MODIFIED LOGIC ---


                dashboardData = uploadedData; // Assign the parsed data to the global dashboardData

                // Restore chat history from the file
                if (Array.isArray(getSafe(() => uploadedData.chatHistory))) { // Use getSafe for chatHistory check
                    chatMessages = uploadedData.chatHistory.filter(msg => msg && msg.role && msg.content); // Filter valid messages
                    console.log(`Restored ${chatMessages.length} chat messages from file.`);
                } else {
                    chatMessages = []; // Clear chat history if not found or invalid
                    console.log("No valid chat history found in file, starting with empty chat.");
                }

                // Add source metadata if missing
                 dashboardData.metadata = dashboardData.metadata || {};
                 dashboardData.metadata.source = 'manual_upload';


                // Process and display the financial data and AI output from the file
                processAndDisplayData(dashboardData); // This updates the main dashboard UI and hides spinner


                // *** IMPORTANT: NOW FETCH THE CURRENT USAGE FROM THE DATABASE ***
                // This will update initialUsageInfo and trigger updateUIBasedOnAccess -> initializeChat
                console.log("File processed, fetching current usage from database based on determined user ID...");
                fetchInitialUsage();


            } catch (error) {
                console.error("Error processing uploaded file:", error);
                // Provide more specific error message if parsing failed vs structure validation failed
                const userMessage = error.message.includes("JSON.parse") ? "File is not valid JSON." : error.message;
                handleError(`Error loading file: ${userMessage}`, error);
                dashboardData = {}; // Reset data on error
                chatMessages = []; // Clear chat history on error
                 // Keep current user info from URL/initial fetch if available.
                 updateUIBasedOnAccess(); // Update chat status based on whatever user info is currently set
            } finally {
                // Reset file input regardless of success/failure to allow re-uploading the same file
                event.target.value = null;
                // Spinner hiding is handled by processAndDisplayData or handleError
                 // fetchInitialUsage() called above will trigger the final updateUIBasedOnAccess call
            }
        };
        reader.onerror = function(e) {
            console.error("FileReader error:", e);
            handleError("Error reading file", e.target.error || new Error("Unknown FileReader error"));
            dashboardData = {}; // Reset data
            chatMessages = []; // Clear chat history
            event.target.value = null; // Reset file input
            if (loadingSpinner) loadingSpinner.style.display = 'none'; // Ensure spinner hides on read error
             // If file reading fails, keep current user info from URL
             updateUIBasedOnAccess(); // Update chat status based on whatever user info is currently set
        };
        reader.readAsText(file); // Read the file as text
    }

    // --- Local Download Handler ---
     function handleLocalDownload() {
         console.log("Initiating local download...");
         const dataToSave = getDataForSave(); // Use the helper function

         if (!dataToSave) {
             alert("No data to download.");
             console.warn("Attempted local download with no dashboard data.");
             return;
         }

         try {
             const dataStr = JSON.stringify(dataToSave, null, 2); // Pretty-print JSON
             const blob = new Blob([dataStr], { type: 'application/json' });
             const url = URL.createObjectURL(blob);

             const a = document.createElement('a');
             a.href = url;
             // Suggest a filename including user name and date
             const userName = getSafe(() => dataToSave.userInput.personalInfo.userName, 'Report').replace(/\s+/g, '_');
             const date = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
             a.download = `${userName}_PSR_${date}.json`;

             // Append to body, click, and remove
             document.body.appendChild(a);
             a.click();
             document.body.removeChild(a);

             URL.revokeObjectURL(url); // Clean up the object URL

             console.log("Local download initiated successfully.");
             setChatStatus("Report downloaded locally.", false); // Update status
             addMessageToChat("System", "Report downloaded locally.", false); // Add confirmation to chat

         } catch (e) {
             console.error("Error during local download:", e);
             setChatStatus("Download failed.", false); // Update status
             alert("Failed to download report: " + e.message);
              addMessageToChat("System", "Failed to download report locally.", true); // Add error to chat
         }
     }


    // --- Google API Loading and Initialization ---
    // Load GIS (for authentication) and Gapi (for API calls) libraries
    // These are triggered by onload in the script tags.

    // Handle Gapi library load (triggered by the script tag)
    function handleGapiLoad() {
        console.log("Gapi library loaded. Loading 'client' module...");
        // Load the core client library, which is necessary before using gapi.client
        if (typeof gapi !== 'undefined') {
             gapi.load('client', () => {
                 console.log("Gapi 'client' module loaded and ready.");
                 // At this point, gapi.client should be available.
                 // The token setting and Drive API load happen in handleGoogleTokenResponse
                 // after a successful sign-in.
             });
        } else {
             console.error("Gapi object not found when handleGapiLoad called.");
              handleError("Google API Load Failed", new Error("Gapi library did not load."));
        }
    }

       // Initialize GIS (Google Identity Services) - Triggered by the GIS script tag onload
    function initializeGIS() {
        console.log("GIS library loaded. Initializing token client...");
        // Use a short delay to potentially give the library a moment if needed, though onload should mean ready
         setTimeout(() => { // Adding a small delay for resilience
             if (typeof google === 'undefined' || typeof google.accounts === 'undefined' || typeof google.accounts.oauth2 === 'undefined') {
                  console.error("GIS library not available after load timeout.");
                  console.warn("Google Identity Services library not available. Google Drive features disabled.");
                  // Explicitly hide buttons if GIS failed to load, show sign-in is pointless
                  updateDriveButtonVisibility(false); // Hide drive buttons
                  if (googleSignInButton) googleSignInButton.style.display = 'none'; // Hide generic sign in button
                  if (promptGoogleLoadButton) promptGoogleLoadButton.style.display = 'none'; // Hide prompt button
                  setChatStatus("Google sign-in setup failed.", false);
                  return; // Exit function if library isn't available
             }

             try {
                 // Initialize the Google Identity Services token client
                 // The callback handles success and 'interaction_required' responses.
                 // The error_callback handles other issues like popup blocked or invalid requests.
                 googleTokenClient = google.accounts.oauth2.initTokenClient({
                     client_id: GOOGLE_CLIENT_ID, // Should be your correct Client ID constant
                     scope: GOOGLE_SCOPES,
                     callback: handleGoogleTokenResponse, // <-- Success and 'interaction_required' responses go here
                     error_callback: (error) => { // <-- Other errors go here (e.g. popup blocked, invalid_request, etc.)
                         console.error("GIS initTokenClient error:", error);
                         // Handle errors that prevent the callback from even being called, like popup blockers.
                         // 'immediate_failed' from prompt: 'none' might also end up here.
                          if (error.type === 'popup_closed' || error.error === 'popup_closed_by_user') {
                              console.log("Google Sign-In popup closed by user.");
                              setChatStatus("Sign-in cancelled", false);
                          } else if (error.error === 'immediate_failed') {
                              // This typically comes from the silent prompt: 'none' attempt failing outright
                              console.log("Silent Google Sign-In failed outright (immediate_failed). User needs to click the button.");
                              setChatStatus("Sign-in needed", false); // Prompt user to click the button
                          } else {
                              // Handle other unexpected GIS errors more seriously, might need user info for handleError
                              console.error("Other unexpected GIS error:", error); // Log the full error object
                              // Pass the error to the central handler if it's not a known silent failure/cancellation
                              handleError("Google Sign-In Process Error", new Error(`GIS error during request: ${error.message || error.error || 'Unknown error'}`));
                          }
                          // In case of any error in the error_callback, ensure buttons reflect not signed in state
                          updateDriveButtonVisibility(!!googleAccessToken); // Should evaluate to false here
                     }
                 });
                 console.log("GIS token client initialized.");

                 // Attach click listeners to the buttons that should initiate the Google flow
                 // These listeners will check if signed in, and if not, call googleTokenClient.requestAccessToken()

                 // Main header buttons
                 if (loadFromDriveButton) {
                     loadFromDriveButton.addEventListener('click', handleLoadFromDriveClick);
                     console.log("Load from Drive button listener added.");
                 } else { console.warn("Load from Drive button not found."); }

                 if (saveToDriveButton) {
                     saveToDriveButton.addEventListener('click', handleSaveToDriveClick);
                     console.log("Save to Drive button listener added.");
                 } else { console.warn("Save to Drive button not found."); }

                 // Button in the initial prompt
                 if (promptGoogleLoadButton) {
                     promptGoogleLoadButton.addEventListener('click', handleLoadFromDriveClick); // Make the prompt button trigger the same load logic
                     console.log("Prompt Google Load button listener added.");
                 } else { console.warn("Prompt Google Load button not found."); }

                 // Sign Out button (optional, usually available when signed in)
                 if (googleSignOutButton) {
                      googleSignOutButton.addEventListener('click', handleGoogleSignOut);
                      console.log("Sign Out button listener added.");
                 } else { console.warn("Sign Out button not found."); }


                 // --- Attempt silent re-authentication on page load ---
                 // This should be called *after* the googleTokenClient is initialized.
                 // It checks if the user has a valid, recent session and attempts to get an access token silently.
                 // If successful, handleGoogleTokenResponse is called with the token.
                 // If not successful ('immediate_failed' error, or 'interaction_required' etc.), the appropriate callback path handles it.
                 if (googleTokenClient) { // Ensure the client object exists before calling its method
                      console.log("Attempting silent Google re-authentication...");
                      // Use prompt: 'none' for a silent check.
                      // This will NOT show a popup if no session exists, but will trigger handleGoogleTokenResponse
                      // with error='interaction_required' or 'access_denied' if necessary.
                      googleTokenClient.requestAccessToken({ prompt: 'none' });
                      // The response (success or interaction_required/access_denied) goes to handleGoogleTokenResponse.
                      // Other errors go to the error_callback defined above.
                 } else {
                     console.warn("Google Token client not available to attempt silent re-auth. Skipping silent check.");
                 }
                 // --- END Silent Re-auth ---


                  // Explicitly update button visibility here once GIS is initially ready.
                  // At this point, googleAccessToken is likely null (unless a token was cached somehow very early),
                  // so this will typically show the sign-in button on the prompt screen by default.
                  // The result of the silent re-auth attempt above will then update the UI via handleGoogleTokenResponse or the error_callback.
                  updateDriveButtonVisibility(!!googleAccessToken); // Show/hide based on initial token state


             } catch (e) { // Catch errors during the GIS initialization itself (initTokenClient call fails)
                  console.error("Error initializing GIS token client:", e);
                  handleError("Google Sign-In Setup Failed", e); // Report the error using the central handler
             }
         }, 100); // Add a small delay (100ms) before init as a precaution

    }


    // Handle the response from the Google Token Client (Authorization Response)
    // This function is called by the Google GIS library after:
    // 1. A successful interactive sign-in (tokenResponse contains access_token).
    // 2. A successful silent re-authentication (tokenResponse contains access_token).
    // 3. A failed silent re-authentication where interaction is required (tokenResponse contains error: 'interaction_required').
    // 4. User denies permissions during interactive flow (tokenResponse contains error: 'access_denied').
    // 5. User closes the popup (tokenResponse contains error: 'popup_closed_by_user').
    function handleGoogleTokenResponse(tokenResponse) {
        console.log("Google token response received:", tokenResponse);
        // IMPORTANT: Do NOT call hideAllMainContentAreas() here.
        // This function should react to auth result, not hide the main dashboard content.
        // Hiding/showing main content is managed by the initial load logic and processAndDisplayData.

        try { // Added try...catch inside handleGoogleTokenResponse
            // Check if the response contains a valid access token (SUCCESS PATH)
            if (tokenResponse && tokenResponse.access_token) {
                console.log("Google token response successful. Access token obtained.");
                googleAccessToken = tokenResponse.access_token; // Store the token globally
                console.log("Access Token obtained (length:", googleAccessToken.length, ")."); // Log length, not full token for security

                // Inject the obtained token into the gapi.client library for making API calls
                // Check if gapi.client is available and has setToken method
                if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined' && typeof gapi.client.setToken === 'function') {
                    gapi.client.setToken({ access_token: googleAccessToken });
                    console.log("Token set in gapi.client.");

                    // Now that we have a token and it's set in gapi.client, load the Drive API library.
                    // gapi.client.load uses promises and handles idempotency (safe to call multiple times).
                     gapi.client.load('drive', 'v3')
                        .then(() => {
                            console.log("Google Drive API v3 loaded successfully after sign-in.");
                            // The Drive API (gapi.client.drive) is now ready to use.
                            // Update button visibility to show Drive-related buttons (Load/Save), hide sign-in.
                            updateDriveButtonVisibility(true);
                            // Fetch user info for display (e.g., "Signed in as...")
                            fetchGoogleUserInfo();

                            // --- Determine what to do after successful sign-in ---
                            // If dashboard data is NOT already loaded (e.g., from URL params or local file),
                            // attempt to automatically load the user's file from Drive.
                            // Check if dashboardData has valid userInput with personalInfo
                             const isDataCurrentlyLoaded = dashboardData && dashboardData.userInput && dashboardData.userInput.personalInfo && Object.keys(getSafe(() => dashboardData.userInput.personalInfo, {})).length > 0;

                             if (!isDataCurrentlyLoaded) {
                                 console.log("No data loaded from URL/Local. Attempting auto-load from Drive after sign-in.");
                                 // Show spinner while loading from Drive
                                 hideAllMainContentAreas(); // Hide existing content before loading from Drive
                                 if (loadingSpinner) loadingSpinner.style.display = 'flex';
                                 setChatStatus("Loading from Drive...", true);
                                 // Call the function to initiate loading from Drive.
                                 // performDriveLoadOrSignIn already checks signed-in status.
                                 // It might be called here *after* sign-in. Let's call the function
                                 // that executes the load operation itself, as sign-in is confirmed.
                                 performDriveLoadOperation(); // Function that does the actual Drive list/load

                             } else {
                                 // If data was already loaded (e.g., from URL params),
                                 // just indicate signed-in status. The main dashboard should already be visible.
                                 console.log("Data already loaded from URL/Local. Skipping auto-load from Drive.");
                                 // Ensure main content is visible if it wasn't already
                                 if (mainContentElement && mainContentElement.style.display === 'none') {
                                    console.log("Main content was hidden, making it visible after successful sign-in.");
                                    mainContentElement.style.display = 'block';
                                    mainContentElement.classList.remove('hidden');
                                 }
                                 if (loadingSpinner) loadingSpinner.style.display = 'none'; // Hide spinner if it was on
                                 setChatStatus("Signed in to Drive", false); // Indicate successful sign-in
                                  // Ensure buttons are correctly visible (redundant but safe)
                                  updateDriveButtonVisibility(true);
                                  // Ensure chat UI state is correct based on current user context
                                 initializeChat();
                             }

                        })
                        .catch((loadError) => {
                             console.error("Error loading Google Drive API after sign-in:", loadError);
                             // This is a failure *after* authentication, but related to API access.
                             // Treat as an error but ensure token/sign-in state is kept.
                             // Don't clear googleAccessToken here.
                             handleError("Google Drive API Load Failed", loadError); // Report the error using central handler
                             // Ensure Drive buttons are hidden if the API failed to load
                             updateDriveButtonVisibility(false); // SignedIn will be true, but Load/Save require API
                             setChatStatus("Drive API Failed", false);
                             // Ensure chat UI state is correct even if Drive failed
                             initializeChat();
                        });

                } else {
                    // This case should ideally not happen if gapi.js loaded correctly via onload=handleGapiLoad()
                    // and handleGapiLoad successfully loaded the 'client' module.
                    // It means gapi.client is somehow not ready *even though* auth succeeded.
                    console.error("Gapi client not available to set token after successful response. Ensure api.js and 'client' module are loaded.");
                     googleAccessToken = null; // Clear token as gapi.client is broken
                     googleUser = null; // Clear user info
                     driveFolderId = null; // Clear cached folder ID
                    handleError("Google API Client Setup Failed", new Error("Google API client not fully ready after authentication.")); // Report the error
                    updateDriveButtonVisibility(false); // Hide Drive buttons
                     setChatStatus("API Client Failed", false);
                    // Ensure chat UI state is correct
                    initializeChat();
                }

            // --- Handle expected non-fatal error responses (interaction_required, access_denied, etc.) ---
            // These are results where a token was NOT obtained, but it's a known state that doesn't
            // necessarily indicate a critical application error needing the full handleError modal.
            // This handles failures from both silent ('prompt:none') and interactive ('prompt:auto') requests.
            } else if (tokenResponse && (tokenResponse.error === 'interaction_required' || tokenResponse.error === 'access_denied' || tokenResponse.error === 'popup_closed_by_user')) {
                 console.warn("Google token response indicated interaction is required or access denied/cancelled:", tokenResponse.error, tokenResponse.error_description);
                 googleAccessToken = null; // Ensure token is null as authentication was NOT successful
                 googleUser = null; // Clear user info display
                 // Clear token from gapi.client if it was somehow set previously
                 if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined' && typeof gapi.client.setToken === 'function') {
                     gapi.client.setToken(null);
                 }
                 driveFolderId = null; // Clear cached folder ID

                 // Update UI to show the sign-in button and reflect not signed in status
                 // Note: Main content visibility is *NOT* changed here. It should remain visible
                 // if it was loaded from URL params, or remain hidden if it was initially hidden.
                 updateDriveButtonVisibility(false); // Pass false because we are NOT signed in (no token)
                 signedInUserDisplayElement = signedInUserDisplayElement || document.getElementById('signedInUserDisplay');
                  if (signedInUserDisplayElement) {
                      signedInUserDisplayElement.textContent = '';
                      signedInUserDisplayElement.style.display = 'none';
                  }

                 // Set status message indicating user needs to click the button
                 setChatStatus("Signed out of Drive", false); // Update status
                 // Ensure chat UI state is correct
                 initializeChat(); // Chat might become disabled if no user ID is set

            // --- Handle any other unexpected errors in the token response ---
            } else if (tokenResponse && tokenResponse.error) {
                console.error("Google token response contained an unexpected error:", tokenResponse);
                googleAccessToken = null; // Ensure token is null
                googleUser = null;
                if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined' && typeof gapi.client.setToken === 'function') {
                    gapi.client.setToken(null);
                }
                driveFolderId = null;

                // Treat these as more serious failures needing the central error handler
                // This WILL call hideAllMainContentAreas(), which is appropriate for a critical error.
                 handleError("Google Sign-In Response Error", new Error(`Unexpected error from Google: ${tokenResponse.error || 'No error code'}: ${tokenResponse.error_description || 'Unknown'}`));
                 // Status and visibility will be set by handleError
                 // Ensure chat UI state is correct (likely disabled by handleError)
                 initializeChat();
            } else {
                 // --- Fallback for truly empty or unexpectedly structured responses ---
                 console.warn("Google token response was empty or unexpectedly structured.", tokenResponse);
                  googleAccessToken = null; // Ensure token is null
                  googleUser = null;
                  if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined' && typeof gapi.client.setToken === 'function') {
                      gapi.client.setToken(null);
                  }
                  driveFolderId = null;

                  // This WILL call hideAllMainContentAreas(), appropriate for a critical error.
                  handleError("Google Sign-In Response Error", new Error("Received empty or invalid response from Google."));
                 // Status and visibility will be set by handleError
                 // Ensure chat UI state is correct
                 initializeChat();
            }
        } catch (innerError) { // Catch any errors that occur within handleGoogleTokenResponse itself
             console.error("ERROR WITHIN handleGoogleTokenResponse:", innerError);
             // Ensure cleanup on internal error within this handler
             googleAccessToken = null;
             googleUser = null;
             if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined' && typeof gapi.client.setToken === 'function') {
                 gapi.client.setToken(null);
             }
             driveFolderId = null;
              handleError("Internal Google Auth Handler Error", innerError); // Report using central handler
             // Ensure chat UI state is correct
             initializeChat();
        }
    }


    // Fetch basic Google User Info (optional, for displaying signed-in status)
    // Called after a successful login/re-auth and Drive API load.
    async function fetchGoogleUserInfo() {
        console.log("Fetching Google user info...");
        // Need to load oauth2 API module if not already loaded
        try {
            // Check if gapi.client is available and has a token before attempting API call
            if (typeof gapi === 'undefined' || typeof gapi.client === 'undefined' || typeof gapi.client.getToken !== 'function' || !gapi.client.getToken()) {
                console.warn("Gapi client not ready or no token available to fetch user info.");
                 return; // Exit if prerequisites are not met
            }
             // Load the oauth2 API module if it hasn't been loaded yet.
             // gapi.client.load uses promises and handles idempotency.
            await gapi.client.load('oauth2', 'v2')
                 .then(() => console.log("OAuth2 API v2 loaded for user info."))
                 .catch(err => console.error("Error loading OAuth2 API for user info:", err));

            // Check again if the oauth2 API is available after attempting load
             if (typeof gapi.client.oauth2 === 'undefined' || typeof gapi.client.oauth2.userinfo === 'undefined' || typeof gapi.client.oauth2.userinfo.get !== 'function') {
                 console.error("Google OAuth2 userinfo API not available after load attempt.");
                 return; // Exit if API is not available
             }

            // Make the API request to get user information
            const response = await gapi.client.oauth2.userinfo.get();
            googleUser = response.result; // Store user info globally
            console.log("Google User Info:", googleUser);

            // Display user name if element exists and user info is available
            signedInUserDisplayElement = signedInUserDisplayElement || document.getElementById('signedInUserDisplay');
            if (signedInUserDisplayElement && googleUser?.name) {
                signedInUserDisplayElement.textContent = `Signed in as: ${googleUser.name}`;
                signedInUserDisplayElement.style.display = 'inline-block'; // Make the span visible
                console.log(`Signed in user display updated: ${googleUser.name}`);
            } else if (signedInUserDisplayElement) {
                 // If element exists but no user name (e.g., email only or error), hide it
                 signedInUserDisplayElement.style.display = 'none';
                 signedInUserDisplayElement.textContent = ''; // Clear any old text
            }

            // Update button visibility again now that user info is fetched (redundant but ensures display updates)
            updateDriveButtonVisibility(!!googleAccessToken);


        } catch (error) {
            console.error("Error fetching Google user info:", error);
            // If fetching user info fails, it's not a critical app error, just log it.
            // The UI will proceed without the user's name displayed.
             // Ensure display is hidden if fetch failed after a token was obtained
             signedInUserDisplayElement = signedInUserDisplayElement || document.getElementById('signedInUserDisplay');
             if (signedInUserDisplayElement) {
                 signedInUserDisplayElement.textContent = '';
                 signedInUserDisplayElement.style.display = 'none';
             }
        }
    }


    // Handle Google Sign Out
    // Revokes the access token and clears local Google-related state.
    function handleGoogleSignOut() {
        console.log("Signing out of Google...");
        // Check if we have a token and the GIS library is available to revoke it
        if (googleAccessToken && typeof google !== 'undefined' && typeof google.accounts !== 'undefined' && typeof google.accounts.oauth2 !== 'undefined' && typeof google.accounts.oauth2.revoke === 'function') {
            // Revoke the access token to invalidate it on Google's side
            google.accounts.oauth2.revoke(googleAccessToken, (revokeResponse) => {
                 console.log("Google access token revoke response:", revokeResponse); // Log revoke response from Google
                console.log("Google access token revoked successfully.");
                // Clear local state after successful revocation
                googleAccessToken = null;
                googleUser = null;
                 // Clear the token in gapi.client as well
                 if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined' && typeof gapi.client.setToken === 'function') {
                    gapi.client.setToken(null);
                    console.log("Token cleared in gapi.client.");
                    // Optionally clear the Drive API instance if needed, though typically not strictly necessary
                    // gapi.client.drive = undefined; // Or null
                 }
                console.log("Google sign out process complete.");

                // Update button visibility to hide Drive buttons and show sign-in button
                updateDriveButtonVisibility(false);
                 // Clear and hide the signed-in user display
                 signedInUserDisplayElement = signedInUserDisplayElement || document.getElementById('signedInUserDisplay');
                 if (signedInUserDisplayElement) {
                     signedInUserDisplayElement.textContent = '';
                     signedInUserDisplayElement.style.display = 'none';
                 }

                 // Clear the cached Drive folder ID as it's specific to the signed-in user/session
                 driveFolderId = null;
                 console.log("Drive folder ID cache cleared.");

                 // After signing out of Google, the user is back to a state where they need to load data.
                 // Show the initial upload prompt state again.
                 showInitialPromptOrMessage();
                 setChatStatus("Signed out of Drive", false); // Update chat status
                 // Chat might become disabled if no user ID is set after sign-out
                 initializeChat();
            });
        } else {
            // If we don't have an access token or GIS is not available, we can't revoke.
            // Just clear local state and update UI.
            console.log("No Google access token or GIS library not available to revoke. Clearing local state only.");
            googleAccessToken = null;
            googleUser = null;
             if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined' && typeof gapi.client.setToken === 'function') {
                 gapi.client.setToken(null);
             }
             driveFolderId = null; // Clear cache
            // Update UI visibility
            updateDriveButtonVisibility(false);
             signedInUserDisplayElement = signedInUserDisplayElement || document.getElementById('signedInUserDisplay');
             if (signedInUserDisplayElement) {
                 signedInUserDisplayElement.textContent = '';
                 signedInUserDisplayElement.style.display = 'none';
             }
             // Show initial prompt state
             showInitialPromptOrMessage();
             setChatStatus("Signed out of Drive", false);
             initializeChat(); // Update chat state
        }
    }

    // Update visibility of Google Drive related buttons and the user display span.
    // Called whenever the signed-in state or data loading state changes.
    function updateDriveButtonVisibility(isSignedIn) {
        // Ensure all relevant button and display elements are cached
        uploadButtonHeader = uploadButtonHeader || document.getElementById('uploadButton'); // Local upload
        downloadLocalButton = downloadLocalButton || document.getElementById('downloadLocalButton'); // Local download
        loadFromDriveButton = loadFromDriveButton || document.getElementById('loadFromDriveButton');
        saveToDriveButton = saveToDriveButton || document.getElementById('saveToDriveButton');
        googleSignInButton = googleSignInButton || document.getElementById('googleSignInButton'); // Generic hidden button
        googleSignOutButton = googleSignOutButton || document.getElementById('googleSignOutButton');
        signedInUserDisplayElement = signedInUserDisplayElement || document.getElementById('signedInUserDisplay');
        promptGoogleLoadButton = promptGoogleLoadButton || document.getElementById('promptGoogleLoadButton'); // Button in the initial prompt

        console.log("Updating Drive button visibility. Signed in:", isSignedIn);

        // Manage visibility of Google-related buttons based on sign-in state and potentially data loaded state
        if (googleSignInButton) googleSignInButton.style.display = 'none'; // Always keep the generic Sign In button hidden in this flow
        if (googleSignOutButton) googleSignOutButton.style.display = isSignedIn ? 'inline-block' : 'none'; // Show Sign Out when signed in

        // Determine if dashboard data is currently loaded (needed for Save/Download)
        const isDataLoaded = dashboardData && dashboardData.userInput && dashboardData.userInput.personalInfo && Object.keys(getSafe(() => dashboardData.userInput.personalInfo, {})).length > 0;
         console.log("Data loaded:", isDataLoaded);

        // The primary Drive interaction buttons (Load/Save)
        if (loadFromDriveButton) loadFromDriveButton.style.display = isSignedIn ? 'inline-block' : 'none';
        if (saveToDriveButton) saveToDriveButton.style.display = (isSignedIn && isDataLoaded) ? 'inline-block' : 'none'; // Save requires data AND sign-in

        // The Load from Drive button in the initial prompt screen
         if (promptGoogleLoadButton && initialUploadPrompt && initialUploadPrompt.style.display !== 'none' && googleTokenClient) { // Only show if prompt is visible AND GIS is ready
             promptGoogleLoadButton.style.display = isSignedIn ? 'none' : 'inline-block'; // Show this button only when NOT signed in, on the prompt screen
         } else if (promptGoogleLoadButton) {
             promptGoogleLoadButton.style.display = 'none'; // Hide otherwise
         }


        // Local file buttons (Upload is always available, Download requires data)
        if (uploadButtonHeader) uploadButtonHeader.style.display = 'inline-block'; // Always show local upload in header
        if (downloadLocalButton) downloadLocalButton.style.display = isDataLoaded ? 'inline-block' : 'none'; // Local download requires data


        // Display user info span only when signed in AND user info is available
        if (signedInUserDisplayElement) {
            const hasUserInfo = googleUser?.name;
            signedInUserDisplayElement.style.display = (isSignedIn && hasUserInfo) ? 'inline-block' : 'none';
            if (isSignedIn && hasUserInfo) {
                 signedInUserDisplayElement.textContent = `Signed in as: ${googleUser.name}`;
            } else {
                 signedInUserDisplayElement.textContent = '';
            }
        }


        console.log("Button states updated:", {
             localUpload: uploadButtonHeader?.style.display,
             localDownload: downloadLocalButton?.style.display,
             driveLoad: loadFromDriveButton?.style.display,
             driveSave: saveToDriveButton?.style.display,
             signOut: googleSignOutButton?.style.display,
             promptGoogleLoad: promptGoogleLoadButton?.style.display,
             signedInUserDisplay: signedInUserDisplayElement?.style.display
        });
    }

    // --- Google Drive Handlers Implementation ---

    /**
     * Finds the designated SmartWealth Navigator Reports folder in Google Drive.
     * Creates the folder if it doesn't exist.
     * Stores the folder ID in the global `driveFolderId`.
     * The folder name is derived from `currentUserId`.
     * @returns {Promise<string>} A promise that resolves with the folder ID.
     */
    async function findOrCreateDriveFolder() {
        const folderName = getDriveFolderName(); // Use the function to get the dynamic name
        console.log(`Attempting to find or create Drive folder: "${folderName}"`);

         if (!currentUserId) {
              console.error("Cannot find or create Drive folder: currentUserId is not set.");
              throw new Error("User ID is required to access Google Drive folder.");
         }

        if (!gapi || !gapi.client || !gapi.client.drive || !googleAccessToken) { // Check for token here too
            console.error("Google Drive API client is not loaded or user not signed in for folder operation.");
            throw new Error("Google Drive API is not ready or user is not signed in.");
        }

        if (driveFolderId) {
             console.log(`Folder ID already cached: ${driveFolderId}`);
             return driveFolderId; // Return cached ID if available
        }

        try {
            // 1. Search for the folder in the root
            const searchResponse = await gapi.client.drive.files.list({
                q: `name='${folderName}' and mimeType='application/vnd.google-apps.folder' and 'root' in parents and trashed=false`,
                spaces: 'drive',
                fields: 'files(id, name)',
                pageSize: 1
            });

            const files = searchResponse.result.files;

            if (files && files.length > 0) {
                // Folder found
                driveFolderId = files[0].id;
                console.log(`Found existing Drive folder: "${folderName}" (ID: ${driveFolderId})`);
                return driveFolderId;
            } else {
                // 2. Folder not found, create it
                console.log(`Drive folder "${folderName}" not found. Creating...`);
                const fileMetadata = {
                    'name': folderName,
                    'mimeType': 'application/vnd.google-apps.folder',
                    'parents': ['root'] // Create in the root folder
                };
                const createResponse = await gapi.client.drive.files.create({
                    resource: fileMetadata,
                    fields: 'id'
                });

                driveFolderId = createResponse.result.id;
                console.log(`Created new Drive folder: "${folderName}" (ID: ${driveFolderId})`);
                return driveFolderId;
            }
        } catch (error) {
            console.error(`Error finding or creating Drive folder "${folderName}":`, error);
             let userFacingError = `Failed to access or create Google Drive folder "${folderName}".`;
             if (error.result?.error?.message) userFacingError += ` Google Error: ${error.result.error.message}`;
             else if (error.message) userFacingError += ` Error: ${error.message}`;
            throw new Error(userFacingError);
        }
    }

    /**
     * Lists PSR files within the designated folder.
     * Searches for the standard filename `my_financial_report.json`.
     * @returns {Promise<Array<Object>>} A promise that resolves with a list of files (id, name, modifiedTime).
     */
    async function listDriveFiles() {
        const folderName = getDriveFolderName();
        console.log(`Listing files named "${PSR_FILE_NAME}" in folder ID: ${driveFolderId} ("${folderName}")`);

        if (!gapi || !gapi.client || !gapi.client.drive || !driveFolderId || !googleAccessToken) { // Check for token here too
             console.warn("Google Drive not signed in or API not ready or folder ID missing for listing.");
             throw new Error("Google Drive API is not ready, user not signed in, or folder not accessible.");
        }

        try {
            // Search for files by name and mimeType within the specific folder
            const searchResponse = await gapi.client.drive.files.list({
                q: `name='${PSR_FILE_NAME}' and mimeType='${PSR_MIME_TYPE}' and '${driveFolderId}' in parents and trashed=false`,
                spaces: 'drive',
                fields: 'files(id, name, modifiedTime)',
                orderBy: 'modifiedTime desc', // Order by modification time descending
                pageSize: 10 // Get up to 10 files with the same name (should ideally be only one)
            });

            const files = searchResponse.result.files;
            console.log(`Found ${files ? files.length : 0} files matching "${PSR_FILE_NAME}".`, files);
            return files || [];

        } catch (error) {
            console.error("Error listing Drive files:", error);
             // Provide more specific error message based on Google API error structure
            let userFacingError = "Failed to list files from Google Drive.";
             if (error.result?.error?.message) {
                 userFacingError = `Google Drive Error: ${error.result.error.message}`;
             } else if (error.message) {
                  userFacingError = `Load Error: ${error.message}`;
             }
            throw new Error(userFacingError);
        }
    }

     /**
     * Loads the content of a specific file from Google Drive.
     * @param {string} fileId The ID of the file to load.
     * @returns {Promise<Object>} A promise that resolves with the parsed JSON content of the file.
     */
    async function loadDriveFileContent(fileId) {
        console.log(`Loading file content for file ID: ${fileId}`);
        if (!gapi || !gapi.client || !gapi.client.drive || !googleAccessToken) { // Check for token here too
             console.error("Google Drive API client is not loaded or user not signed in for content loading.");
             throw new Error("Google Drive API is not ready or user is not signed in.");
        }

        try {
            // Use alt=media to download the file content
            const response = await gapi.client.drive.files.get({
                fileId: fileId,
                alt: 'media'
            });

            // The response.result contains the file content (as text for JSON)
            console.log("Raw file content received (first 200 chars):", String(response.body).substring(0, 200) + '...');

            try {
                const fileContent = JSON.parse(response.body); // Assuming the content is JSON
                console.log("Parsed file content from Drive:", fileContent);
                return fileContent;
            } catch (parseError) {
                 console.error("Error parsing file content as JSON:", parseError);
                 throw new Error("Failed to parse the file content as JSON. It might be corrupted.");
            }

        } catch (error) {
            console.error("Error loading file content from Drive:", error);
             // Check if the error indicates permission issues (e.g., 403) or file not found (404)
             let userFacingError = "Failed to load file from Google Drive.";
             if (error.result?.error?.code === 403) {
                 userFacingError = "Permission denied to access this file in Google Drive. Please check your Google account permissions.";
             } else if (error.result?.error?.code === 404) {
                 userFacingError = "File not found in Google Drive. It may have been moved or deleted.";
             } else if (error.result?.error?.message) {
                  userFacingError = `Google Drive Error: ${error.result.error.message}`;
             } else if (error.message) {
                  userFacingError = `Load Error: ${error.message}`;
             }
            throw new Error(userFacingError);
        }
    }


    /**
     * Saves the current dashboardData as a JSON file to the designated Drive folder.
     * Updates the existing file if found, otherwise creates a new one.
     * Uses the standard filename `my_financial_report.json`.
     * @returns {Promise<void>} A promise that resolves when the file is saved.
     */
    async function saveFileToDrive() {
        console.log("Attempting to save file to Google Drive...");

         const dataToSave = getDataForSave(); // Use the helper function

        if (!dataToSave) {
             throw new Error("No dashboard data available to save.");
        }
        if (!gapi || !gapi.client || !gapi.client.drive || !googleAccessToken) {
             console.error("Google Drive API is not ready or user is not signed in for saving.");
             throw new Error("Google Drive API is not ready or user is not signed in.");
        }
         if (!currentUserId) {
              console.error("Attempted to save to Drive without a valid currentUserId.");
              throw new Error("User ID is required to save to Google Drive.");
         }


         // Provide immediate feedback to the user
         setChatStatus("Saving to Drive...", true);
         // Disable save button to prevent multiple clicks
         if (saveToDriveButton) saveToDriveButton.disabled = true;
         if (loadFromDriveButton) loadFromDriveButton.disabled = true; // Disable load during save
         if (downloadLocalButton) downloadLocalButton.disabled = true;


        const fileContent = JSON.stringify(dataToSave, null, 2);
        const blob = new Blob([fileContent], { type: PSR_MIME_TYPE });

        let fileIdToUpdate = null;

        try {
            // 1. Ensure the folder exists and get its ID (uses cached driveFolderId or finds/creates)
            const folderId = await findOrCreateDriveFolder();
            console.log("Drive folder ID for saving:", folderId);

            // 2. Search for an existing file with the standard name in this folder
            const existingFiles = await listDriveFiles(); // listDriveFiles already filters by name/type/parent/trashed

            if (existingFiles && existingFiles.length > 0) {
                // Found existing file(s) - use the first one (most recent if list was ordered)
                fileIdToUpdate = existingFiles[0].id;
                console.log(`Found existing file "${PSR_FILE_NAME}" (ID: ${fileIdToUpdate}). Will update.`);
            }

            // 3. Prepare the request body (metadata is separate in multipart)
            const fileMetadata = {
                'name': PSR_FILE_NAME,
                'mimeType': PSR_MIME_TYPE,
                // Specify parents ONLY when creating (POST), not when updating (PATCH)
                ...(fileIdToUpdate ? {} : { 'parents': [folderId] })
            };

            // Use multipart upload for file content
            const form = new FormData();
            form.append('metadata', new Blob([JSON.stringify(fileMetadata)], { type: 'application/json' }));
            form.append('file', blob);

            // Determine the API endpoint and method (update or create)
            const path = fileIdToUpdate ? `/upload/drive/v3/files/${fileIdToUpdate}` : `/upload/drive/v3/files`;
            const method = fileIdToUpdate ? 'PATCH' : 'POST'; // Use PATCH to update, POST to create

            console.log(`Executing Drive file ${fileIdToUpdate ? 'update (PATCH)' : 'create (POST)'} request...`);

            // 4. Execute the request using gapi.client.request
            // Need to ensure gapi.client is loaded BEFORE this request
             if (typeof gapi === 'undefined' || typeof gapi.client === 'undefined' || typeof gapi.client.request !== 'function') {
                 console.error("Google API client is not loaded for file request.");
                 throw new Error("Google API client is not ready.");
             }

            const response = await gapi.client.request({
                path: path,
                method: method,
                params: { uploadType: 'multipart' }, // Indicate multipart upload
                headers: { 'Authorization': `Bearer ${googleAccessToken}` }, // Ensure Authorization header is set
                body: form
            });

            console.log(`Drive file ${fileIdToUpdate ? 'updated' : 'created'} successfully:`, response.result);
            // The response.result will contain the file metadata including the ID

        } catch (error) {
            console.error("Error during Save to Drive process:", error);
             // Provide more specific error messages if possible
            let userFacingError = "Failed to save file to Google Drive.";
             if (error.message.includes("Google Drive API is not ready") || error.message.includes("not signed in")) {
                 userFacingError = "Please sign in to Google Drive first.";
             } else if (error.message.includes("Failed to access Google Drive folder")) {
                 userFacingError = error.message; // Use the specific folder error message
             } else if (error.result?.error?.message) {
                 userFacingError = `Google Drive Error: ${error.result.error.message}`;
             } else if (error.message) {
                  userFacingError = `Save Error: ${error.message}`;
             }
            addMessageToChat("System", "Failed to save report to Google Drive: " + userFacingError, true); // Add error to chat
            setChatStatus("Save failed", false);
             // Optionally show a more detailed error modal
             // handleError("Failed to save to Google Drive", error); // Can call this for critical errors
        } finally {
             // Re-enable buttons
             if (saveToDriveButton) saveToDriveButton.disabled = false;
             if (loadFromDriveButton) loadFromDriveButton.disabled = false;
             if (downloadLocalButton) downloadLocalButton.disabled = false;
             // Status message will auto-clear or stay if error
             // setChatStatus("", false); // Already done by setChatStatus itself
        }
    }


    /**
     * Performs the actual file loading or initiates sign-in if not already authenticated.
     * This is the core logic called by handleLoadFromDriveClick and potentially handleGoogleTokenResponse.
     * @param {boolean} isAutoLoad - True if this is an automatic load after sign-in (no user click happened first for this specific action), false if user explicitly clicked Load.
     */
    async function performDriveLoadOrSignIn(isAutoLoad = false) {
         console.log(`Attempting Google Drive Load flow (isAutoLoad: ${isAutoLoad}). Signed in: ${!!googleAccessToken}`);

         if (!googleTokenClient) {
              console.error("Google Identity Services client not initialized. Cannot initiate Drive load.");
              handleError("Google sign-in services not ready. Cannot load from Drive.", new Error("GIS client is null."));
              return;
         }

         if (!googleAccessToken) {
             console.log("Not signed in. Initiating Google Sign-In process.");
             // If not signed in, request interactive sign-in.
             // The handleGoogleTokenResponse callback will be called upon completion.
             // It will then check for success and, if successful, will call performDriveLoadOperation.
             setChatStatus("Waiting for Google Sign-in...", true);
             // Use 'select_account' to allow user to pick if multiple signed in
             googleTokenClient.requestAccessToken({ prompt: 'select_account' });
             // The rest of the process continues in handleGoogleTokenResponse.
             return; // Exit this function, wait for callback
         }

         // --- Proceed with Load operation IF signed in ---
         console.log("Signed in. Proceeding with Drive load operation.");

         // Show loading state
         hideAllMainContentAreas(); // Hide existing content
         if (loadingSpinner) loadingSpinner.style.display = 'flex';
         setChatStatus("Loading from Drive...", true);


         const driveLoadModal = document.getElementById('driveLoadModal');
         const driveFileListDiv = document.getElementById('driveFileList');
         const driveLoadErrorP = document.getElementById('driveLoadError');

         if (driveFileListDiv) driveFileListDiv.innerHTML = 'Searching...';
         if (driveLoadErrorP) driveLoadErrorP.textContent = '';

         // Ensure user ID is available to construct the folder name
         if (!currentUserId) {
             console.error("Cannot load from Drive: currentUserId is not set.");
             if (loadingSpinner) loadingSpinner.style.display = 'none';
             setChatStatus("Load failed (no user ID)", false);
             handleError("Cannot load from Drive", new Error("User ID is required to access Google Drive folder. Please ensure you are authenticated correctly."));
             updateDriveButtonVisibility(!!googleAccessToken);
             initializeChat();
             return;
         }


         try {
             // 1. Ensure the folder exists (uses cached driveFolderId or finds/creates it)
             const folderId = await findOrCreateDriveFolder();
             console.log("Drive folder ID for loading:", folderId);

             // 2. List files in the folder matching the standard name
             const files = await listDriveFiles();

             if (!files || files.length === 0) {
                 console.log(`No PSR file (${PSR_FILE_NAME}) found in Drive folder ("${getDriveFolderName()}").`);
                 if (loadingSpinner) loadingSpinner.style.display = 'none'; // Hide spinner
                 // If no file found, revert to showing the prompt but indicate Drive is connected
                 showInitialPromptOrMessage(`No SmartWealth Navigator file found in your Google Drive folder "${getDriveFolderName()}". You can upload a local file or generate a new report.`);
                 setChatStatus("No file found in Drive", false);
                 // Update button visibility (Load button should still be visible as signed in)
                 updateDriveButtonVisibility(!!googleAccessToken);
                 // Ensure chat UI state is correct based on user context but no data
                 initializeChat();

                 return; // Exit function
             }

             // 3. Handle multiple files or load the first one found (most recent)
             // The listDriveFiles function already sorts by modifiedTime desc, so files[0] is the latest
             const fileToLoad = files[0];
             console.log(`Found file to load: "${fileToLoad.name}" (ID: ${fileToLoad.id}). Loading content...`);

             // Close the potential file list modal if it was open
             closeModal('driveLoadModal');

             // Load the content of the selected file
             const fileContent = await loadDriveFileContent(fileToLoad.id);

             console.log("Processing loaded data from Drive file...");

             // Validate loaded data structure
             if (fileContent && fileContent.userInput && typeof fileContent.userInput === 'object' && fileContent.userInput.personalInfo && Object.keys(getSafe(() => fileContent.userInput.personalInfo, {})).length > 0) { // Added check for non-empty personalInfo
                  console.log("Loaded file content is valid PSR data. Updating dashboard.");

                  // --- Restore User ID and Tier from file metadata ---
                  // Prioritize explicit userId/tier from file metadata if available
                 const fileUserId = getSafe(() => fileContent.metadata?.userId, null);
                 const fileUserTier = getSafe(() => fileContent.metadata?.tier, null);

                 if (fileUserId && fileUserId !== 'N/A' && fileUserId.length > 0) {
                     if(fileUserId !== currentUserId) console.warn(`Overriding current user ID (${currentUserId}) with ID from file metadata: ${fileUserId}`);
                     currentUserId = fileUserId;
                 } else {
                    // If file doesn't have userId, keep the current one (from XTL or previous state)
                    console.warn("Loaded file metadata has no valid userId. Keeping current user context:", currentUserId);
                 }

                if (fileUserTier && ['basic', 'pro'].includes(fileUserTier)) {
                     if(fileUserTier !== effectiveTier) console.warn(`Overriding current tier (${effectiveTier}) with tier from file metadata: ${fileUserTier}`);
                     effectiveTier = fileUserTier;
                } else {
                    // If file doesn't have tier, keep the current one (from XTL or previous state)
                    console.warn("Loaded file metadata has no valid tier. Keeping current tier context:", effectiveTier);
                }

                // Note: We do NOT restore initialUsageInfo from the file here.
                // We will fetch the *current* usage from the DB next.
                // Update dashboardData with the loaded content
                dashboardData = fileContent;

                // Restore chat history from the file
                if (Array.isArray(getSafe(() => dashboardData.chatHistory))) { // Use getSafe for chatHistory check
                    chatMessages = dashboardData.chatHistory.filter(msg => msg && msg.role && msg.content); // Filter valid messages
                    console.log(`Restored ${chatMessages.length} chat messages from file.`);
                } else {
                    chatMessages = []; // Clear chat history if not found or invalid
                    console.log("No valid chat history found in file, starting with empty chat.");
                }

                // Add source metadata if missing or update
                 dashboardData.metadata = dashboardData.metadata || {};
                 dashboardData.metadata.source = 'google_drive_loaded';


                // Process and display the financial data and AI output from the file
                processAndDisplayData(dashboardData); // This updates the main dashboard UI and hides spinner


                // *** IMPORTANT: NOW FETCH THE CURRENT USAGE FROM THE DATABASE ***
                // This will update initialUsageInfo and trigger updateUIBasedOnAccess -> initializeChat
                console.log("File processed, fetching current usage from database based on determined user ID...");
                fetchInitialUsage();


             } else {
                 console.error("Loaded file content does not match expected PSR format or is incomplete.", fileContent);
                 throw new Error("The file from Google Drive is not a valid SmartWealth Navigator report.");
             }

         } catch (error) {
             console.error("Error during Drive file load process:", error);
             if (loadingSpinner) loadingSpinner.style.display = 'none'; // Hide spinner
             setChatStatus("Load failed", false);
             handleError("Failed to load file from Google Drive", error);
             // Keep current user info from initial load if available.
             updateDriveButtonVisibility(!!googleAccessToken); // Ensure buttons are updated based on current auth state
             initializeChat(); // Update chat state based on current user/no data
         }
     }


    /**
     * Performs the actual file saving process to Google Drive.
     * This function is called *after* successful Google Sign-In/Auth.
     */
    async function performDriveSave() {
        console.log("Performing Drive Save. Signed in:", !!googleAccessToken);

        const dataToSave = getDataForSave(); // Use the helper function

        if (!dataToSave) {
             console.warn("Attempted performDriveSave without valid dashboard data.");
             // This case should not happen if Save button visibility is managed correctly.
             alert("No dashboard data available to save.");
             setChatStatus("Save failed (no data)", false);
             return;
        }
         if (!googleAccessToken) {
             console.warn("Attempted performDriveSave without access token.");
             // This case should not happen if initiateGoogleFlow works correctly before calling this.
             alert("Please sign in to Google Drive first.");
             setChatStatus("Save failed (not signed in)", false);
             return;
         }
         // Ensure user ID is set before attempting to create the folder name
         if (!currentUserId) {
              console.error("Attempted performDriveSave without a valid currentUserId.");
              alert("Cannot save without a user ID. Please ensure you are authenticated correctly.");
              setChatStatus("Save failed (no user ID)", false);
              return;
         }


         // Provide immediate feedback to the user
         setChatStatus("Saving to Drive...", true);
         // Disable save button to prevent multiple clicks
         if (saveToDriveButton) saveToDriveButton.disabled = true;
         if (loadFromDriveButton) loadFromDriveButton.disabled = true; // Disable load during save
         if (downloadLocalButton) downloadLocalButton.disabled = true;


        const fileContent = JSON.stringify(dataToSave, null, 2);
        const blob = new Blob([fileContent], { type: PSR_MIME_TYPE });

        let fileIdToUpdate = null;

        try {
            // 1. Ensure the folder exists and get its ID (uses cached driveFolderId or finds/creates)
            const folderId = await findOrCreateDriveFolder();
            console.log("Drive folder ID for saving:", folderId);

            // 2. Search for an existing file with the standard name in this folder
            const existingFiles = await listDriveFiles(); // listDriveFiles already filters by name/type/parent/trashed

            if (existingFiles && existingFiles.length > 0) {
                // Found existing file(s) - use the first one (most recent if list was ordered)
                fileIdToUpdate = existingFiles[0].id;
                console.log(`Found existing file "${PSR_FILE_NAME}" (ID: ${fileIdToUpdate}). Will update.`);
            }

            // 3. Prepare the request body (metadata is separate in multipart)
            const fileMetadata = {
                'name': PSR_FILE_NAME,
                'mimeType': PSR_MIME_TYPE,
                // Specify parents ONLY when creating (POST), not when updating (PATCH)
                ...(fileIdToUpdate ? {} : { 'parents': [folderId] })
            };

            // Use multipart upload for file content
            const form = new FormData();
            form.append('metadata', new Blob([JSON.stringify(fileMetadata)], { type: 'application/json' }));
            form.append('file', blob);

            // Determine the API endpoint and method (update or create)
            const path = fileIdToUpdate ? `/upload/drive/v3/files/${fileIdToUpdate}` : `/upload/drive/v3/files`;
            const method = fileIdToUpdate ? 'PATCH' : 'POST'; // Use PATCH to update, POST to create

            console.log(`Executing Drive file ${fileIdToUpdate ? 'update (PATCH)' : 'create (POST)'} request...`);

            // 4. Execute the request using gapi.client.request
            // Need to ensure gapi.client is loaded BEFORE this request
             if (typeof gapi === 'undefined' || typeof gapi.client === 'undefined' || typeof gapi.client.request !== 'function') {
                 console.error("Google API client is not loaded for file request.");
                 throw new Error("Google API client is not ready.");
             }

            const response = await gapi.client.request({
                path: path,
                method: method,
                params: { uploadType: 'multipart' }, // Indicate multipart upload
                headers: { 'Authorization': `Bearer ${googleAccessToken}` }, // Ensure Authorization header is set
                body: form
            });

            console.log(`Drive file ${fileIdToUpdate ? 'updated' : 'created'} successfully:`, response.result);
            // The response.result will contain the file metadata including the ID

        } catch (error) {
            console.error("Error during Save to Drive process:", error);
             // Provide more specific error messages if possible
            let userFacingError = "Failed to save file to Google Drive.";
             if (error.message.includes("Google Drive API is not ready") || error.message.includes("not signed in")) {
                 userFacingError = "Please sign in to Google Drive first.";
             } else if (error.message.includes("Failed to access Google Drive folder")) {
                 userFacingError = error.message; // Use the specific folder error message
             } else if (error.result?.error?.message) {
                 userFacingError = `Google Drive Error: ${error.result.error.message}`;
             } else if (error.message) {
                  userFacingError = `Save Error: ${error.message}`;
             }
            addMessageToChat("System", "Failed to save report to Google Drive: " + userFacingError, true); // Add error to chat
            setChatStatus("Save failed", false);
             // Optionally show a more detailed error modal
             // handleError("Failed to save to Google Drive", error); // Can call this for critical errors
        } finally {
             // Re-enable buttons
             if (saveToDriveButton) saveToDriveButton.disabled = false;
             if (loadFromDriveButton) loadFromDriveButton.disabled = false;
             if (downloadLocalButton) downloadLocalButton.disabled = false;
             // Status message will auto-clear or stay if error
             // setChatStatus("", false); // Already done by setChatStatus itself
        }
    }


    // --- MAIN Document Ready Event ---
    document.addEventListener('DOMContentLoaded', function() {
        console.log("DOM fully loaded. Initializing application...");

        // --- 1. Cache Global DOM Elements ---
        // Cache them safely, check for null later if needed
        loadingSpinner = document.getElementById('loadingSpinner');
        errorMessageElement = document.getElementById('errorMessage');
        mainContentElement = document.getElementById('mainContent');
        initialMessageElement = document.getElementById('initialMessage');
        initialUploadPrompt = document.getElementById('initialUploadPrompt');
        errorTextElement = document.getElementById('errorText');
        debugInfoElement = document.getElementById('debugInfo');
        fileInput = document.getElementById('fileInput');
        chatInterfaceCardElement = document.getElementById('chatInterfaceCard'); // Cache chat card

        // Cache Drive related buttons
        uploadButtonHeader = document.getElementById('uploadButton');
        downloadLocalButton = document.getElementById('downloadLocalButton');
        loadFromDriveButton = document.getElementById('loadFromDriveButton');
        saveToDriveButton = document.getElementById('saveToDriveButton');
        googleSignInButton = document.getElementById('googleSignInButton'); // Generic hidden button
        googleSignOutButton = document.getElementById('googleSignOutButton'); // Sign Out button
        signedInUserDisplayElement = document.getElementById('signedInUserDisplay');
        promptGoogleLoadButton = document.getElementById('promptGoogleLoadButton'); // Button in the initial prompt

        console.log("Cached DOM elements.");

        // --- 2. Set Initial UI State ---
        // Hide all main content areas first, then show spinner
        hideAllMainContentAreas();
        if (loadingSpinner) {
            loadingSpinner.style.display = 'flex'; // Use flex for centering spinner
            console.log("Spinner shown.");
        } else {
             console.error("Loading spinner element not found!");
             // Cannot show spinner, proceed with caution
        }

        // Add the resize listener early
         window.addEventListener('resize', handleResize);
         console.log("Window resize listener added.");


        // --- 3. Initialization Flow ---
        try {
            console.log("Starting main initialization try block...");

            // Get URL parameters once
            const params = parseUrlParams();

            // Check for the 'data=null' special case first
            if (params === null) {
                // parseUrlParams already logged warning.
                // Hide spinner and show the initial prompt state
                console.log("'data=null' param detected. Showing initial upload prompt.");
                if (loadingSpinner) loadingSpinner.style.display = 'none';
                showInitialPromptOrMessage();
                // Initialize core features including Supabase and Google APIs
                // This also triggers fetchInitialUsage (using the determined currentUserId/effectiveTier)
                // and subsequently updateUIBasedOnAccess -> initializeChat,
                // AND initiates Google API loading and silent auth attempt.
                initializeSupabaseAndCoreFeatures();
                console.log("Exiting main try block due to 'data=null'.");
                return; // Stop main initialization flow
            }

            // Parse the xtl parameter FIRST to get userId and effectiveTier
            const xtlParsedSuccessfully = parseXtlParameter(params);
            console.log(`XTL parsed successfully: ${xtlParsedSuccessfully}, currentUserId: ${currentUserId}, effectiveTier: ${effectiveTier}`);


            // Parse financial data from URL parameters regardless of XTL success
            // This sets initial dashboardData (might be null)
            dashboardData = parseDataFromUrlParams(params) || {}; // Use || {} to ensure it's an object


            // Initialize core features including Supabase and Google APIs
            // This also triggers fetchInitialUsage (using the determined currentUserId/effectiveTier)
            // and subsequently updateUIBasedOnAccess -> initializeChat,
            // AND initiates Google API loading and silent auth attempt.
            initializeSupabaseAndCoreFeatures();
            console.log("Core features initialization initiated.");


            // Determine which main content state to show based on data and auth status
            console.log("Checking conditions for initial content display:");
            // Check if dashboardData has valid userInput and personalInfo
            const hasDataFromUrl = dashboardData && dashboardData.userInput && dashboardData.userInput.personalInfo && Object.keys(getSafe(() => dashboardData.userInput.personalInfo, {})).length > 0;
             console.log(`  hasDataFromUrl: ${hasDataFromUrl}`);
             console.log(`  xtlParsedSuccessfully: ${xtlParsedSuccessfully}`);
             console.log(`  currentUserId (after XTL): ${currentUserId}`);


            if (hasDataFromUrl) {
                 // Data was successfully parsed from URL params
                 console.log("Condition matched: hasDataFromUrl is true. Processing and displaying data from URL.");
                 // Update metadata source for loaded data
                 dashboardData.metadata = dashboardData.metadata || {};
                 // If XTL provided user info, ensure data object has it for saving later
                 if (currentUserId && !dashboardData.metadata.userId) dashboardData.metadata.userId = currentUserId;
                 if (effectiveTier && !dashboardData.metadata.tier) dashboardData.metadata.tier = effectiveTier;
                 // Set source if missing
                 if (!dashboardData.metadata.source || dashboardData.metadata.source === 'unknown') dashboardData.metadata.source = 'url_params';

                 // fetchInitialUsage was already initiated by initializeSupabaseAndCoreFeatures
                 processAndDisplayData(dashboardData); // This handles showing mainContent and hiding spinner, and updates UI elements

            } else if (xtlParsedSuccessfully && currentUserId) {
                 // No dashboard data from URL, but XTL was valid and provided a user ID.
                 // This user is logged in via XTL but has no data yet.
                 console.log(`Condition matched: XTL valid but no URL data. Showing empty main content shell for user ${currentUserId}.`);
                 hideAllMainContentAreas();
                 if (mainContentElement) {
                    mainContentElement.style.display = 'block';
                    mainContentElement.classList.remove('hidden');
                    console.log("Main content shell made visible.");
                 } else {
                     console.error("Main content element not found!");
                     handleError("Critical: Main content element not found.", new Error("DOM element #mainContent is missing."));
                     console.log("Exiting main try block due to missing mainContent element.");
                     return; // Cannot proceed without main content
                 }
                 // Create a minimal dashboardData structure with user context for saving/chat context
                 dashboardData = {
                     userInput: { personalInfo: {}, income: {}, expenses: {}, savings: {}, debts: [], financials: {} },
                     aiOutput: {},
                     metadata: { userId: currentUserId, tier: effectiveTier, source: 'xtl_no_data' },
                     chatHistory: []
                 };

                 // Update UI elements to show "N/A" or default states explicitly using the minimal data
                 updateReportBasics(dashboardData, calculateTotals(dashboardData));
                 updateRatiosDisplay(calculateRatios(dashboardData, calculateTotals(dashboardData)));
                 updateGoalsDisplay(dashboardData, calculateTotals(dashboardData));
                 updateDebtsDisplay(dashboardData, calculateTotals(dashboardData));
                 updateUIDisplayFromAI(dashboardData);
                 renderCharts(dashboardData, calculateTotals(dashboardData)); // Attempt to render empty charts or messages
                 console.log("Empty dashboard shell UI updated.");

                 if (loadingSpinner) loadingSpinner.style.display = 'none'; // Hide spinner now that shell is visible
                 console.log("Spinner hidden.");

                 // Google init runs automatically and silent auth is attempted.
                 // If silent auth succeeds, handleGoogleTokenResponse will call performDriveLoadOperation()
                 // which will auto-load the file IF it exists for this user ID.
                 // Button visibility will be updated by updateDriveButtonVisibility based on auth state.

            } else {
                 // No dashboard data from URL and no valid XTL (or XTL didn't provide a user ID).
                 console.log("Condition matched: No URL data and no valid XTL user. Showing initial prompt/message.");
                 if (loadingSpinner) loadingSpinner.style.display = 'none'; // Hide spinner
                 console.log("Spinner hidden.");
                 showInitialPromptOrMessage(); // Show the upload prompt or generic message
                 console.log("Initial prompt shown.");
                 // Error message might already be showing if XTL parse failed (handleInvalidAccess)
                 // Button visibility will be updated by updateDriveButtonVisibility after Google init/silent auth attempt.
                 // Supabase client is initialized, but fetchInitialUsage will report "No user ID" and chat will be disabled.
            }

             console.log("Finished conditions check for initial content display.");


        } catch (error) {
            console.error("CRITICAL Error during initial setup:", error);
            // Use the central error handler for any unexpected errors during setup
            handleError("Critical Initialization Error", error);
        } finally {
            // The spinner hiding is now managed by the specific display paths (processAndDisplayData, handleError, showInitialPromptOrMessage).
            console.log("DOMContentLoaded finally block finished.");
        }
    });


</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>SmartWealth Navigator - Enhanced Financial Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
     <!-- Updated CSP for Google APIs -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; frame-src content.googleapis.com; script-src 'self' 'unsafe-inline' cdn.tailwindcss.com cdn.plot.ly cdn.jsdelivr.net tfnwwpksieluzvxqdiiq.supabase.co accounts.google.com apis.google.com; style-src 'self' 'unsafe-inline' fonts.googleapis.com fonts.gstatic.com; font-src 'self' fonts.gstatic.com; img-src 'self' static.wixstatic.com data:; connect-src 'self' tfnwwpksieluzvxqdiiq.supabase.co https://tfnwwpksieluzvxqdiiq.supabase.co accounts.google.com apis.google.com https://www.googleapis.com; object-src 'none'; base-uri 'self'; form-action 'self';">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="./plotly.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- Add Google API loader script tags -->
    <script src="https://accounts.google.com/gsi/client" async defer onload="initializeGIS()"></script>
    <script src="https://apis.google.com/js/api.js" async defer onload="handleGapiLoad()"></script>

    <style>
        /* Base Styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f5f7fa;
            color: #374151;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            min-width: 100vw;
            overflow-x: hidden;

        }
        /* Garamond for Headers */
        h1, h2, h3, h4, .header-font {
            font-family: 'EB Garamond', serif;
            color: #111827;
            font-weight: bold;
        }
        h1 { font-size: 1.8em; }
        h2 { font-size: 1.5em; }
        h3 { font-size: 1.2em; color: #333; }
        h4 { font-size: 1.1em; }

        /* Main Container */
        .main-container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 1.5rem 2rem;
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.07);
        }

        /* Header */
        header {
            display: flex;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #e5e7eb;
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
        }
        header img {
            height: 72px;
            margin-right: 15px;
            border-radius: 8px;
            object-fit: contain;
        }
        header h1 {
            color: #4f46e5;
            margin: 0;
            flex-grow: 1; /* Allow title to take available space */
            font-size: 2.2em;
            line-height: 1.2;
             /* Add some spacing to the right if buttons are present */
            margin-right: 10px;
        }

        /* Header Buttons */
        header button {
            margin-left: 10px; /* Space between buttons */
            padding: 0.6rem 1.2rem;
            background-color: #4f46e5;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            /* Add flex-shrink to prevent buttons from shrinking */
            flex-shrink: 0;
        }
        header button#uploadButton { background-color: #059669; }
        header button:hover { background-color: #4338ca; }
        header button#uploadButton:hover { background-color: #047857; }
        #fileInput { display: none; }

        /* Add specific styles for Google buttons */
        #googleSignInButton {
            background-color: #4285F4; /* Google blue */
        }
        #googleSignInButton:hover {
            background-color: #3367D6;
        }
         #googleSignOutButton {
             background-color: #d1d5db; /* Gray */
             color: #374151;
         }
         #googleSignOutButton:hover {
             background-color: #9ca3af;
         }
         #loadFromDriveButton {
             background-color: #10b981; /* Green */
         }
         #loadFromDriveButton:hover {
             background-color: #059669;
         }
          #saveToDriveButton {
              background-color: #f59e0b; /* Amber/Orange */
          }
          #saveToDriveButton:hover {
              background-color: #d97706;
          }
         #downloadLocalButton {
             background-color: #6b7280; /* Darker Gray */
         }
         #downloadLocalButton:hover {
             background-color: #4b5563;
         }
         #signedInUserDisplay {
             margin-right: 10px;
             font-size: 0.9em;
             color: #4b5563;
             white-space: nowrap; /* Prevent wrapping */
             overflow: hidden;
             text-overflow: ellipsis; /* Add ellipsis if text overflows */
             max-width: 150px; /* Limit width */
             display: inline-block; /* Allow max-width */
         }


        /* Grid Layout */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-bottom: 25px;
        }

        /* Dashboard Cards */
        .dashboard-card {
            background: #fff;
            padding: 1.5rem;
            border-radius: 10px;
            /* Updated Shadow for more prominence */
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            /* Slightly darker border */
            border: 1px solid #d1d5db; /* Using a slightly darker gray than #e5e7eb */
            display: flex;
            flex-direction: column;
            min-height: 160px;
        }

        /* Card Headers */
        .card-header {
            font-family: 'Inter', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            color: #374151;
            margin: -1.5rem -1.5rem 1.25rem -1.5rem;
            padding: 0.75rem 1.5rem;
            border-bottom: 1px solid #e5e7eb;
            background-color: #f9fafb;
            border-radius: 10px 10px 0 0;
        }
        .dashboard-card h3 {
             margin: 0 0 1rem 0;
             padding: 0; border: none; background: none;
        }

        .card-content { flex-grow: 1; font-size: 0.95em; }
        .card-content p { margin-bottom: 0.6rem; }
        .card-content p strong { font-weight: 500; color: #1f2937; margin-right: 5px; }

        /* Chart Card Specifics */
        .chart-card {
            min-height: 400px;
            overflow: hidden;
        }
        .chart-container-div {
            min-height: 400px; /* Keep this height */
            width: 100%; /* Keep width 100% */
            flex-grow: 1; /* Allow it to grow in flex container */
            display: flex; /* Keep flex display for centering */
            align-items: center; /* Keep centering */
            justify-content: center; /* Keep centering */
            padding: 15px; /* Keep padding */
            box-sizing: border-box; /* Keep box-sizing */
            overflow: hidden; /* Keep overflow hidden */
            /* Ensure no specific Plotly width/height overrides from parent */
            position: relative; /* Add relative positioning if needed for Plotly */
        }


        /* Ratio Bar Styles */
        .ratio-item { margin-bottom: 12px; }
        .ratio-label { display: block; font-weight: 500; margin-bottom: 3px; font-size: 0.9em; color: #4b5563; }
        .ratio-value { display: inline-block; margin-bottom: 5px; font-size: 1.1em; font-weight: 600; color: #1f2937; }
        .ratio-bar-container { background-color: #e5e7eb; border-radius: 4px; overflow: hidden; height: 8px; width: 100%; }
        .ratio-bar { height: 100%; width: 0%; transition: width 0.5s ease-in-out; border-radius: 4px; }
        /* Define colors based on status */
        .ratio-bar.savings-rate { background-color: #ef4444; }
        .ratio-bar.savings-rate.ok { background-color: #f59e0b; }
        .ratio-bar.savings-rate.good { background-color: #10b981; }
        .ratio-bar.emergency-coverage { background-color: #ef4444; }
        .ratio-bar.emergency-coverage.ok { background-color: #f59e0b; }
        .ratio-bar.emergency-coverage.good { background-color: #10b981; }
        .ratio-bar.dti-ratio { background-color: #10b981; }
        .ratio-bar.dti-ratio.warning { background-color: #f59e0b; }
        .ratio-bar.dti-ratio.high { background-color: #ef4444; }

         /* Debt Table Styles */
        #debtsTable {
            width: 100%;
            margin-top: 10px;
            border-collapse: collapse;
            border: 1px solid #d1d5db; /* Add a light outer border */
            border-radius: 8px; /* Optional: soften corners */
            overflow: hidden; /* Helps with border-radius */
        }
        /* Shared styles for headers and data cells */
        #debtsTable th, #debtsTable td {
            padding: 8px 12px; /* Increased padding slightly for better spacing */
            border-bottom: 1px solid #e5e7eb; /* Keep bottom border between rows */
            border-right: 1px solid #e5e7eb; /* Add vertical borders between columns */
            font-size: 0.9em; /* Keep same font size for both headers and data */
            /* Remove default text-align here to control per column/header */
        }
        /* Remove right border from the last column */
        #debtsTable th:last-child,
        #debtsTable td:last-child {
            border-right: none;
        }
        /* Remove bottom border from the last row */
        #debtsTable tbody tr:last-child td {
             border-bottom: none;
        }


        /* Header styles */
        #debtsTable th {
            font-weight: 700; /* Make headers bold */
            color: #374151; /* Set header color */
            background-color: #f9fafb;
            text-align: left; /* Default header alignment (keep this) */
            cursor: pointer; /* Indicate clickable for popups */
        }
        /* Align specific headers right to match data */
         #debtsTable th.balance-header,
         #debtsTable th.min-pmt-header {
             text-align: right;
         }

        /* Data cell default alignment (most columns left, normal weight) */
        #debtsTable td {
            text-align: left;
            font-weight: normal;
        }

        /* Specific data column styling for alignment and bolding (set by JS adding these classes) */
        #debtsTable td.balance-col {
             text-align: right; /* Align Balance data right */
             font-weight: 700; /* Make Balance data bold */
        }
         #debtsTable td.rate-col {
             /* text-align: left; is default td alignment */
             font-weight: 700; /* Make Rate data bold */
         }
         #debtsTable td.min-pmt-col {
             text-align: right; /* Align Min. Payment data right */
             font-weight: 700; /* Make Min. Payment data bold */
         }

        /* Debt Table Styles */
        #debtsTable { /* ... existing styles ... */ }
        #debtsTable th, #debtsTable td { /* ... existing styles ... */ }
        #debtsTable th {
            font-weight: 500;
            color: #6b7280;
            background-color: #f9fafb;
            text-align: left; /* Default header alignment (keep this) */
            cursor: pointer;
        }
        /* --- ADD THESE NEW RULES --- */
        #debtsTable th.balance-header {
            text-align: right; /* Align Balance header right */
        }
        #debtsTable th.min-pmt-header {
            text-align: right; /* Align Min. Pmt header right */
        }
        /* --- END NEW RULES --- */
        #debtsTable tr:last-child td { /* ... existing styles ... */ }
        #debtsTable td { /* ... existing styles ... */ }
        #debtsTable td.balance-col { /* ... existing styles ... */ }
        #debtsTable td.rate-col { /* ... existing styles ... */ }
        #debtsTable td.min-pmt-col { /* ... existing styles ... */ }

        /* Progress Bar Styles */
        .progress-bar-container { background-color: #e5e7eb; border-radius: 6px; overflow: hidden; height: 20px; margin-top: 5px; margin-bottom: 10px; }
        .progress-bar { background-color: #4f46e5; height: 100%; width: 0%; transition: width 0.5s ease-in-out; text-align: center; color: white; font-size: 0.8em; line-height: 20px; font-weight: 500; }
        .goal-status { font-weight: 500; color: #1f2937; }

        /* Recommendations List Styles */
        #recommendationsList { list-style: none; padding-left: 0; margin-top: 10px; }
        #recommendationsList li { margin-bottom: 10px; line-height: 1.6; font-family: 'Inter', sans-serif; font-size: 0.95em; padding-left: 1.5em; position: relative; }
        #recommendationsList li::before { content: '✓'; color: #10b981; position: absolute; left: 0; font-weight: bold; }
        #recommendationsList li.warning::before { content: '!'; color: #f59e0b; }
        #recommendationsList li.critical::before { content: '!!'; color: #ef4444; }

        /* Modals */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); padding-top: 60px; }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 25px; border: 1px solid #888; width: 80%; max-width: 700px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); }
        .close-button { color: #aaa; float: right; font-size: 32px; line-height: 1; font-weight: bold; cursor: pointer; }
        .close-button:hover, .close-button:focus { color: black; text-decoration: none; }
        #driveFileList a { cursor: pointer; color: #4f46e5; text-decoration: underline; }
         #driveFileList a:hover { text-decoration: none; }


        /* Loading / Error / Initial Messages */
        #loadingSpinner, #errorMessage {
             display: none;
             position: fixed;
             top: 0; left: 0;
             width: 100%; height: 100%;
             z-index: 1050;
             background-color: rgba(255, 255, 255, 0.95);
             align-items: center;
             justify-content: center;
             padding: 1rem;
        }
         #errorMessage > div {
             background-color: #fee2e2;
             border: 1px solid #f87171;
             color: #b91c1c;
             padding: 1.5rem;
             border-radius: 0.5rem;
             max-width: 600px;
             box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
             text-align: center;
         }
         #errorMessage h3 { color: #991b1b; }
         #debugInfo {
             margin-top: 1rem; margin-bottom: 1rem;
             max-height: 200px; overflow-y: auto;
             text-align: left; background-color: #f3f4f6;
             padding: 0.75rem; border-radius: 0.375rem;
             border: 1px solid #d1d5db;
             font-size: 0.75rem;
             line-height: 1.2;
             color: #4b5563;
             white-space: pre-wrap;
             word-break: break-all;
         }
         #debugInfo strong { color: #1f2937; }
         #errorMessage button {
             background-color: #dc2626;
             color: white; padding: 0.5rem 1rem;
             border: none; border-radius: 0.375rem; cursor: pointer;
             font-size: 0.875rem; margin: 0 0.5rem;
             transition: background-color 0.2s;
         }
          #errorMessage button:hover { background-color: #b91c1c; }
          #errorMessage button.secondary-button { background-color: #d1d5db; color: #374151; }
          #errorMessage button.secondary-button:hover { background-color: #9ca3af; }

        #initialUploadPrompt { display: none; }
        #initialMessage { display: none; text-align: center; padding: 40px; font-size: 1.2em; color: #555; }
        #mainContent.hidden { display: none; }
        #mainContent { display: none; }

        /* Chat Interface Card */
        #chatInterfaceCard { display: none; }

        /* Chat Styles */
        #chatInterfaceCard { grid-column: 1 / -1; }
        .chat-container {
            display: flex; flex-direction: column; height: 550px;
            border: 1px solid #d1d5db; border-radius: 10px; overflow: hidden;
            background-color: #ffffff; box-shadow: inset 0 2px 4px rgba(0,0,0,0.03);
        }
        .chat-history {
            flex-grow: 1; padding: 1.5rem; overflow-y: auto;
            scrollbar-width: thin; scrollbar-color: #d1d5db transparent;
        }
        .chat-history::-webkit-scrollbar { width: 8px; }
        .chat-history::-webkit-scrollbar-track { background: transparent; }
        .chat-history::-webkit-scrollbar-thumb { background-color: #d1d5db; border-radius: 10px; border: 2px solid transparent; background-clip: content-box; }
        .chat-history::-webkit-scrollbar-thumb:hover { background-color: #9ca3af; }

        .chat-message { margin-bottom: 1.25rem; line-height: 1.6; display: flex; }
        .chat-message.user { justify-content: flex-end; }
        .chat-message.assistant { justify-content: flex-start; }
        .message-bubble {
             border-radius: 18px; padding: 0.8rem 1.1rem; max-width: 75%;
             box-shadow: 0 2px 4px rgba(0,0,0,0.05); word-wrap: break-word;
        }
        .chat-message.user .message-bubble {
            background: linear-gradient(135deg, #4f46e5 0%, #6366f1 100%); color: white;
            border-radius: 18px 18px 4px 18px;
        }
        .chat-message.assistant .message-bubble {
            background-color: #eef2ff; color: #374151;
            border: 1px solid #e0e7ff; border-radius: 18px 18px 18px 4px;
        }
        .chat-message.system .message-bubble {
            background-color: #f3f4f6; color: #6b7280; font-size: 0.85em;
            text-align: center; max-width: 100%; border-radius: 8px;
            padding: 0.5rem 1rem; border: 1px solid #e5e7eb;
            box-shadow: none;
        }
        .chat-message.system { justify-content: center; margin: 0.5rem 0; }

        .message-sender { display: none; }

        /* Chat Status & Input */
        .chat-status {
            font-size: 0.8rem; color: #6b7280; padding: 0.5rem 1rem;
            text-align: center; height: 25px;
            background-color: #f9fafb; border-top: 1px solid #e5e7eb;
            overflow: hidden; white-space: nowrap; text-overflow: ellipsis;
        }
        .typing-indicator { display: inline-block; }
        .typing-indicator span {
            height: 8px; width: 8px; margin: 0 2px;
            background-color: #9ca3af; border-radius: 50%;
            display: inline-block;
            animation: typing 1.4s infinite ease-in-out both;
        }
        .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
        .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }
        @keyframes typing {
            0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); }
        }

        .chat-input-area {
            border-top: 1px solid #e5e7eb; padding: 0.75rem 1rem;
            background-color: #f9fafb; display: flex; align-items: center; gap: 0.75rem;
        }
        .chat-input-area textarea {
            flex-grow: 1;
            padding: 0.7rem 1rem;
            border: 1px solid #d1d5db;
            border-radius: 20px;
            resize: none; /* Prevent manual resizing */
            font-size: 0.95rem;
            line-height: 1.4;
            height: 88px; /* Set the initial height */
            min-height: 88px; /* Add minimum height to prevent it from shrinking below this */
            max-height: 120px; /* Keep the max height from JS auto-grow */
            background-color: white;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            outline: none;
            overflow-y: auto; /* Ensure scrollbar appears if text exceeds height */
        }
        .chat-input-area textarea:focus {
            border-color: #4f46e5; box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
        }
        .chat-input-area button {
            padding: 0.6rem 1rem; white-space: nowrap; flex-shrink: 0;
            border-radius: 20px;
            background-color: #4f46e5; color: white; border: none; cursor: pointer;
            transition: background-color 0.2s;
            display: flex; align-items: center; justify-content: center;
        }
        .chat-input-area button:hover { background-color: #4338ca; }
        .chat-input-area button:disabled { background-color: #a5b4fc; cursor: not-allowed; }
        .chat-input-area button svg { width: 1.25rem; height: 1.25rem; }
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0; }

        /* Responsive */
        @media (max-width: 768px) {
            header { flex-direction: column; align-items: flex-start; }
            header h1 { margin-top: 10px; font-size: 1.8em; }
             /* Adjust margin for buttons on smaller screens */
             /*header button { margin-left: 0; margin-top: 10px; margin-right: 10px; }*/
             /* Remove right margin from the last button in the header */
            /*header button:last-child { margin-right: 0; }*/

            /* Ensure button container wraps */
             header div {
                 display: flex;
                 flex-wrap: wrap;
                 gap: 10px; /* Space between buttons */
                 margin-top: 10px;
                 width: 100%; /* Ensure container takes full width */
             }
             header button {
                 margin: 0; /* Remove individual margins */
                 flex-grow: 1; /* Allow buttons to share space */
                 min-width: 120px; /* Minimum width for buttons */
             }
             #signedInUserDisplay {
                 order: -1; /* Place above buttons */
                 width: 100%;
                 text-align: center;
                 margin-bottom: 5px;
                 margin-right: 0; /* Remove right margin */
             }


            .grid-container { grid-template-columns: 1fr; }
            .main-container { margin: 1rem; padding: 1rem; }
        }

        /* ADD THIS NEW MEDIA QUERY FOR EVEN SMALLER SCREENS */
        @media (max-width: 500px) { /* Target screens/iframes up to 500px wide */
            /* Adjust Grid Minimum Width */
            .grid-container {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* Lower the minimum width */
                gap: 15px; /* Reduce gap slightly */
            }
             /* Further adjust header layout on very small screens */
             header {
                flex-direction: column;
                align-items: stretch; /* Stretch items */
            }
             header img { margin-right: 0; margin-bottom: 10px; max-width: 100%; height: auto; }
             header h1 { margin-right: 0; text-align: center; font-size: 1.6em; }
             /* Make buttons stack or distribute space */
             header div {
                 display: flex;
                 flex-wrap: wrap; /* Allow buttons container to wrap */
                 justify-content: center; /* Center buttons if they wrap */
                 gap: 10px; /* Space between wrapped buttons */
                 width: 100%; /* Ensure container takes full width */
                 margin-top: 10px;
             }
             header button { margin: 0; flex-grow: 1; min-width: 100px; padding: 0.5rem 1rem; font-size: 0.8em; } /* Allow buttons to grow slightly */
             #signedInUserDisplay {
                 order: -1; /* Place above buttons */
                 width: 100%;
                 text-align: center;
                 margin-bottom: 5px;
                 margin-right: 0; /* Remove right margin */
             }
        }
    </style>
</head>

<body>
    <pre id="embeddedPsrData" style="display: none;">/* EMBEDDED_JSON_DATA_HERE */</pre>

    <div id="loadingSpinner" style="display: none;">
        <div class="text-center">
            <svg class="animate-spin h-10 w-10 text-indigo-600 mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="text-gray-700 text-lg">Loading your financial dashboard...</p>
        </div>
    </div>

    <div id="errorMessage" style="display: none;">
        <div>
            <h3 class="font-bold text-xl mb-3 header-font">Error Loading Dashboard</h3>
            <p id="errorText" class="mb-4">An error occurred.</p>
            <div id="debugInfo" class="mb-4 text-xs">Debug info will appear here...</div>
            <div class="flex justify-center space-x-3 mt-4">
                <button id="retryButton" class="action-button">Retry Loading</button>
                <button id="manualEntryButton" class="secondary-button">Use Demo Data</button>
            </div>
        </div>
    </div>

     <div id="initialUploadPrompt" style="display: none; text-align: center; padding: 60px 20px;">
         <div class="main-container" style="max-width: 600px; margin: auto;">
             <h2 class="header-font text-2xl mb-4 text-gray-700">Welcome to SmartWealth Navigator</h2>
             <p class="text-gray-600 mb-6">
                 📂 Please upload your saved PSR file to view your dashboard.
             </p>
             <button id="initialUploadButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-200 ease-in-out">
                 Upload PSR
             </button>
             <p class="text-sm text-gray-500 mt-4">
                 (If you haven't generated a report yet, please complete the initial form first.)
             </p>
         </div>
     </div>

    <div id="initialMessage" style="display: none;">
        Upload a PSR JSON file or parameter to view your dashboard.
    </div>

    <div id="mainContent" class="main-container" style="display: none;">
        <header>
            <img src="https://static.wixstatic.com/media/c3283f_a9271d9818ba414994d98950da749489~mv2.jpg" alt="SmartWealth Navigator Logo">
            <h1>SmartWealth Navigator</h1>
             <!-- Button Container for better wrapping on small screens -->
            <div>
                 <!-- Display area for signed-in user name -->
                 <span id="signedInUserDisplay" style="display: none;"></span>
                 <!-- Keep fileInput hidden -->
                 <input type="file" id="fileInput" accept=".json" style="display: none;">

                 <!-- Google Authentication Buttons -->
                 <button id="googleSignInButton" style="display: none;">Sign in with Google</button>
                 <button id="googleSignOutButton" style="display: none;">Sign Out</button>

                 <!-- Drive File Management Buttons (initially hidden, managed by JS) -->
                 <button id="loadFromDriveButton" style="display: none;">Load from Drive</button>
                 <button id="saveToDriveButton" style="display: none;">Save to Drive</button>

                 <!-- Optional: Keep a local download button as fallback/alternative -->
                 <button id="downloadLocalButton" style="display: none;">Download Local PSR</button>
            </div>
        </header>

        <div class="grid-container">
            <div class="dashboard-card">
                <h3 class="card-header">Quick Summary</h3>
                <div class="card-content">
                    <p><strong>User:</strong> <span id="userName">N/A</span></p>
                    <p><strong>Age:</strong> <span id="age">N/A</span></p>
                    <p><strong>Total Monthly Income:</strong> <span id="totalIncome">N/A</span></p>
                    <p><strong>Total Monthly Expenses:</strong> <span id="totalExpenses">N/A</span></p>
                    <p><strong>Monthly Net Flow:</strong> <span id="netFlow">N/A</span></p>
                </div>
            </div>
            <div class="dashboard-card" id="ratiosCard">
                <h3 class="card-header">Key Financial Ratios</h3>
                <div class="card-content">
                    <div class="ratio-item">
                        <span class="ratio-label cursor-pointer" data-desc="Income kept, not spent.">Savings Rate</span>
                        <span class="ratio-value" id="savingsRateValue">N/A</span>
                        <div class="ratio-bar-container"><div class="ratio-bar savings-rate" id="savingsRateBar"></div></div>
                    </div>
                    <div class="ratio-item">
                        <span class="ratio-label cursor-pointer" data-desc="Months cash covers bills.">Emergency Fund Coverage</span>
                        <span class="ratio-value" id="emergencyCoverageValue">N/A</span>
                        <div class="ratio-bar-container"><div class="ratio-bar emergency-coverage" id="emergencyCoverageBar"></div></div>
                    </div>
                    <div class="ratio-item">
                        <span class="ratio-label cursor-pointer" data-desc="Income used for debts.">Debt to Income (DTI)</span>
                        <span class="ratio-value" id="dtiRatioValue">N/A</span>
                        <div class="ratio-bar-container"><div class="ratio-bar dti-ratio" id="dtiRatioBar"></div></div>
                        <p style="font-size: 0.8em; color: #666;">(Using min. payments)</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="grid-container">
            <div class="dashboard-card">
                <h3 class="card-header">Savings Overview</h3>
                <div class="card-content">
                    <p><strong>Emergency Savings:</strong> <span id="emergencySavings">N/A</span></p>
                    <p><strong>General Savings:</strong> <span id="currentSavings">N/A</span></p>
                    <p><strong>Retirement Fund:</strong> <span id="retirementFund">N/A</span></p>
                </div>
            </div>
            <div class="dashboard-card" id="goalsCard">
                <h3 class="card-header cursor-pointer" data-desc="Distance to rainy day target.">Savings Goals Progress</h3>
                <div class="card-content">
                    <div id="emergencyGoalDisplay" style="display: none;">
                        <p><strong>Emergency Fund Goal:</strong> <span class="goal-status">N/A</span></p>
                        <div class="progress-bar-container"><div class="progress-bar" id="emergencyProgressBar"></div></div>
                    </div>
                    <div id="purchaseGoalDisplay" style="margin-top: 15px; display: none;">
                        <p><strong data-desc="Saved toward big buy.">Purchase Goal (<span id="purchaseGoalName">N/A</span>):</strong> <span class="goal-status">N/A</span></p>
                        <div class="progress-bar-container"><div class="progress-bar" id="purchaseProgressBar"></div></div>
                    </div>
                    <p id="noGoalsMessage" style="display: none;" class="text-gray-500 italic">
                        No specific savings goals identified.
                    </p>
                </div>
            </div>
        </div>

        <div class="grid-container">
            <div class="dashboard-card chart-card">
                <h3 class="card-header cursor-pointer" data-desc="Where income comes from.">Income Breakdown</h3>
                <div id="incomeChart" class="chart-container-div">
                    <p class="text-center text-gray-500 pt-10"></p>
                </div>
            </div>
            <div class="dashboard-card chart-card">
                <h3 class="card-header cursor-pointer" data-desc="Where money goes.">Expense Breakdown</h3>
                <div id="expenseChart" class="chart-container-div">
                    <p class="text-center text-gray-500 pt-10"></p>
                </div>
            </div>
        </div>

        <div class="grid-container">
            <div class="dashboard-card">
                <h3 class="card-header">Recommendations</h3>
                <div class="card-content">
                    <ul id="recommendationsList">
                        <li>Loading recommendations...</li>
                    </ul>
                </div>
            </div>
                                   <div class="dashboard-card">
                <h3 class="card-header">AI Analysis Summary</h3>
                <div class="card-content">
                    <div id="aiAnalysis" class="prose prose-sm max-w-none mb-4" style="white-space: pre-wrap;">
                        Loading analysis...
                    </div>
                    <button onclick="openModal('progressModal')" class="text-indigo-600 hover:underline text-sm font-medium">
                        View Full Progress History
                    </button>
                    <button id="saveSummaryBtn" class="bg-indigo-600 text-white text-sm font-medium px-3 py-1 rounded mt-2">
                        Save Summary to Report
                    </button>
                </div>
            </div>
        </div>

        <div class="grid-container">
            <div class="dashboard-card" id="debtsCard">
                <h3 class="card-header">Debt Overview</h3>
                <div class="card-content overflow-x-auto">
                    <table id="debtsTable">
                      <thead>
                            <tr>
                                <th>Type</th>
                                <th class="balance-header" data-desc="Total amount currently owed on this debt.">Balance</th>
                                <th data-desc="Annual interest rate for this debt.">Rate (%)</th>
                                <th class="min-pmt-header" data-desc="Minimum monthly payment required for this debt.">Min. Pmt</th>
                            </tr>
                        </thead>

                        <tbody>
                            <tr><td colspan="4" class="text-center p-4 text-gray-500">Loading debt data...</td></tr>
                        </tbody>
                    </table>
                    <p style="margin-top: 10px;"><strong data-desc="All debts owed.">Total Debt Balance:</strong> <span id="totalDebtBalance" class="font-semibold">N/A</span></p>
                    <p><strong data-desc="Minimum due monthly.">Total Min. Payments:</strong> <span id="totalMinPayments" class="font-semibold">N/A</span></p>
                </div>
            </div>
            <div class="dashboard-card">
                <h3 class="card-header">Financial Tools & Goals</h3>
                <div class="card-content">
                    <p><strong>Financial Tools:</strong> <span id="financialTools">N/A</span></p>
                    <p><strong>Challenges:</strong> <span id="challenges">N/A</span></p>
                    <p><strong>Upcoming Purchase Goal Detail:</strong> <span id="purchaseGoals">N/A</span></p>
                </div>
            </div>
        </div>

           <section id="chatInterfaceCard" class="dashboard-card" style="display: none;">
            <!-- MODIFIED HEADER WITH FLEX AND BUTTON -->
            <h3 class="card-header flex items-center justify-between">
                <span>Ask SmartWealth AI</span>
                <button id="generateAnalysisBtn" class="bg-green-600 hover:bg-green-700 text-white text-sm font-medium px-3 py-1 rounded">
                     Generate New Analysis
                </button>
            </h3>
            <!-- END MODIFIED HEADER -->
            <div class="chat-container">
                <div class="chat-history" id="chatHistory">
                    </div>
                <div class="chat-status flex justify-between items-center px-4" id="chatStatusContainer">
                 <span>
                     Tier: <strong id="chatTierDisplay">-</strong> |
                     Model: <span id="chatModelDisplay" class="text-xs">-</span>
                 </span>
                 <span id="chatThinkingIndicator" style="display: none; margin-left: auto; margin-right: auto;">
                     <div class="typing-indicator"><span style="background-color: #4f46e5;"></span><span style="background-color: #4f46e5;"></span><span style="background-color: #4f46e5;"></span></div> Thinking...
                 </span>
                 <span class="ml-auto"> Usage: <strong id="chatUsageDisplay">- / -</strong>
                 </span>
            </div>
            <!-- THIS IS THE CHAT INPUT AREA -->
            <div class="chat-input-area">
                <textarea id="chatInput" placeholder="Ask about your finances..." rows="1" disabled></textarea>
                <button id="chatSendButton" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">
                        <path d="M3.105 3.105a1.5 1.5 0 011.995-.04l8 4a1.5 1.5 0 010 2.87l-8 4a1.5 1.5 0 01-1.995-.04L1.6 13.89a1.5 1.5 0 01-.04-1.995l3-4a1.5 1.5 0 010-1.79l-3-4a1.5 1.5 0 01.04-1.995l1.5-1.5z" />
                    </svg>
                    <span class="sr-only">Send</span>
                </button>
            </div>
            <!-- END OF CHAT INPUT AREA -->
            </div> <!-- This closes the chat-container div -->
        </section>

        <footer class="text-center text-gray-500 text-sm py-6 mt-4 border-t border-gray-200">
            <p>SmartWealth Navigator © 2025 | Built by Socialeap™️</p>
            <p>Consult with a qualified financial advisor for personalized advice.</p>
        </footer>
    </div>

    <div id="progressModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('progressModal')">&times;</span>
            <h2>User Progress History</h2>
            <div id="progressContent" style="white-space: pre-wrap;">Loading history...</div>
        </div>
    </div>

    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('infoModal')">&times;</span>
            <p id="infoModalText" style="margin:0;"></p>
        </div>
    </div>

    <!-- Modal for listing files from Drive -->
    <div id="driveLoadModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('driveLoadModal')">&times;</span>
            <h2>Select File to Load</h2>
            <div id="driveFileList">Loading files...</div>
            <p id="driveLoadError" style="color: red;"></p>
        </div>
    </div>

<script>
    // --- Globals ---
    let dashboardData = {}; // Holds the main data object
    let chatMessages = []; // Holds chat history for API calls
    // Note: CHAT_MODEL is effectively determined by the backend based on tier,
    // but defining it here might be useful for frontend logic if needed later.
    // For now, rely on backend.
    const CHAT_MODEL = 'determined_by_backend'; // Placeholder

    const plotlyConfig = {
        displaylogo: false,
        responsive: true, // Added responsive config
        modeBarButtonsToRemove: ['sendDataToCloud', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale2d', 'resetScale2d', 'hoverClosestPie', 'toggleSpikelines', 'hoverCompareCartesian']
    };

    let currentUserId = null; // User ID derived from XTL parameter or loaded file
    let effectiveTier = 'basic'; // Tier derived from XTL parameter or loaded file
    let initialUsageInfo = null; // To store fetched usage/limit info for initial UI setup

    // --- Supabase Client (CONFIGURE THESE) ---
    // **IMPORTANT:** Ensure these are correct and your Supabase project is configured
    // with RLS policies that allow anon key reads on 'SWN_Users' (using the 'id' column matching XTL)
    // and service key access in your Edge Function.
    const SUPABASE_URL = 'https://tfnwwpksieluzvxqdiiq.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRmbnd3cGtzaWVsdXp2eHFkaWlxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ1ODQ3MjgsImV4cCI6MjA2MDE2MDcyOH0.xbtjiQ65vCggjj35qtlCZ0S5mJa4muSZcHXhaU4qvrE';
    let supabase = null; // Initialize later

    // --- Google Drive Integration Constants ---
    const GOOGLE_CLIENT_ID = '351536963710-k1tqdl2v9ddnnb1hgda4r4gm40kpu2sa.apps.googleusercontent.com'; // Your Google Cloud Client ID
    // Scopes needed: Accessing userinfo (for display), reading/writing Drive files created by this app
    // 'drive.file' limits access to files created/opened by this app.
    const GOOGLE_SCOPES = 'https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/drive.file';
    const PSR_MIME_TYPE = 'application/json'; // MIME type for your PSR file
    const PSR_FOLDER_NAME = 'SmartWealth Navigator Reports'; // Name of the folder to use in Drive
    const PSR_FILE_NAME = 'my_financial_report.json'; // Standard file name to use

    // --- Google Drive Related Globals ---
    let googleAccessToken = null; // Store the current Google Access Token
    let googleTokenClient = null; // Store the GIS token client instance
    let googleUser = null; // Store basic user info (name, etc.)
    let driveFolderId = null; // Store the ID of the designated Drive folder

    // --- Cached DOM Elements ---
    // Declare variables here, cache in DOMContentLoaded
    let loadingSpinner, errorMessageElement, mainContentElement, initialMessageElement, errorTextElement, debugInfoElement, fileInput, initialUploadPrompt, chatInterfaceCardElement;
    let googleSignInButton, googleSignOutButton, loadFromDriveButton, saveToDriveButton, downloadLocalButton, signedInUserDisplayElement;

    // --- Utility Functions ---
    function getSafe(fn, defaultVal = 'N/A') {
        try {
            const value = fn();
            // More robust check for empty/null/undefined/NaN/Infinity
            if (value === null || value === undefined || String(value).trim() === '' || (typeof value === 'number' && !isFinite(value))) {
                 return defaultVal;
            }
            return value;
        } catch (e) {
            // console.warn("getSafe caught error:", e.message); // Log getSafe errors if needed
            return defaultVal;
        }
    }

    function formatCurrency(value, hideNA = false) {
        const number = Number(getSafe(() => value, NaN)); // Use getSafe internally
        if (isNaN(number) || !isFinite(number)) return hideNA ? '' : 'N/A';
        // Use maximumFractionDigits: 2 for cents unless specified otherwise
        return number.toLocaleString('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 0, maximumFractionDigits: 2 });
    }

    function formatPercentage(value, decimals = 1) {
         const number = Number(getSafe(() => value, NaN)); // Use getSafe internally
        if (isNaN(number) || !isFinite(number)) return 'N/A';
        return number.toLocaleString(undefined, { style: 'percent', minimumFractionDigits: decimals, maximumFractionDigits: decimals });
    }

    function updateElementText(id, value, formatter) {
        const element = document.getElementById(id);
        if (element) {
            try {
                const formattedValue = formatter ? formatter(value) : (value !== null && value !== undefined && String(value).trim() !== '' ? String(value) : 'N/A');
                element.textContent = formattedValue;
            } catch (e) {
                console.error(`Error formatting/updating text for element ID ${id}:`, e);
                element.textContent = 'Error'; // Indicate error on the UI
            }
        } // else { console.warn(`Element with ID ${id} not found for text update.`); } // Keep console warning optional
    }

    function updateElementHTML(id, value) {
        const element = document.getElementById(id);
        if (element) {
             try {
                // Use innerHTML carefully - ensure value is trusted or sanitized
                element.innerHTML = value !== null && value !== undefined && String(value).trim() !== '' ? String(value) : '';
            } catch (e) {
                 console.error(`Error updating HTML for element ID ${id}:`, e);
                 element.textContent = 'Error'; // Fallback to text on error
            }
        } // else { console.warn(`Element with ID ${id} not found for HTML update.`); }
    }

    // Helper function to parse URL parameters
    function parseUrlParams() {
        console.log("Parsing URL parameters...");
        try {
            const params = new URLSearchParams(window.location.search);
             // Check for data=null parameter (special case from Jotform redirect)
            if (params.has('data') && params.get('data') === 'null') {
                console.warn("URL parameter 'data=null' detected. Showing initial upload prompt.");
                // This case is handled by the main DOMContentLoaded flow after parsing
                return null; // Indicates special state, not lack of params
            }
             // Check for any parameters indicating data is present
            if (Array.from(params.keys()).length > 0) {
                 console.log("URL parameters found and parsed.");
                 return params;
            } else {
                 console.log("No URL parameters found.");
                 return new URLSearchParams(); // Return empty params object
            }

        } catch (e) {
            console.error("Error parsing URL parameters:", e);
            // Return empty params or re-throw? Let's return empty to allow auth check
            return new URLSearchParams(); // Return empty params on error
        }
    }

    // Function to parse all financial data from URL parameters
    function parseDataFromUrlParams(params) {
        console.log("Attempting to parse financial data from URL params...");
        if (!params || typeof params.get !== 'function' || Array.from(params.keys()).length === 0) {
             console.log("No valid URL params object or no params found to parse data from.");
             return null; // Return null if no params are present
        }

        // Helper function to get and decode parameter values
        const getParam = (key) => {
            if (!params.has(key)) return null;
            const rawValue = params.get(key);
            if (rawValue === null || rawValue === undefined) return null;
            try {
                // Replace '+' with space before decoding, then decode
                return decodeURIComponent(rawValue.replace(/\+/g, ' ')).trim();
            } catch (e) {
                console.warn(`Error decoding parameter ${key}:`, e);
                return rawValue.trim(); // Return raw value if decode fails
            }
        };

        // Helper function to parse numeric values, returns defaultValue on error/empty
        const parseNumeric = (key, defaultValue = 0) => {
             const value = getParam(key);
            if (value === null || value === undefined || value === '') return defaultValue;
            // Remove currency symbols, commas, etc. before parsing
            const cleaned = String(value).replace(/[^0-9.-]+/g, '');
            const number = parseFloat(cleaned);
             if (isNaN(number) || !isFinite(number)) {
                 console.warn(`Could not parse numeric value for key "${key}" from "${value}". Using default ${defaultValue}.`);
                 return defaultValue;
             }
            return number;
        };

        // Log key parameters for debugging
        console.log("Debugging URL parameter parsing (first few):");
        console.log("  userName:", getParam('userName'));
        console.log("  age:", getParam('age'));
        console.log("  mainJobIncome:", getParam('mainJobIncome'));
        console.log("  housing:", getParam('housing'));
        console.log("  xtl:", getParam('xtl')); // Log xtl for debug
        console.log("  userID:", getParam('userID')); // Log userID for debug (Note: XTL is preferred for auth)


        // Construct and return the data object based on URL parameters
        // Use getSafe or default values aggressively here
        const parsedData = {
            userInput: {
                personalInfo: {
                    userName: getParam('userName'), // Keep as string
                    age: parseNumeric('age')
                },
                income: {
                    mainJobIncome: parseNumeric('mainJobIncome'),
                    secondJob: parseNumeric('secondJobIncome'),
                    otherIncome: parseNumeric('otherIncome')
                },
                expenses: {
                    housing: parseNumeric('housing'),
                    transportation: parseNumeric('transportation'),
                    utilities: parseNumeric('utilities'),
                    groceriesEssentials: parseNumeric('groceriesessentials'),
                    insurance: parseNumeric('insurance'),
                    medical: parseNumeric('medical'),
                    care: parseNumeric('care'),
                    subscriptions: parseNumeric('subscriptions'),
                    taxes: parseNumeric('taxes')
                },
                savings: {
                    emergency: parseNumeric('emergencySavings'),
                    savings: parseNumeric('currentSavings'), // Assuming 'savings' is general savings
                    retirement: parseNumeric('retirementFund'),
                    emergencyFundTarget: parseNumeric('emergencyFundTarget'), // Optional explicit target
                    monthlySavingsGoal: parseNumeric('monthlySavingsGoal') // Optional explicit monthly goal
                },
                debts: [], // Debts will be populated below
                financials: {
                    financialTools: getParam('financialTools'),
                    challenges: getParam('challenges'),
                    upcomingPurchase: getParam('upcomingPurchases')
                }
            },
            aiOutput: {
                analysis: getParam('aiAnalysis') || 'Analysis not available.',
                recommendations: getParam('recommendations') || 'Recommendations not available.',
                userProgress: getParam('userProgressHistory') || 'No progress history available.'
            },
             // Add metadata including the parsed user ID and tier for saving/loading
             // Use the user ID and tier derived from XTL parsing, if successful.
             // If XTL parsing failed, currentUserId and effectiveTier will be null/basic,
             // which is fine - they might be populated later from a loaded file.
            metadata: {
                 userId: currentUserId,
                 tier: effectiveTier,
                 source: 'url_params' // Indicate data source
            },
             // Add chatMessages array to the data structure for saving/loading
            chatHistory: [] // Initialize empty, will be populated if chat is used
        };

        // Populate Debts Array - Check for existence and parse
        try {
             const creditCardDebt = parseNumeric('creditCardDebt');
             if (creditCardDebt > 0) {
                 parsedData.userInput.debts.push({
                     type: "Credit Card",
                     balance: creditCardDebt,
                     interestRate: parseNumeric('creditCardRate', 22.5), // Default CC rate
                     minPayment: parseNumeric('creditCardMinPayment', Math.max(creditCardDebt * 0.03, 25)) // Default min payment logic
                 });
                 //console.log("Added Credit Card Debt from param:", creditCardDebt);
             }

             const bankLoans = parseNumeric('bankLoans');
             if (bankLoans > 0) {
                 parsedData.userInput.debts.push({
                     type: "Bank Loans",
                     balance: bankLoans,
                     interestRate: parseNumeric('bankLoanRate', 6.5), // Default Bank Loan rate
                     minPayment: parseNumeric('bankLoanMinPayment', Math.max(bankLoans * 0.015, 50)) // Default min payment logic
                 });
                 //console.log("Added Bank Loans from param:", bankLoans);
             }

             const studentLoans = parseNumeric('studentLoanDebt');
             if (studentLoans > 0) {
                 parsedData.userInput.debts.push({
                     type: "Student Loans",
                     balance: studentLoans,
                     interestRate: parseNumeric('studentLoanRate', 5.5), // Default Student Loan rate
                     minPayment: parseNumeric('studentLoanMinPayment', Math.max(studentLoans * 0.01, 50)) // Default min payment logic
                 });
                 //console.log("Added Student Loans from param:", studentLoans);
             }

             const carLoans = parseNumeric('carLoanBalance');
             if (carLoans > 0) {
                 parsedData.userInput.debts.push({
                     type: "Car Loan",
                     balance: carLoans,
                     interestRate: parseNumeric('carLoanRate', 6.0), // Default Car Loan rate
                     minPayment: parseNumeric('carLoanMinPayment', Math.max(carLoans * 0.015, 100)) // Default min payment logic
                 });
                 //console.log("Added Car Loan from param:", carLoans);
             }
        } catch (e) {
             console.error("Error populating debt array from params:", e);
             // Continue with potentially empty or partially filled debts array
        }


        console.log("Parsed data object created from URL params:", parsedData);
        return parsedData;
    }

    // --- Debugging & Error Handling ---
    function debugURLParameters() {
        if (!debugInfoElement) return; // Check if element exists
        const params = new URLSearchParams(window.location.search);
        let paramsText = '<strong>URL Params:</strong><br>';
        if (params.toString() === '') {
            paramsText += '<span style="color:gray;">None</span><br>';
        } else {
            paramsText += '<table style="width:100%; font-size:10px; border-collapse: collapse;"><thead><tr style="background:#eee;"><th style="border:1px solid #ccc; padding: 2px;">Param</th><th style="border:1px solid #ccc; padding: 2px;">Value</th></tr></thead><tbody>';
            for (const [key, value] of params.entries()) {
                // Truncate long values for display in debug box
                const displayValue = (value && value.length > 150) ? value.substring(0, 150) + '...' : (value || '<i style="color:gray;">(empty)</i>');
                paramsText += `<tr><td style="border:1px solid #ccc; padding: 2px; word-break:break-all;">${key}</td><td style="border:1px solid #ccc; padding: 2px; word-break:break-all;">${displayValue}</td></tr>`;
            }
            paramsText += '</tbody></table>';
        }
        // Append to existing debug info safely
        const currentDebugHTML = debugInfoElement.innerHTML;
        // Add params at the top, remove old params if present
        debugInfoElement.innerHTML = paramsText + '<hr style="margin: 5px 0;">' + currentDebugHTML.replace(/^<strong>URL Params:.*?<hr style="margin: 5px 0;">/s, '');
    }

    function handleError(message, error, isAccessError = false) {
        console.error("HANDLE ERROR TRIGGERED:", message, error);

        // Ensure elements exist before manipulating (using cached elements)
        errorTextElement = errorTextElement || document.getElementById('errorText'); // Fallback if cache failed
        debugInfoElement = debugInfoElement || document.getElementById('debugInfo');
        errorMessageElement = errorMessageElement || document.getElementById('errorMessage'); // Fallback

        // Populate error details
        if (errorTextElement) {
            errorTextElement.textContent = `${message}. See details below.`;
        } else {
            console.error("Error text element not found!");
        }
        if (debugInfoElement) {
            debugInfoElement.innerHTML = ''; // Clear previous debug info first
            debugURLParameters(); // Add URL parameters FIRST
            debugInfoElement.innerHTML += `<br><strong>Error Type:</strong> ${getSafe(() => error.name, 'N/A')}`;
            debugInfoElement.innerHTML += `<br><strong>Error Message:</strong><br><span style="color:red;">${getSafe(() => error.message, 'Unknown error')}</span>`;
            if (error?.stack) {
                // Make stack trace more readable
                debugInfoElement.innerHTML += `<br><strong>Stack Trace:</strong><br><code style="font-size:10px; white-space: pre-wrap; display: block; line-height:1.2;">${error.stack.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code>`;
            }
        } else {
            console.error("Debug info element not found!");
        }

        // Manage UI visibility
        hideAllMainContentAreas(); // Hide everything first

        if (errorMessageElement) {
            errorMessageElement.style.display = 'flex'; // Use flex for centering
            console.log("Error message shown by handleError.");

             // Adjust retry/demo buttons based on error type if needed
             const retryButton = document.getElementById('retryButton');
             const manualEntryButton = document.getElementById('manualEntryButton');
             if (isAccessError) {
                 if (retryButton) retryButton.style.display = 'none'; // Retry likely won't fix invalid access
                 if (manualEntryButton) manualEntryButton.style.display = 'inline-block'; // Offer demo
             } else {
                 if (retryButton) retryButton.style.display = 'inline-block'; // Offer retry for other errors
                 if (manualEntryButton) manualEntryButton.style.display = 'inline-block'; // Offer demo as alternative
             }

        } else {
            console.error("Error message element not found! Displaying alert fallback.");
            // Fallback alert if the error UI can't be shown
            alert(`Critical Application Error:\n\n${message}\n\nDetails: ${error?.message || 'Unknown error'}`);
        }
        // Disable chat on error
        enableChatInput(false);
        setChatStatus("Error occurred", false);
         if (chatInterfaceCardElement) chatInterfaceCardElement.style.display = 'none'; // Ensure chat is hidden
         // Hide Drive buttons on error
         updateDriveButtonVisibility(false);
    }

    // --- Demo Data ---
    function useDemoData() {
        console.log("Using Demo Data");
         // Ensure error message is hidden before processing
        hideAllMainContentAreas();
        if (loadingSpinner) loadingSpinner.style.display = 'flex'; // Show spinner briefly

        // A more complete demo data structure matching potential real data
        const demoData = {
            userInput: {
                personalInfo: { userName: "Demo User", age: 35 },
                income: { mainJobIncome: 5500, secondJob: 1200, otherIncome: 300 },
                expenses: { housing: 1800, utilities: 250, transportation: 450, groceriesEssentials: 600, insurance: 350, medical: 150, care: 100, subscriptions: 80, taxes: 1100 },
                savings: { emergency: 8000, savings: 15000, retirement: 75000, emergencyFundTarget: 15000, monthlySavingsGoal: 500 },
                debts: [
                    { type: "Credit Card", balance: 4500, interestRate: 22.5, minPayment: 150 },
                    { type: "Student Loan", balance: 25000, interestRate: 5.5, minPayment: 280 },
                    { type: "Car Loan", balance: 12000, interestRate: 6.5, minPayment: 300 }
                ],
                financials: {
                    financialTools: "Budgeting App (YNAB), Credit Monitor (Credit Karma)",
                    challenges: "Saving consistently for down payment, Reducing high-interest CC debt",
                    upcomingPurchase: "#1) House Down Payment, $25000, 24 months" // Example matching regex
                }
            },
            aiOutput: {
                analysis: "Cash flow is positive ($1120/month). Emergency fund covers ~2 months of core expenses (target is 3-6). High DTI ratio (31%) primarily due to student/car loans, but CC debt is high interest. Good retirement savings.",
                recommendations: "- Prioritize paying off the 22.5% interest credit card.\n- Aim to increase emergency fund to $10,000 (3 months expenses).\n- Continue consistent retirement contributions.\n- Review subscription expenses for potential savings.",
                userProgress: "2024-12-01: Initial report generated (Demo Data).\n2025-03-15: Credit card balance reduced by $500. Emergency fund increased by $1000."
            },
             // Add metadata for demo data - use a placeholder user ID
            metadata: {
                 userId: 'demo-user-123',
                 tier: 'basic',
                 source: 'demo_data'
            },
            chatHistory: [
                 { role: 'assistant', content: "Hello! Ask me anything about the financial data shown on your dashboard." }
            ]
        };

        // Use a timeout to simulate loading and ensure spinner is seen briefly
        setTimeout(() => {
            // IMPORTANT: When using demo data, we *reset* the Supabase user context
            currentUserId = demoData.metadata.userId;
            effectiveTier = demoData.metadata.tier;
            chatMessages = demoData.chatHistory; // Load demo chat history
            initialUsageInfo = { // Simulate usage info for demo user
                 usage: 0,
                 limit: (effectiveTier === 'pro' ? 500000 : 15000), // Use realistic limits for demo tier
                 model: (effectiveTier === 'pro' ? 'gpt-4o-mini' : 'gpt-3.5-turbo'), // Use realistic models for demo tier
                 tier: effectiveTier,
                 actualDbTier: 'demo', // Indicate it's demo data
                 lastReset: new Date().toISOString(), // Simulate a recent reset
                 resetDue: false,
                 userFoundInDb: true // Simulate user exists (for chat enablement)
            };

            console.log("Rendering demo data...");
            processAndDisplayData(demoData); // Process the demo data
            // Hide spinner is handled by processAndDisplayData finally block
            // Button visibility updated by processAndDisplayData -> updateDriveButtonVisibility

        }, 500); // Simulate a small delay
    }

    // --- Parse XTL Parameter for Authentication ---
    function parseXtlParameter(params) {
        console.log("Parsing XTL parameter...");
        if (!params || typeof params.get !== 'function') {
             console.warn("No URL params available for XTL parsing.");
             // Do not treat missing params as invalid access here, just no XTL user
             currentUserId = null;
             effectiveTier = 'basic';
             return false; // Indicate failure
        }

        const xtlParam = params.get('xtl');
        let userIdFromXtl = null;
        let tierFromXtl = 'basic'; // Default assumption

        console.log("XTL parameter found:", xtlParam);

        if (xtlParam && xtlParam.length === 21) {
            try {
                // Extract the verification segment (characters 7-11, index 6-10)
                const verificationSegment = xtlParam.substring(6, 11);
                // Extract the user ID segment (characters 12-21, index 11-end)
                const userIdSegment = xtlParam.substring(11);

                console.log("Parsed XTL: verification segment =", verificationSegment, "user ID segment =", userIdSegment);

                // Validate both segments
                if (/^[a-zA-Z0-9]{5}$/.test(verificationSegment) && userIdSegment.length === 10) {
                    // Set tier based on verification segment
                    if (verificationSegment === '16j59') {
                        tierFromXtl = 'pro';
                        console.log("Verified pro tier access via XTL.");
                    } else if (verificationSegment === '83n45') {
                        tierFromXtl = 'basic';
                        console.log("Verified basic tier access via XTL.");
                    } else {
                        console.error("Unrecognized verification segment in XTL:", verificationSegment);
                        handleInvalidAccess("Invalid Access Code Segment in XTL"); // Treat as invalid access if segment is unknown
                        return false; // Indicate failure
                    }

                    // Set the user ID since verification passed
                    userIdFromXtl = userIdSegment;
                    console.log("XTL parsing successful. User ID:", userIdFromXtl, "Tier:", tierFromXtl);

                    // Set globals
                    currentUserId = userIdFromXtl;
                    effectiveTier = tierFromXtl;

                    return true; // Indicate success

                } else {
                    console.error("Invalid XTL format: verification segment or user ID segment has wrong format");
                    handleInvalidAccess("Invalid XTL Format"); // Treat as invalid access if format is wrong
                    return false; // Indicate failure
                }
            } catch (e) {
                 console.error("Error processing XTL parameter:", e);
                 handleInvalidAccess("Error Processing XTL Parameter"); // Treat as invalid access on processing error
                 return false; // Indicate failure
            }
        } else {
            console.warn("XTL parameter missing or wrong length. Proceeding without authenticated user via XTL.");
            // This is not an invalid access, just means no XTL user context
            // currentUserId and effectiveTier will remain null/basic from initial declaration
            return false; // Indicate no authenticated user was found via XTL
        }
    }

    // Function to fetch initial usage for UI feedback and final access check
    async function fetchInitialUsage() {
        console.log("Fetching initial usage info...");

        // Ensure Supabase client is initialized
        if (!supabase) {
            console.warn("Supabase client not initialized before fetching usage. Attempting initialization.");
             try {
                if (typeof window.supabase === 'undefined' || !window.supabase?.createClient) {
                    throw new Error("Supabase library not loaded.");
                }
                const { createClient } = window.supabase;
                supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log("Supabase client initialized during fetch attempt.");
             } catch (err) {
                console.error("Error initializing Supabase during fetch:", err);
                initialUsageInfo = { error: "Could not initialize service connection." };
                 updateUIBasedOnAccess(); // Update UI to show error state
                 return; // Stop fetch process
             }
        }

        if (!currentUserId) {
            console.log("Skipping initial usage fetch: No user ID available (XTL not parsed or invalid, or demo data not loaded).");
            initialUsageInfo = { error: "No valid user ID for access check." }; // Indicate why chat might not work
            updateUIBasedOnAccess(); // Update UI based on no user ID
            return; // Exit early
        }


        console.log(`Attempting to fetch user data for ID: ${currentUserId}`);

        try {
            // Using the ANON key here requires appropriate RLS on your 'SWN_Users' table
            // to allow reading 'token_usage', 'last_token_reset', 'tier' for the user matching 'id' column
            const { data, error } = await supabase
                .from('SWN_Users')
                .select('token_usage, last_token_reset, tier')
                .eq('id', currentUserId) // Using the ID derived from XTL or demo data
                .maybeSingle();

            if (error && error.code !== 'PGRST116') { // PGRST116 is 'results in 0 rows'
                console.error("Error fetching initial usage:", error.message);
                initialUsageInfo = { error: `Error loading usage data: ${error.message}` };
                updateUIBasedOnAccess();
            } else if (data) {
                console.log("Initial usage data fetched:", data);
                // Note: The backend function is the source of truth for tier/limit/model based on header.
                // This fetch is primarily for displaying client-side usage info.
                // We'll use the tier determined by XTL (effectiveTier) for the frontend UI and backend header,
                // but also show the DB tier for potential debugging if needed.
                const determinedLimit = (effectiveTier === 'pro') ? 500000 : 15000; // Client-side assumption for display

                const now = new Date();
                const lastReset = data.last_token_reset ? new Date(data.last_token_reset) : null;
                let currentUsage = Number(data.token_usage) || 0; // Ensure it's a number

                // Check if weekly reset is due (same logic as backend)
                let needsReset = !lastReset || (now.getTime() - lastReset.getTime()) / (1000 * 60 * 60 * 24) >= 7;

                // Reflect reset state for the frontend display calculation
                // Frontend display shows actual usage from DB, but notes if reset is pending/needed
                // currentUsage = 0; // <-- Reverted this - show actual usage


                initialUsageInfo = {
                    usage: currentUsage, // Usage from DB
                    limit: determinedLimit, // Limit based on frontend effective tier
                    model: (effectiveTier === 'pro') ? 'gpt-4o-mini' : 'gpt-3.5-turbo', // Model based on frontend effective tier
                    tier: effectiveTier, // Tier derived from XTL or loaded data (used for backend calls)
                    actualDbTier: data.tier, // Tier stored in DB (for comparison/debug)
                    lastReset: data.last_token_reset,
                    resetDue: needsReset,
                    userFoundInDb: true // Flag indicating the user exists in the DB
                };
                console.log("Initial Usage Info Calculated:", initialUsageInfo);
                updateUIBasedOnAccess(); // Update UI based on fetched info

            } else {
                // data is null and error is PGRST116 - User ID not found in DB
                console.warn(`User ID ${currentUserId} not found in SWN_Users table during initial fetch.`);
                // This user will be registered on their first chat request by the updated backend.
                // For frontend display, show 0 usage but indicate user not found in initial fetch.
                 initialUsageInfo = {
                    usage: 0, // Assume 0 usage for a new user
                    limit: (effectiveTier === 'pro') ? 500000 : 15000, // Use configured limits for display
                    model: (effectiveTier === 'pro') ? 'gpt-4o-mini' : 'gpt-3.5-turbo', // Use configured models for display
                    tier: effectiveTier, // Tier derived from XTL or loaded data
                    actualDbTier: null, // Not found in DB
                    lastReset: null,
                    resetDue: true, // New user needs a reset timestamp set on first use
                    userFoundInDb: false // Flag indicating the user does NOT exist in the DB yet
                 };
                 console.log("Initial Usage Info (User Not Found in DB) Calculated:", initialUsageInfo);
                updateUIBasedOnAccess(); // Update UI assuming a new user state
            }
        } catch (err) {
            console.error("Unexpected error fetching initial usage:", err);
            initialUsageInfo = { error: "Unexpected error loading usage data." };
            updateUIBasedOnAccess(); // Update UI with error
        }
    }

    function handleInvalidAccess(reason) {
        console.error("Access Denied or Invalid:", reason);
        currentUserId = null; // Explicitly nullify user ID
        effectiveTier = 'basic'; // Reset tier assumption
        initialUsageInfo = null; // Clear usage info

        // Use the central error handler to ensure visibility
        handleError(`Access Error: ${reason}`, new Error(reason), true); // Pass true for isAccessError
    }

    // This function now updates the chat status display info AND calls initializeChat
    function updateUIBasedOnAccess() {
        console.log("Executing updateUIBasedOnAccess to update Tier/Usage display info START");
        console.log("  currentUserId:", currentUserId);
        console.log("  effectiveTier:", effectiveTier);
        console.log("  initialUsageInfo:", initialUsageInfo); // Log the state of the data object

        // Get references to the new display elements inside the chat status bar
        const tierDisplay = document.getElementById('chatTierDisplay');
        const modelDisplay = document.getElementById('chatModelDisplay');
        const usageDisplay = document.getElementById('chatUsageDisplay');

        console.log("  Found chat status elements:", {
            tierDisplay: !!tierDisplay, // Check if element was found (true/false)
            modelDisplay: !!modelDisplay,
            usageDisplay: !!usageDisplay
        });


        // Default display values
        let tierText = 'Loading...'; // Use 'Loading...' as an explicit state
        let modelText = '-';
        let usageText = '- / -';

        if (initialUsageInfo) { // Check if initialUsageInfo object exists at all
             console.log("  initialUsageInfo exists.");
             if (!initialUsageInfo.error) { // Check if there was an error fetching info
                   console.log("  initialUsageInfo has no error.");
                   // We have valid usage info
                    const usage = initialUsageInfo.usage !== undefined ? initialUsageInfo.usage : NaN;
                    const limit = initialUsageInfo.limit !== undefined ? initialUsageInfo.limit : NaN;

                    // Use the tier/model from initialUsageInfo if available, fallback to effectiveTier
                    // initialUsageInfo.tier and model are determined by effectiveTier in fetchInitialUsage
                    tierText = initialUsageInfo.tier || effectiveTier;
                    modelText = initialUsageInfo.model || 'N/A';

                    console.log("  Calculated raw values:", { usage, limit, tierText, modelText });


                    if (!isNaN(usage) && isFinite(usage) && !isNaN(limit) && isFinite(limit)) {
                         usageText = `${Math.floor(usage).toLocaleString()} / ${Math.floor(limit).toLocaleString()}`; // Floor usage/limit for display
                    } else {
                         usageText = 'ErrorCalculating'; // Indicate if usage/limit numbers are invalid
                    }

                    if(initialUsageInfo.resetDue && initialUsageInfo.userFoundInDb) usageText += " (Reset Pending)"; // Only show reset pending if user is found
                    if(!initialUsageInfo.userFoundInDb && currentUserId) tierText += " (New User)"; // Append note if needed (e.g., 'basic (New)')

                    console.log("  Formatted text values:", { tierText, modelText, usageText });

             } else {
                   // Error loading usage info
                    tierText = 'ErrorFetch'; // Indicate error state
                    modelText = 'ErrorFetch';
                    usageText = 'ErrorFetch';
                    console.warn("  Displaying Error state due to initialUsageInfo.error:", initialUsageInfo.error);
             }
        } else if (!currentUserId) {
            // No valid user ID available (XTL parsing failed or missing, and no data loaded)
            tierText = 'NoUser'; // Indicate no user
            modelText = 'NoUser';
            usageText = 'NoUser';
             console.log("  No currentUserId available.");
        } else {
             // initialUsageInfo is null/undefined, but user ID is present.
             // This means fetchInitialUsage hasn't completed yet or failed silently before setting initialUsageInfo.error.
             console.log("  initialUsageInfo is null/undefined, user ID present. Still loading?");
             // The "Loading..." defaults set initially will cover this.
             tierText = 'Loading...'; // Explicitly show loading state
             modelText = 'Loading...';
             usageText = 'Loading...';
        }

        // Update the text content of the new spans in the chat status bar
        if (tierDisplay) tierDisplay.textContent = tierText;
        else console.error("Chat tier display element (#chatTierDisplay) not found - critical for status display."); // Changed warn to error for clarity

        if (modelDisplay) modelDisplay.textContent = modelText;
        else console.error("Chat model display element (#chatModelDisplay) not found - critical for status display."); // Changed warn to error

        console.log("  Attempting to update Usage display with:", usageText); // <-- LOG BEFORE SETTING TEXT
        if (usageDisplay) {
            usageDisplay.textContent = usageText; // <-- This line updates the usage display
            console.log("  Successfully updated Usage display."); // <-- LOG AFTER SETTING TEXT
        } else {
            console.error("Chat usage display element (#chatUsageDisplay) not found - critical for status display.");
        }

        console.log("  Finished updating chat status elements."); // <-- LOG AFTER ALL ELEMENTS ARE HANDLED


        // Update any pro-specific UI elements (e.g., buttons) based on the effectiveTier
        const proFeatureButton = document.getElementById('proFeatureButton'); // Assuming you have such a button
        if (proFeatureButton) {
            proFeatureButton.style.display = (effectiveTier === 'pro') ? 'inline-block' : 'none';
        } else { console.warn("Pro feature button element not found."); } // Keep as warn


        // Trigger chat initialization/update AFTER usage info is processed and displayed
        // This ensures the chat UI visibility/state (enabled/disabled) reflects the latest access status
        console.log("  Calling initializeChat() from updateUIBasedOnAccess.");
        initializeChat(); // This remains crucial

        console.log("Executing updateUIBasedOnAccess END");
    }

    // --- Main Data Processing & Display Function ---
    function processAndDisplayData(data) {
        console.log("--- processAndDisplayData START ---", data);
        // Basic validation of the data structure
        if (!data || typeof data !== 'object' || !data.userInput) {
            console.error("Invalid data structure received by processAndDisplayData", data);
            handleError("Invalid data format for processing. Cannot display dashboard.", new Error("Data structure is missing 'userInput'."));
            return; // Stop processing
        }
        dashboardData = data; // Update global reference

        // Update user context based on loaded data's metadata if available and valid
        if (dashboardData.metadata && typeof dashboardData.metadata.userId === 'string' && dashboardData.metadata.userId.length > 0) {
             console.log(`Updating user context from loaded data metadata: User ID = ${dashboardData.metadata.userId}, Tier = ${dashboardData.metadata.tier}`);
             currentUserId = dashboardData.metadata.userId;
             effectiveTier = getSafe(() => dashboardData.metadata.tier, 'basic');
             // Ensure tier is valid if provided, default to basic
             if (!['basic', 'pro'].includes(effectiveTier)) {
                 effectiveTier = 'basic';
                 console.warn("Invalid tier found in file metadata. Defaulting to basic.");
             }
             // Re-fetch usage info for the newly set user ID
             fetchInitialUsage(); // This will also call updateUIBasedOnAccess and initializeChat
        } else {
             console.warn("No user ID or tier found in loaded data metadata. Keeping current context (from XTL or default).");
             // If no metadata, rely on currentUserId/effectiveTier set by XTL or defaults
             updateUIBasedOnAccess(); // Ensure UI reflects current user/tier/usage state
        }

         // Load chat history from data if available
         chatMessages = Array.isArray(getSafe(() => dashboardData.chatHistory)) ? dashboardData.chatHistory.filter(msg => msg && msg.role && msg.content) : []; // Filter valid messages
         console.log(`Loaded ${chatMessages.length} chat messages from data.`);

        // Recalculate totals and ratios after loading new data
         const totals = calculateTotals(data);
         const ratios = calculateRatios(data, totals);


        try {
            console.log("1. Calculating totals...");
            // Totals already calculated above
            console.log("Totals calculated:", totals);

            console.log("2. Calculating ratios...");
             // Ratios already calculated above
            console.log("Ratios calculated:", ratios);

            console.log("3. Updating basic info UI...");
            updateReportBasics(data, totals);
            console.log("Basic info UI updated.");

            console.log("4. Updating ratios UI...");
            updateRatiosDisplay(ratios);
            console.log("Ratios UI updated.");

            console.log("5. Updating goals UI...");
            updateGoalsDisplay(data, totals);
            console.log("Goals UI updated.");

            console.log("6. Updating debts UI...");
            console.log("  About to call updateDebtsDisplay...");
            updateDebtsDisplay(data, totals);
            console.log("Debts UI updated.");

            console.log("7. Scheduling chart rendering...");
            // Use requestAnimationFrame to ensure DOM is ready for Plotly
            requestAnimationFrame(() => {
                console.log("7a. Executing chart rendering (inside requestAnimationFrame)...");
                try {
                    renderCharts(data);
                    console.log("Charts rendered successfully.");
                } catch (chartError) {
                    console.error("--- Error during renderCharts ---", chartError);
                    // Display error within the chart divs
                    const incomeChartDiv = document.getElementById('incomeChart');
                    const expenseChartDiv = document.getElementById('expenseChart');
                    if(incomeChartDiv) incomeChartDiv.innerHTML = `<p class="text-red-600 text-center p-4">Error loading income chart:<br>${getSafe(() => chartError.message, 'Unknown chart error')}</p>`;
                    if(expenseChartDiv) expenseChartDiv.innerHTML = `<p class="text-red-600 text-center p-4">Error loading expense chart:<br>${getSafe(() => chartError.message, 'Unknown chart error')}</p>`;
                }
            });

            console.log("8. Updating AI display UI...");
            updateUIDisplayFromAI(data);
            console.log("AI display UI updated.");

            // Chat initialization happens via updateUIBasedOnAccess which is called after metadata processing or in finally block

            console.log("9. Making main content visible...");
            hideAllMainContentAreas(); // Hide other states
            if (mainContentElement) {
                mainContentElement.style.display = 'block'; // Use block display (or grid if appropriate)
                mainContentElement.classList.remove('hidden'); // Ensure class is removed if used
                console.log("Main content should now be visible.");
            } else {
                 console.error("Main content element not found!");
                 handleError("Critical: Main content element not found.", new Error("DOM element #mainContent is missing."));
            }

        } // <-- This brace closes the 'try' block of processAndDisplayData

        catch (processingError) {
            console.error("--- processAndDisplayData ERROR ---", processingError);
            handleError("Error processing or displaying data", processingError);
        } finally {
            // Ensure spinner is hidden regardless of success/failure within the try block
            console.log("Executing finally block in processAndDisplayData.");
            if (loadingSpinner) {
                loadingSpinner.style.display = 'none';
                console.log("Spinner hidden by processAndDisplayData finally block.");
            } else {
                console.warn("Spinner element not found in finally block.");
            }
             // Ensure chat is initialized/updated after data processing is complete
            console.log("Calling initializeChat() from processAndDisplayData finally block.");
            initializeChat(); // This will read the updated chatMessages and user context

            // --- The silent re-authentication code WAS HERE, BUT IT BELONGS IN  ---
            // --- It has been removed from THIS finally block ---

            // Update button visibility now that data is loaded
             updateDriveButtonVisibility(!!googleAccessToken);
            console.log("--- processAndDisplayData END ---");
        }
    } // <-- This brace closes the processAndDisplayData function

    // --- Calculation Functions ---
    function calculateTotals(data) {
        console.log("Calculating totals...");
        const totals = {
            totalIncome: 0, totalExpenses: 0, netFlow: 0,
            totalDebt: 0, totalSavings: 0, totalMinPayments: 0,
            monthlyCoreExpenses: 0 // Added for emergency fund calc
        };

        try {
            const income = getSafe(() => data.userInput?.income, {});
            const expenses = getSafe(() => data.userInput?.expenses, {});
            const savings = getSafe(() => data.userInput?.savings, {});
            const debts = getSafe(() => data.userInput?.debts, []);

            // Income: Sum known income types
            totals.totalIncome = (Number(getSafe(() => income.mainJobIncome, 0)) || 0) + (Number(getSafe(() => income.secondJob, 0)) || 0) + (Number(getSafe(() => income.otherIncome, 0)) || 0);

            // Expenses & Core Expenses: Iterate through expenses object
            // Define core expenses - ADJUST THESE KEYS TO MATCH YOUR DATA EXACTLY
             // Assuming min payments from debts are *not* included in expenses object directly
            const coreExpenseKeys = ['housing', 'utilities', 'transportation', 'groceriesEssentials', 'insurance', 'medical', 'care', 'subscriptions', 'taxes']; // Removed 'minPayments' here

            for (const key in expenses) {
                const value = Number(getSafe(() => expenses[key], 0)) || 0;
                totals.totalExpenses += value;
                // Check if the expense key is considered 'core'
                if (coreExpenseKeys.includes(key)) {
                    totals.monthlyCoreExpenses += value;
                }
            }

            // Debts: Sum balance and minimum payments from the debts array
            if (Array.isArray(debts)) {
                debts.forEach(debt => {
                    totals.totalDebt += Number(getSafe(() => debt.balance, 0)) || 0;
                    const minPayment = Number(getSafe(() => debt.minPayment, 0)) || 0;
                    totals.totalMinPayments += minPayment;
                });
            }

            // Add total minimum debt payments to total expenses and core expenses
            totals.totalExpenses += totals.totalMinPayments;
            totals.monthlyCoreExpenses += totals.totalMinPayments; // Min payments are usually core

            totals.netFlow = totals.totalIncome - totals.totalExpenses;

            // Savings: Sum known savings types
            totals.totalSavings = (Number(getSafe(() => savings.emergency, 0)) || 0) + (Number(getSafe(() => savings.savings, 0)) || 0) + (Number(getSafe(() => savings.retirement, 0)) || 0);

             console.log("Totals calculation successful.");
        } catch (e) {
             console.error("Error during calculateTotals:", e);
             // Return partial totals or re-throw? Returning partial is more robust
             return totals; // Return whatever was calculated before the error
        }

        return totals;
    }

    function calculateRatios(data, totals) {
        console.log("Calculating ratios...");
        const ratios = { savingsRate: 0, emergencyCoverage: 0, dtiRatio: 0 };

         // Check if totals are valid before calculating ratios
         if (typeof totals !== 'object' || isNaN(totals.totalIncome) || isNaN(totals.totalExpenses) || isNaN(totals.totalMinPayments) || isNaN(totals.monthlyCoreExpenses)) {
             console.error("Invalid totals provided for ratio calculation.");
             return ratios; // Return zero ratios
         }

        try {
            const savingsInput = getSafe(() => data.userInput?.savings, {});

            // Savings Rate: Use explicit monthly goal if available, otherwise use positive net flow proxy
            const monthlySavingsGoal = Number(getSafe(() => savingsInput.monthlySavingsGoal, 0));
            // Use the goal if defined AND positive, otherwise use net flow (but cap at 0 if net flow is negative)
            const contribution = (monthlySavingsGoal > 0) ? monthlySavingsGoal : Math.max(0, totals.netFlow);

            if (totals.totalIncome > 0) {
                // Savings rate = (Amount Saved Per Month / Gross Monthly Income)
                ratios.savingsRate = (contribution / totals.totalIncome); // Rate as decimal
            } else {
                ratios.savingsRate = 0; // Avoid division by zero
            }

            // Emergency Fund Coverage (Months based on CORE expenses)
            const currentEmergencyFund = Number(getSafe(() => savingsInput.emergency, 0)) || 0;
            if (totals.monthlyCoreExpenses > 0) {
                ratios.emergencyCoverage = currentEmergencyFund / totals.monthlyCoreExpenses; // Result in months
            } else if (totals.totalExpenses > 0) {
                // Fallback if core expenses somehow end up zero but total expenses > 0
                ratios.emergencyCoverage = currentEmergencyFund / totals.totalExpenses;
                console.warn("Using total expenses for emergency coverage calculation as core expenses were zero.")
            } else {
                ratios.emergencyCoverage = Infinity; // If no expenses, coverage is infinite (or handle as special case)
            }

            // Debt-to-Income (DTI) Ratio (using minimum payments from totals)
            // DTI = (Total Monthly Minimum Debt Payments / Gross Monthly Income)
            if (totals.totalIncome > 0) {
                ratios.dtiRatio = (totals.totalMinPayments / totals.totalIncome); // Rate as decimal
            } else {
                ratios.dtiRatio = 0; // Or Infinity if debts exist but income is zero? Define behavior.
            }
             console.log("Ratios calculation successful.");
        } catch (e) {
             console.error("Error during calculateRatios:", e);
             return ratios; // Return partial ratios or re-throw? Returning partial is more robust
        }

        return ratios;
    }

    // --- UI Update Functions ---
    function updateReportBasics(data, totals) {
        console.log("Updating report basics UI...");
        try {
            const personalInfo = getSafe(() => data.userInput?.personalInfo, {});
            const savings = getSafe(() => data.userInput?.savings, {});
            const financials = getSafe(() => data.userInput?.financials, {});

            updateElementText('userName', getSafe(() => personalInfo.userName));
            updateElementText('age', getSafe(() => personalInfo.age)); // Assumes age is just a number
            updateElementText('totalIncome', totals.totalIncome, formatCurrency);
            updateElementText('totalExpenses', totals.totalExpenses, formatCurrency);
            updateElementText('netFlow', totals.netFlow, formatCurrency);

            // Update Savings Overview Card
            updateElementText('emergencySavings', getSafe(() => savings.emergency), formatCurrency);
            updateElementText('currentSavings', getSafe(() => savings.savings), formatCurrency); // Assumes 'savings' is general savings
            updateElementText('retirementFund', getSafe(() => savings.retirement), formatCurrency);

            // Update Financial Tools & Goals Card (specific fields)
            updateElementText('financialTools', getSafe(() => financials.financialTools));
            updateElementText('challenges', getSafe(() => financials.challenges));
            updateElementText('purchaseGoals', getSafe(() => financials.upcomingPurchase)); // Raw detail string here
            console.log("Report basics UI updated.");
        } catch (e) {
            console.error("Error updating report basics UI:", e);
        }
    }

    function updateRatiosDisplay(ratios) {
        console.log("Updating ratios display UI...");
        try {
            // Savings Rate
            const savingsRateValue = getSafe(() => ratios.savingsRate, 0);
            updateElementText('savingsRateValue', savingsRateValue, val => formatPercentage(val, 1));
            const savingsRatePercent = Math.min(100, Math.max(0, savingsRateValue * 100));
            const savingsBar = document.getElementById('savingsRateBar');
            if (savingsBar) {
                savingsBar.style.width = `${savingsRatePercent}%`;
                // Recommendation: Poor < 5%, Ok 5-10%, Good 10-15%, Excellent > 15% (Adjust thresholds as needed)
                savingsBar.className = `ratio-bar savings-rate ${savingsRateValue >= 0.10 ? 'good' : savingsRateValue >= 0.05 ? 'ok' : 'poor'}`; // Example thresholds
            } else { console.warn("Savings rate bar element not found."); }

            // Emergency Fund Coverage (Display in Months)
            const emergencyCoverageMonths = getSafe(() => ratios.emergencyCoverage, 0);
             const emergencyCoverageText = emergencyCoverageMonths === Infinity ? 'N/A (No Expenses)' : `${emergencyCoverageMonths.toFixed(1)} months`;
            updateElementText('emergencyCoverageValue', emergencyCoverageText);
            const emergencyBar = document.getElementById('emergencyCoverageBar');
            if (emergencyBar) {
                // Progress towards a target, e.g., 6 months. Cap at 100%. Handle Infinity.
                const targetMonths = 6;
                const emergencyProgressPercent = emergencyCoverageMonths === Infinity ? 100 : Math.min(100, Math.max(0, (emergencyCoverageMonths / targetMonths) * 100));
                emergencyBar.style.width = `${emergencyProgressPercent}%`;
                // Recommendation: Poor < 1 month, Ok 1-3 months, Good 3-6 months, Excellent > 6 months (Adjust thresholds)
                emergencyBar.className = `ratio-bar emergency-coverage ${emergencyCoverageMonths >= 3 ? 'good' : emergencyCoverageMonths >= 1 ? 'ok' : 'poor'}`;
            } else { console.warn("Emergency coverage bar element not found."); }


            // DTI Ratio
            const dtiRatioValue = getSafe(() => ratios.dtiRatio, 0);
            updateElementText('dtiRatioValue', dtiRatioValue, val => formatPercentage(val, 1));
            const dtiPercent = Math.min(100, Math.max(0, dtiRatioValue * 100));
            const dtiBar = document.getElementById('dtiRatioBar');
            if (dtiBar) {
                dtiBar.style.width = `${dtiPercent}%`;
                // General guideline: Good < 36%, Warning 36-43%, High > 43% (Adjust thresholds)
                dtiBar.className = `ratio-bar dti-ratio ${dtiRatioValue > 0.43 ? 'high' : dtiRatioValue >= 0.36 ? 'warning' : 'good'}`;
            } else { console.warn("DTI ratio bar element not found."); }
             console.log("Ratios display UI updated.");
        } catch (e) {
            console.error("Error updating ratios display UI:", e);
        }
    }

    function updateGoalsDisplay(data, totals) {
        console.log("Updating goals display UI...");
        try {
            const savingsInput = getSafe(() => data.userInput?.savings, {});
            const financialsInput = getSafe(() => data.userInput?.financials, {});
            const upcomingPurchaseString = getSafe(() => financialsInput.upcomingPurchase, '');

            const emergencyGoalDisplay = document.getElementById('emergencyGoalDisplay');
            const purchaseGoalDisplay = document.getElementById('purchaseGoalDisplay');
            const noGoalsMessage = document.getElementById('noGoalsMessage');
            let hasVisibleGoal = false;

            // --- Emergency Fund Goal ---
            const emergencyCurrent = Number(getSafe(() => savingsInput.emergency, 0)) || 0;
            // Use target from data if available, otherwise default to 3 months CORE expenses
            const emergencyGoalTargetExplicit = Number(getSafe(() => savingsInput.emergencyFundTarget, 0));
            const emergencyGoalTargetCalculated = totals.monthlyCoreExpenses > 0 ? totals.monthlyCoreExpenses * 3 : 0;
            // Prefer explicit target if valid (>0), else use calculated (>0), else target is 0
            const emergencyGoalTarget = (emergencyGoalTargetExplicit > 0) ? emergencyGoalTargetExplicit : (emergencyGoalTargetCalculated > 0 ? emergencyGoalTargetCalculated : 0);

            const emergencyProgressBar = document.getElementById('emergencyProgressBar');

            if (emergencyGoalTarget > 0 && emergencyGoalDisplay && emergencyProgressBar) {
                hasVisibleGoal = true;
                emergencyGoalDisplay.style.display = 'block';
                const progress = Math.min(100, Math.max(0, (emergencyCurrent / emergencyGoalTarget) * 100));
                emergencyProgressBar.style.width = `${progress}%`;
                emergencyProgressBar.textContent = `${progress.toFixed(0)}%`;
                const statusEl = emergencyGoalDisplay.querySelector('.goal-status');
                if (statusEl) statusEl.textContent = `Target: ${formatCurrency(emergencyGoalTarget)} (${formatPercentage(emergencyCurrent / emergencyGoalTarget, 0)} funded)`;
            } else if (emergencyGoalDisplay) {
                emergencyGoalDisplay.style.display = 'none'; // Hide if target is not valid or 0
            } else { console.warn("Emergency goal elements not found."); }


            // --- Upcoming Purchase Goal (Attempt to parse first one) ---
            const purchaseProgressBar = document.getElementById('purchaseProgressBar');
            const purchaseGoalNameEl = document.getElementById('purchaseGoalName');

            // Check if all necessary elements exist before attempting to parse/display purchase goal
            if (upcomingPurchaseString && purchaseGoalDisplay && purchaseProgressBar && purchaseGoalNameEl) {
                 // Look for pattern like: #1) Name, $Amount[, X months] - make months optional
                 // Made regex slightly more robust to handle spaces, commas, dollar signs better
                 const match = upcomingPurchaseString.match(/#\d+\)\s*(.*?),\s*\$?\s*([\d,.]+)(?:,\s*\d+\s*months?)?/i); // Added case-insensitive flag
                 console.log("Purchase goal regex match:", match);

                if (match && match[1] && match[2]) {
                    const goalName = match[1].trim();
                    const goalAmountStr = match[2].replace(/,/g, '');
                    const goalAmount = parseFloat(goalAmountStr);
                    // Use general savings for progress unless specific goal savings provided in data
                    const generalSavings = Number(getSafe(() => savingsInput.savings, 0)) || 0;

                    if (goalName && !isNaN(goalAmount) && goalAmount > 0) {
                        hasVisibleGoal = true;
                        purchaseGoalDisplay.style.display = 'block';
                        purchaseGoalNameEl.textContent = goalName;
                        // Calculate progress using general savings balance towards this goal amount
                        const progress = Math.min(100, Math.max(0, (generalSavings / goalAmount) * 100));
                        purchaseProgressBar.style.width = `${progress}%`;
                        purchaseProgressBar.textContent = `${progress.toFixed(0)}%`;
                        const statusEl = purchaseGoalDisplay.querySelector('.goal-status');
                        if (statusEl) statusEl.textContent = `Target: ${formatCurrency(goalAmount)} (${formatCurrency(generalSavings)} saved)`;
                    } else {
                        console.warn("Purchase goal parsed but name or amount invalid:", { goalName, goalAmount });
                        purchaseGoalDisplay.style.display = 'none'; // Hide if parsing results in invalid goal
                    }
                } else {
                     console.log("Upcoming purchase string does not match expected format, displaying raw text:", upcomingPurchaseString);
                     // If parsing fails, display the raw text in the Financial Tools & Goals card instead
                     // This is already done by updateReportBasics, so just hide this progress bar section
                    purchaseGoalDisplay.style.display = 'none';
                }
            } else if (purchaseGoalDisplay) { // Hide if no string or elements
                purchaseGoalDisplay.style.display = 'none';
                 if (!purchaseGoalDisplay) console.warn("Purchase goal display elements not found.");
            }

            // Show 'No goals' message only if neither goal section is visible
            if (noGoalsMessage) {
                noGoalsMessage.style.display = hasVisibleGoal ? 'none' : 'block';
            } else { console.warn("No goals message element not found.");}
             console.log("Goals display UI updated.");
        } catch (e) {
            console.error("Error updating goals display UI:", e);
        }
    }

     function updateDebtsDisplay(data, totals) {
        console.log("--- updateDebtsDisplay FUNCTION ENTERED ---"); // Very first log inside {}

        try { // Wrap the main logic in try block
            console.log("--- updateDebtsDisplay START ---");
            console.log("  Received data object:", data);
            console.log("  Received totals object:", totals);

            const debts = getSafe(() => data.userInput?.debts, []); // Get debts array safely
            console.log("  Parsed debts array:", debts);
            console.log("  Is debts an array?", Array.isArray(debts));
            console.log("  Debts array length:", debts.length);


            const debtsTable = document.getElementById('debtsTable');
            if (!debtsTable) {
                console.error("Debt table element (#debtsTable) not found!");
                // Still attempt to update totals even if table is missing
                 // Update totals using the calculated totals object - ensure totals exist and are valid
                if (totals && typeof totals === 'object' && isFinite(totals.totalDebt) && isFinite(totals.totalMinPayments)) {
                     updateElementText('totalDebtBalance', totals.totalDebt, formatCurrency);
                     updateElementText('totalMinPayments', totals.totalMinPayments, formatCurrency);
                } else {
                     console.warn("Totals object invalid, skipping total debt display update.");
                     updateElementText('totalDebtBalance', 'N/A');
                     updateElementText('totalMinPayments', 'N/A');
                }
                console.log("--- updateDebtsDisplay END (Table not found) ---");
                return; // Exit function if table is missing
            }

            const debtsTableBody = debtsTable.getElementsByTagName('tbody')[0];
             if (!debtsTableBody) {
                 console.error("Debt table body element (tbody) not found inside #debtsTable!");
                 // Update totals even if tbody is missing
                 if (totals && typeof totals === 'object' && isFinite(totals.totalDebt) && isFinite(totals.totalMinPayments)) {
                     updateElementText('totalDebtBalance', totals.totalDebt, formatCurrency);
                     updateElementText('totalMinPayments', totals.totalMinPayments, formatCurrency);
                } else {
                     console.warn("Totals object invalid, skipping total debt display update.");
                     updateElementText('totalDebtBalance', 'N/A');
                     updateElementText('totalMinPayments', 'N/A');
                }
                 console.log("--- updateDebtsDisplay END (Tbody not found) ---");
                 return; // Exit function if tbody is missing
             }

            console.log("  Debt table body found.");
            debtsTableBody.innerHTML = ''; // Clear existing rows
            console.log("  Cleared existing table rows.");

            if (!Array.isArray(debts) || debts.length === 0) {
                console.log("  No debt data or debts array is not an array. Displaying 'No debt information'.");
                debtsTableBody.innerHTML = '<tr><td colspan="4" class="text-center text-gray-500 py-4">No debt information provided.</td></tr>';
            } else {
                console.log(`  Processing ${debts.length} debt items.`);
                debts.forEach((debt, index) => {
                    console.log(`    Processing debt item ${index}:`, debt);
                    // Inner try/catch already exists here for individual rows - keep it

                    try { // Existing inner try block
                        const row = debtsTableBody.insertRow();

                        // Use getSafe for potentially missing debt properties
                        const type = getSafe(() => debt.type, 'N/A');
                        const balance = getSafe(() => debt.balance, 0); // Use getSafe for balance with default 0
                        const minPayment = getSafe(() => debt.minPayment, 0); // Use getSafe for minPayment with default 0
                        const interestRate = getSafe(() => debt.interestRate, 0); // Default rate to 0 if missing

                        console.log(`      Values for row ${index}:`, { type, balance, minPayment, interestRate });
                        console.log(`      Formatted values:`, {
                             balance: formatCurrency(balance),
                             minPayment: formatCurrency(minPayment),
                             interestRate: (Number(interestRate)).toFixed(1) + '%'
                        });


                        // Correctly map data to the appropriate columns and add CSS classes
                        row.innerHTML = `
                            <td>${type}</td>                                          <!-- Column 1: Type -->
                            <td class="balance-col">${formatCurrency(balance)}</td>    <!-- Column 2: Balance -->
                            <td class="rate-col">${(Number(interestRate)).toFixed(1)}%</td>    <!-- Column 3: Rate -->
                            <td class="min-pmt-col">${formatCurrency(minPayment)}</td>    <!-- Column 4: Min Payment -->
                        `;
                         console.log(`      Row ${index} HTML set.`);
                    } catch (e) { // Existing inner catch block
                        console.error(`  Error adding debt row for item ${index}:`, debt, e);
                        // Add an error row if processing a specific debt item fails
                        const row = debtsTableBody.insertRow();
                         row.innerHTML = `<td colspan="4" class="text-center text-red-500">Error displaying data for this debt item.</td>`;
                    }
                });
                 console.log("  Finished processing debt items.");
            }

            // Update totals using the calculated totals object - ensure totals exist and are valid
            if (totals && typeof totals === 'object' && isFinite(totals.totalDebt) && isFinite(totals.totalMinPayments)) {
                console.log("  Updating total debt elements:", { totalDebt: totals.totalDebt, totalMinPayments: totals.totalMinPayments });
                 updateElementText('totalDebtBalance', totals.totalDebt, formatCurrency);
                 updateElementText('totalMinPayments', totals.totalMinPayments, formatCurrency);
            } else {
                 console.warn("  Totals object invalid or missing, skipping total debt display update.");
                 updateElementText('totalDebtBalance', 'N/A');
                 updateElementText('totalMinPayments', 'N/A');
            }
             console.log("--- updateDebtsDisplay END ---"); // Last log before function exits normally

        } catch (outerError) { // Outer catch block
            console.error("--- updateDebtsDisplay OUTER CATCH ERROR ---", outerError);
            // Optionally display a generic error message in the table body if it wasn't cleared
            if(debtsTableBody && debtsTableBody.innerHTML === '') {
                 debtsTableBody.innerHTML = '<tr><td colspan="4" class="text-center text-red-500 py-4">Error loading debt data. Check console.</td></tr>';
            } else if (debtsTableBody && debtsTableBody.innerHTML.includes('Loading debt data')) {
                // If still showing "Loading...", replace it
                 debtsTableBody.innerHTML = '<tr><td colspan="4" class="text-center text-red-500 py-4">Error loading debt data. Check console.</td></tr>';
            }
             // Update totals to N/A on error
             updateElementText('totalDebtBalance', 'N/A');
             updateElementText('totalMinPayments', 'N/A');
        }
        // Function implicitly ends here if no outer catch error, or returns above
         console.log("--- updateDebtsDisplay FUNCTION EXIT ---"); // Log right before the function truly exits
    }

    function renderCharts(data) {
        console.log("--- renderCharts START ---");
        console.log("  Received data object for charts:", data);

        // Check if Plotly library is loaded
        if (typeof Plotly === 'undefined') {
            console.error("  Plotly library not found. Cannot render charts.");
            const incomeChartDiv = document.getElementById('incomeChart');
            const expenseChartDiv = document.getElementById('expenseChart');
            if(incomeChartDiv) incomeChartDiv.innerHTML = '<p class="text-red-600 text-center p-4">Error: Plotly library not loaded.</p>';
            if(expenseChartDiv) expenseChartDiv.innerHTML = '<p class="text-red-600 text-center p-4">Error: Plotly library not loaded.</p>';
            console.log("--- renderCharts END (Plotly not loaded) ---");
            return; // Exit function
        }
        console.log("  Plotly library found.");


        try {
            const incomeData = getSafe(() => data.userInput?.income, {});
            const expenseData = getSafe(() => data.userInput?.expenses, {});

            console.log("  Parsed income data:", incomeData);
            console.log("  Parsed expense data:", expenseData);


            // --- Filter and prepare income labels/values ---
            const incomeLabels = [];
            const incomeValues = [];
            Object.entries(incomeData).forEach(([key, value]) => {
                const numValue = Number(getSafe(() => value, 0)); // Use getSafe for value with default 0
                if (numValue > 0) {
                    let label = key.replace(/([A-Z])/g, ' $1').replace(/^./, c => c.toUpperCase());
                    incomeLabels.push(label);
                    incomeValues.push(numValue);
                }
            });
            console.log("  Prepared income data for chart:", { labels: incomeLabels, values: incomeValues });

            // --- Filter and prepare expense labels/values ---
            const expenseLabels = [];
            const expenseValues = [];
            Object.entries(expenseData).forEach(([key, value]) => {
                const numValue = Number(getSafe(() => value, 0)); // Use getSafe for value with default 0
                if (numValue > 0) {
                    let label = key.replace(/([A-Z])/g, ' $1').replace(/^./, c => c.toUpperCase());
                    if (key === 'groceriesEssentials') label = 'Groceries/Essentials';
                     // Add debt minimum payments from totals if they exist
                    if (key === 'minPayments' && totals?.totalMinPayments > 0) {
                         // Ensure minPayments is not duplicated if it was somehow in the original expense data
                         // Also ensure we only add it if the calculated totalMinPayments is > 0
                         // A better approach is to add a separate slice for debts if needed, but for now, assume minPayments key maps to total min payments if present.
                         // Or better yet, don't include minPayments in the expense chart unless it was distinct data.
                         // Let's skip the minPayments key from the expenseData loop and handle total min payments separately if necessary for the chart.
                         // For simplicity, let's just chart the categories provided in expenseData for now.
                         // If debt payments need to be explicitly shown, you'd structure the data differently or add them here.
                         // For this iteration, only use keys present in the expenseData object from the source.
                          console.warn(`Skipping expense key "${key}" with value ${value} in chart rendering.`);
                          return; // Skip this iteration
                    }

                    expenseLabels.push(label);
                    expenseValues.push(numValue);
                }
            });
             console.log("  Prepared expense data for chart:", { labels: expenseLabels, values: expenseValues });


            const incomeChartDiv = document.getElementById('incomeChart');
            const expenseChartDiv = document.getElementById('expenseChart');

             console.log("  Found chart divs:", { incomeChartDiv: !!incomeChartDiv, expenseChartDiv: !!expenseChartDiv });

            // Common layout adjustments for Pie charts
          const commonPieLayout = {
    autosize: true,
    margin: { l: 40, r: 40, b: 60, t: 80 },   // extra space
    showlegend: true,
    legend: {
        orientation: "h",
        yanchor: "top",
        y: -0.20,                              // legend below the chart
        xanchor: "center",
        x: 0.5
    },
    paper_bgcolor: "rgba(0,0,0,0)",
    plot_bgcolor: "rgba(0,0,0,0)",
    font: { family: "Inter, sans-serif", size: 12, color: "#374151" },
    hoverlabel: { font: { family: "Inter, sans-serif", size: 12 } }
};

             console.log("  Common Pie Layout:", commonPieLayout);

            // Plotly config
             const plotlyConfig = {
                 displaylogo: false,
                 responsive: true, // Ensure responsive is true in config
                 modeBarButtonsToRemove: ['sendDataToCloud', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale2d', 'resetScale2d', 'hoverClosestPie', 'toggleSpikelines', 'hoverCompareCartesian']
             };
             console.log("  Plotly Config:", plotlyConfig);


            // Income Chart (Pie)
            if (incomeChartDiv) {
                console.log("  Processing Income Chart.");
                Plotly.purge(incomeChartDiv); // Clear previous chart first
                if (incomeValues.length > 0) {
                    console.log("  Income data found, attempting to plot.");
                    const incomeTrace = [{
                        values: incomeValues,
                        labels: incomeLabels,
                        type: 'pie',
                        hole: .4,
                        hoverinfo: 'label+percent+value',
                        textinfo: 'percent',
                        texttemplate: '%{percent}',
                        textposition: 'inside',
                        textfont_size: 11,
                        marker: {
                            colors: ['#10b981', '#34d399', '#6ee7b7', '#a7f3d0', '#d1fae5'],
                            line: { color: '#ffffff', width: 1 }
                        },
                        domain: { y: [0, 1] } // Domain should cover full height [0, 1]
                    }];
                    console.log("  Income Trace:", incomeTrace);
                    Plotly.newPlot(incomeChartDiv, incomeTrace, { ...commonPieLayout, title: { text: 'Income Sources', y:0.98, font: { size: 14, family: 'EB Garamond, serif', color: '#111827' } } }, plotlyConfig)
                        .then(() => { console.log("  Income Chart plotted successfully."); })
                        .catch((plotErr) => { console.error("  Error during Income Plotly.newPlot:", plotErr); incomeChartDiv.innerHTML = `<p class="text-red-600 text-center p-4">Error plotting income chart:<br>${getSafe(() => plotErr.message, 'Unknown plot error')}</p>`; });

                } else {
                    console.log("  No income data to plot. Displaying message.");
                    incomeChartDiv.innerHTML = '<p class="text-center text-gray-500 pt-10">No income data to display.</p>';
                    // incomeChartDiv.innerHTML  = ''; // Keep the empty message div
                }
            } else { console.error("  Income chart div (#incomeChart) not found."); }


            // Expense Chart (Pie)
            if (expenseChartDiv) {
                 console.log("  Processing Expense Chart.");
                Plotly.purge(expenseChartDiv); // Clear previous chart
                if (expenseValues.length > 0) {
                    console.log("  Expense data found, attempting to plot.");
                    const expenseTrace = [{
                        values: expenseValues,
                        labels: expenseLabels,
                        type: 'pie',
                        hole: .4,
                        hoverinfo: 'label+percent+value',
                        textinfo: 'percent',
                        texttemplate: '%{percent}',
                        textposition: 'inside',
                        textfont_size: 11,
                        marker: {
                            colors: ['#ef4444', '#f87171', '#fca5a5', '#fecaca', '#fb923c', '#fdba74', '#fed7aa', '#ffedd5', '#d1d5db', '#9ca3af', '#a78bfa', '#c4b5fd'],
                            line: { color: '#ffffff', width: 1 }
                        },
                        domain: { y: [0, 1] } // Domain should cover full height [0, 1]
                    }];
                     console.log("  Expense Trace:", expenseTrace);
                    Plotly.newPlot(expenseChartDiv, expenseTrace, { ...commonPieLayout, title: { text: 'Expense Categories', y:0.98, font: { size: 14, family: 'EB Garamond, serif', color: '#111827' } } }, plotlyConfig)
                        .then(() => { console.log("  Expense Chart plotted successfully."); })
                        .catch((plotErr) => { console.error("  Error during Expense Plotly.newPlot:", plotErr); expenseChartDiv.innerHTML = `<p class="text-red-600 text-center p-4">Error plotting expense chart:<br>${getSafe(() => plotErr.message, 'Unknown plot error')}</p>`; });

                } else {
                    console.log("  No expense data to plot. Displaying message.");
                    expenseChartDiv.innerHTML = '<p class="text-center text-gray-500 pt-10">No expense data to display.</p>';
                     // expenseChartDiv.innerHTML = ''; // Keep the empty message div
                }
            } else { console.error("  Expense chart div (#expenseChart) not found."); }

             console.log("--- renderCharts END ---"); // Last log before function exits
        } catch (chartError) {
            console.error("--- renderCharts OUTER CATCH ERROR ---", chartError);
            // Display generic error in chart divs if a general error occurred above Plotly.newPlot
            const incomeChartDiv = document.getElementById('incomeChart');
            const expenseChartDiv = document.getElementById('expenseChart');
             if(incomeChartDiv) incomeChartDiv.innerHTML = `<p class="text-red-600 text-center p-4">Error loading chart.</p>`;
             if(expenseChartDiv) expenseChartDiv.innerHTML = `<p class="text-red-600 text-center p-4">Error loading chart.</p>`;
            // Rethrow the error so it can be caught by the caller in requestAnimationFrame
            // throw new Error(`Chart rendering failed: ${getSafe(() => chartError.message, 'Unknown error')}`); // Don't re-throw, just log
        }
    }

    function updateUIDisplayFromAI(data) {
        console.log("Updating AI display UI...");
        try {
            const aiOutput            = getSafe(() => data.aiOutput, {});
            const analysisEl          = document.getElementById('aiAnalysis');
            const recommendationsList = document.getElementById('recommendationsList');
            const progressContentEl   = document.getElementById('progressContent');

            /* ---- AI analysis text ---- */
            // Using textContent first and then converting newlines for safety against unexpected HTML
            const rawAnalysis = getSafe(() => aiOutput.analysis, 'Analysis not available.');
            const formattedAnalysis = rawAnalysis
                .replace(/\\n/g, '\n')   // literal “\n” → newline
                .replace(/\n/g, '<br>'); // newline      → <br>
            if (analysisEl) updateElementHTML('aiAnalysis', formattedAnalysis);
             else { console.warn("AI analysis element (#aiAnalysis) not found."); }


            /* ---- Recommendations ---- */
            if (recommendationsList) {
                const rawRecs = getSafe(() => aiOutput.recommendations, '');
                const items = rawRecs
                    .split(/\r?\n/)
                    .map(t => t.trim())
                    .filter(Boolean);
                recommendationsList.innerHTML = items.length
                    ? items.map(txt => `<li>${txt}</li>`).join('')
                    : '<li class="text-gray-500">No recommendations available.</li>';
            } else { console.warn("Recommendations list element (#recommendationsList) not found."); }

            /* ---- Progress history ---- */
            if (progressContentEl) {
                const rawProgress = getSafe(() => aiOutput.userProgress, 'No progress history available.');
                 const formattedProgress = rawProgress.replace(/\\n/g, '\n'); // literal “\n” → newline for modal pre-wrap
                progressContentEl.textContent = formattedProgress; // Use textContent for pre
            } else { console.warn("Progress content element (#progressContent) not found."); }
            console.log("AI display UI updated.");
        } catch (e) {
            console.error("Error updating AI display UI:", e);
        }
    }

    // Helper function to show initial message when no data is found
    function showInitialPromptOrMessage(message = "Upload a PSR JSON file or sign in with Google Drive to load your dashboard.") { // Updated default message
        console.log("Executing showInitialPromptOrMessage");
        hideAllMainContentAreas(); // Hide everything else first

        // Prefer showing the structured upload prompt if available
        if (initialUploadPrompt) {
            initialUploadPrompt.style.display = 'block';
             // Ensure the upload button listener is active for this state
            const initialUploadButton = document.getElementById('initialUploadButton');
            if (initialUploadButton && fileInput) {
                // Listener is added in initializeSupabaseAndCoreFeatures, just ensure button is visible if needed
                 initialUploadButton.style.display = 'inline-block'; // Assuming it's part of the prompt div
                 console.log("Initial upload prompt and button visible.");
            } else {
                 console.warn("Initial upload button or file input not found.");
            }

        } else if (initialMessageElement) {
             // Fallback to simple message if prompt not found
            initialMessageElement.textContent = message;
            initialMessageElement.style.display = 'block';
            console.log("Displayed fallback initial message element.");
        } else {
             console.warn("Could not find initial prompt or message elements.");
        }

        // Ensure chat is hidden if we revert to the initial state
        if (chatInterfaceCardElement) { chatInterfaceCardElement.style.display = 'none'; }
        enableChatInput(false); // Disable chat input as well
         setChatStatus("No data loaded", false);
         // Hide Drive buttons if signed out or not loaded, show Sign In
         updateDriveButtonVisibility(false); // This will make sure the sign-in button is visible if not signed in
    }

     // Helper to hide all potential main content/initial states
     function hideAllMainContentAreas() {
         if (loadingSpinner) loadingSpinner.style.display = 'none';
         if (errorMessageElement) errorMessageElement.style.display = 'none';
         if (mainContentElement) { mainContentElement.style.display = 'none'; mainContentElement.classList.add('hidden'); }
         if (initialMessageElement) initialMessageElement.style.display = 'none';
         if (initialUploadPrompt) initialUploadPrompt.style.display = 'none';
         closeModal('driveLoadModal'); // Close the Drive load modal if open
         closeModal('progressModal'); // Close other modals too
         closeModal('infoModal');
     }

     // Handle window resize to potentially re-render charts for responsiveness
     function handleResize() {
         //console.log("Window resized. Attempting to relayout charts..."); // Commented out - too noisy
         const incomeChartDiv = document.getElementById('incomeChart');
         const expenseChartDiv = document.getElementById('expenseChart');

         // Check if plotly is available and the divs exist and contain a chart
         if (typeof Plotly !== 'undefined') {
             if (incomeChartDiv && incomeChartDiv.data) { // Check if Plotly data is attached
                 //console.log("Relayouting Income Chart...");
                 Plotly.relayout(incomeChartDiv, { autosize: true });
             }
             if (expenseChartDiv && expenseChartDiv.data) { // Check if Plotly data is attached
                  //console.log("Relayouting Expense Chart...");
                 Plotly.relayout(expenseChartDiv, { autosize: true });
             }
         } // else { console.warn("Plotly not available for relayout on resize."); } // Commented out - too noisy
     }

    // --- Chat Functionality ---
    // handleChatEnterKey, autoGrowTextarea, enableChatInput, addMessageToChat, setChatStatus already defined above

     // Function to handle the enter key press in the chat input
     function handleChatEnterKey(event) {
         if (event.key === 'Enter' && !event.shiftKey) { // Send on Enter, allow Shift+Enter for newline
             event.preventDefault(); // Prevent default newline insertion
             handleChatSubmit(); // Trigger send action
         }
     }

     // Function to auto-grow the textarea height based on content
     function autoGrowTextarea(event) {
         const textarea = event.target;
         textarea.style.height = 'auto'; // Temporarily shrink to base height
         // Calculate the desired height: at least minHeight, based on scrollHeight, max maxHeight
         const minHeight = 88; // Define minimum height here (matches CSS)
         const maxHeight = 120; // Define maximum height here (matches CSS)
         textarea.style.height = Math.min(Math.max(textarea.scrollHeight, minHeight), maxHeight) + 'px';
         // Ensure scrollbar appears if scrollHeight exceeds maxHeight
         textarea.style.overflowY = (textarea.scrollHeight > maxHeight) ? 'auto' : 'hidden';
     }


     // Function to enable/disable the chat input and send button
     function enableChatInput(enabled) {
         const chatInput = document.getElementById('chatInput');
         const chatSendButton = document.getElementById('chatSendButton');
         if (chatInput && chatSendButton) {
             chatInput.disabled = !enabled;
             chatSendButton.disabled = !enabled;
             chatInput.placeholder = enabled ? "Ask about your finances..." : "Chat unavailable";
             // Adjust visual state
             chatInput.style.opacity = enabled ? '1' : '0.6';
             chatSendButton.style.opacity = enabled ? '1' : '0.6';
             chatSendButton.style.cursor = enabled ? 'pointer' : 'not-allowed';
              //if (!enabled) chatInput.value = ''; // Clear input if disabling - maybe too aggressive?
         } else {
             console.warn("Could not find chat input or send button to enable/disable.");
         }
     }

     // Function to add a message bubble to the chat history display
     function addMessageToChat(sender, message, isError = false) {
         const chatHistory = document.getElementById('chatHistory');
         if (!chatHistory) {
             console.error("Chat history element not found.");
             return;
         }

         const messageContainer = document.createElement('div');
         // Sanitize sender string for class name just in case
         const senderClass = sender ? sender.toLowerCase().replace(/[^a-z0-9]/g, '') : 'system'; // Default to system
         messageContainer.classList.add('chat-message', senderClass);

         const bubble = document.createElement('div');
         bubble.classList.add('message-bubble');

         if (isError) { // Style error messages distinctly within the bubble
             bubble.style.backgroundColor = '#fee2e2'; // Tailwind red-100
             bubble.style.color = '#b91c1c'; // Tailwind red-700
             bubble.style.borderColor = '#fca5a5'; // Tailwind red-300
             bubble.style.borderWidth = '1px';
             bubble.style.borderStyle = 'solid';
         }

         // Basic Markdown-like handling: [text](url) -> <a href="url">text</a>, **text** -> <strong>text</strong>
         // Convert newlines to <br> for HTML display
          // Basic sanitization: replace < and > to prevent simple injection
         const safeMessage = message.replace(/</g, "&lt;").replace(/>/g, "&gt;");
         const formattedMessage = safeMessage
             .replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer" class="text-indigo-600 hover:underline font-medium">$1</a>')
             .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Handle bold
             .replace(/\n/g, '<br>'); // Convert newlines

         bubble.innerHTML = formattedMessage; // Assign the processed HTML
         messageContainer.appendChild(bubble);
         chatHistory.appendChild(messageContainer);

         // Scroll to the bottom smoothly
         chatHistory.scrollTo({ top: chatHistory.scrollHeight, behavior: 'smooth' });
     }

     // Function to set the chat status message (like "Thinking..." or "Ready")
     function setChatStatus(message, isLoading = false) {
         const chatStatusContainer = document.getElementById('chatStatusContainer'); // Use the container ID
         const chatThinkingIndicator = document.getElementById('chatThinkingIndicator');

         if (!chatStatusContainer || !chatThinkingIndicator) {
             console.warn("Chat status elements not found.");
             return;
         }

         // Hide thinking indicator by default
         chatThinkingIndicator.style.display = 'none';

         // Update main status text display (e.g., Tier | Model | Usage)
         // This requires the spans inside chatStatusContainer to be updated separately
         // The status message should probably be handled differently, perhaps in a dedicated span?
         // Let's just show the thinking indicator and hide it when done.
         // The message text could be part of the indicator or a separate span.

         // Let's make the indicator *contain* the loading message
         if (isLoading) {
              chatThinkingIndicator.style.display = 'inline-block'; // Show the indicator container
             // The "Thinking..." text is already part of the indicator HTML structure
         } else {
             // When not loading, the indicator is hidden.
             // The static status display (Tier | Model | Usage) should remain visible.
             // The message text can be displayed briefly somewhere else if needed, but the current structure doesn't have a dedicated spot for the message *when not loading*.
             // For now, just managing the thinking indicator based on `isLoading` is sufficient based on the provided HTML structure.
             // The main status text (Tier/Model/Usage) is updated by updateUIBasedOnAccess.
             console.log("Set chat status: ", message, isLoading ? "(Loading)" : "(Idle)");
         }
     }

    // Function to initialize chat UI state and listeners
    function initializeChat() {
        console.log("--- initializeChat START ---");

        // Cache chat elements here if not already done
        chatInterfaceCardElement = chatInterfaceCardElement || document.getElementById('chatInterfaceCard');
        const chatInput = document.getElementById('chatInput');
        const chatSendButton = document.getElementById('chatSendButton');
        const chatHistory = document.getElementById('chatHistory');

        if (!chatInput || !chatSendButton || !chatHistory || !chatInterfaceCardElement) {
            console.error("One or more Chat UI elements not found! Aborting chat initialization.");
            if (chatInterfaceCardElement) chatInterfaceCardElement.style.display = 'none';
            enableChatInput(false);
            setChatStatus("Chat UI elements missing", false);
            return;
        }

        // SIMPLIFIED CHECK: Ensure Supabase client exists and fetch is available
        const isReadyForChat = supabase && typeof fetch === 'function';
        console.log("Is environment ready for chat (Supabase client + fetch)?", isReadyForChat);

        // Determine if chat CAN be enabled based on user/usage (from global state)
        // Check if initialUsageInfo is available and has a valid usage/limit property
        const canEnableChat = currentUserId && initialUsageInfo && !initialUsageInfo.error && initialUsageInfo.usage !== undefined && initialUsageInfo.limit !== undefined && initialUsageInfo.usage < initialUsageInfo.limit;
        console.log("Can chat be enabled based on user/usage state?", canEnableChat);

        if (isReadyForChat && canEnableChat) {
            chatInterfaceCardElement.style.display = 'block'; // Show the card
            enableChatInput(true); // Enable input fields
            setChatStatus("", false); // Clear any previous status, ensure indicator is hidden

            // Clear and rebuild chat history display based on chatMessages array
            chatHistory.innerHTML = '';
            if (chatMessages.length === 0 || !chatMessages.some(msg => msg.role === 'assistant' && msg.content.includes("Hello! Ask me anything"))) {
                // Add initial assistant message only if chat history is empty or doesn't contain the greeting
                const initialMsgContent = "Hello! Ask me anything about the financial data shown on your dashboard.";
                addMessageToChat("Assistant", initialMsgContent, false);
                // Don't push initial greeting to history array unless you want it saved/resent
                // chatMessages.push({ role: "assistant", content: initialMsgContent }); // Decide if greeting should be saved
            } else {
                // Restore previous messages from history array
                chatMessages.forEach(msg => addMessageToChat(msg.role.charAt(0).toUpperCase() + msg.role.slice(1), msg.content));
            }
            // Scroll to the latest message after loading history
            chatHistory.scrollTop = chatHistory.scrollHeight;

            // Ensure listeners are attached only once or re-attached correctly
            // Using a flag or removing/adding is safer
            chatSendButton.removeEventListener('click', handleChatSubmit);
            chatInput.removeEventListener('keydown', handleChatEnterKey);
            chatInput.removeEventListener('input', autoGrowTextarea);

            chatSendButton.addEventListener('click', handleChatSubmit);
            chatInput.addEventListener('keydown', handleChatEnterKey);
            chatInput.addEventListener('input', autoGrowTextarea);
            autoGrowTextarea({ target: chatInput }); // Adjust height initially

            console.log("Chat UI initialized and enabled.");

        } else {
            // Chat cannot be enabled - figure out why and set status
            console.log("Chat setup skipped or disabled. Reasons:", {
                 isReadyForChat,
                 canEnableChat,
                 hasUserId: !!currentUserId,
                 hasUsageInfo: !!initialUsageInfo,
                 usageInfoError: initialUsageInfo?.error,
                 limitReached: initialUsageInfo && initialUsageInfo.limit !== undefined && initialUsageInfo.usage >= initialUsageInfo.limit
            });
            if (chatInterfaceCardElement) chatInterfaceCardElement.style.display = 'none'; // Ensure hidden
            enableChatInput(false); // Disable input

            // Set appropriate status message in the main status bar area
            if (!initialUsageInfo) {
                 // Status already shows "Loading..." initially, let that handle it
                 setChatStatus("Loading access info...", true); // Keep loading indicator if info isn't fetched
            } else if (initialUsageInfo.error) {
                 setChatStatus("Chat unavailable - Access Error", false);
            } else if (!isReadyForChat) {
                 setChatStatus("Chat unavailable - Service Offline", false);
            } else if (!currentUserId) {
                 setChatStatus("Chat unavailable - Authentication needed", false); // User ID needed for Supabase functions
            } else if (initialUsageInfo.limit !== undefined && initialUsageInfo.usage >= initialUsageInfo.limit) {
                 setChatStatus("Weekly token limit reached", false);
                 if (chatInterfaceCardElement) chatInterfaceCardElement.style.display = 'block'; // Show card but disabled state
            } else {
                  setChatStatus("Chat unavailable", false); // Generic fallback
            }
        }
        console.log("--- initializeChat END ---");
    }

    // Function to handle sending a chat message when the send button is clicked
    function handleChatSubmit() {
        const chatInput = document.getElementById('chatInput');
        if (!chatInput) return; // Safety check

        const userMessage = chatInput.value.trim();
        if (!userMessage || chatInput.disabled) {
             console.log("Attempted to send empty or disabled message.");
            return; // Don't send empty messages or if disabled
        }

        addMessageToChat("User", userMessage);
        chatMessages.push({ role: "user", content: userMessage }); // Add user message to history array
        chatInput.value = ''; // Clear input field
        chatInput.style.height = 'auto'; // Reset height after send - autoGrow listener will re-adjust
        //chatInput.style.height = '88px'; // Force back to original size

        sendToBackendChatFunction(); // Call backend function
    }


    // --- Updated sendToBackendChatFunction --- (See Part 2 for implementation)
    // ... (function sendToBackendChatFunction is defined above) ...


    // --- Modals ---
    function initModals() {
        console.log("Initializing modals...");
        // Close modal if clicking on the background overlay
        window.addEventListener('click', function(event) {
            const modals = document.getElementsByClassName('modal');
            for (let i = 0; i < modals.length; i++) {
                if (event.target == modals[i]) { // Check if the click target is the modal background itself
                    closeModal(modals[i].id); // Close the modal using its ID
                }
            }
        });
        // Add ESC key listener to close modals
        document.addEventListener('keydown', function(event) {
            if (event.key === "Escape") {
                const modals = document.getElementsByClassName('modal');
                for (let i = 0; i < modals.length; i++) {
                    if (modals[i].style.display === "block") {
                        closeModal(modals[i].id);
                        event.preventDefault(); // Prevent other escape handlers
                        break; // Only close one modal at a time
                    }
                }
            }
        });
         console.log("Modals initialized.");
    }

    function openModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            // Optional: Refresh modal content if dynamic before showing
            if(modalId === 'progressModal' && dashboardData?.aiOutput) {
                const progressContentEl = document.getElementById('progressContent');
                if(progressContentEl) {
                    const rawProgress = getSafe(() => dashboardData.aiOutput.userProgress, 'No progress history available.');
                    const formattedProgress = rawProgress.replace(/\\n/g, '\n');
                    progressContentEl.textContent = formattedProgress; // Use textContent for pre
                }
            } else if (modalId === 'driveLoadModal') {
                 // Content for driveLoadModal is populated by handleLoadFromDriveClick
                 console.log("Opening driveLoadModal. Content should be populated by handler.");
            }

            modal.style.display = "block";
        } else { console.warn(`Modal with ID ${modalId} not found.`); }
    }

    function closeModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = "none";
        }
    }

    /* --- Save Summary workflow --- */
    function generateAndSaveSummary() {
        // Placeholder implementation to prevent ReferenceError
        // TODO: Implement summary generation and saving logic here
        console.log("generateAndSaveSummary called");
    }

    /* --- Generate New Analysis Workflow --- */
    function generateAndDisplayNewSummary() {
        // Placeholder implementation to prevent ReferenceError
        // TODO: Implement summary generation and display logic here
        console.log("generateAndDisplayNewSummary called");
    }

    /* --- Info popup support --- */
    function showInfo(text) {
        const infoModalText = document.getElementById('infoModalText');
        const infoModal = document.getElementById('infoModal');
        if(infoModalText && infoModal) {
            infoModalText.textContent = text; // Use textContent for safety
            openModal('infoModal');
        } else {
            console.warn("Info modal elements not found.");
            alert(text); // Fallback to simple alert
        }
    }

    function initInfoPopups() {
        console.log("Initializing info popups...");
        // Use event delegation on a parent container for potentially dynamic elements
        const mainContainer = document.getElementById('mainContent');
        if (mainContainer) {
            mainContainer.addEventListener('click', function(event) {
                // Find the closest ancestor with data-desc attribute
                const targetElement = event.target.closest('[data-desc]');
                if (targetElement) {
                    const description = targetElement.dataset.desc;
                    if (description) {
                        showInfo(description);
                    }
                }
            });
            console.log("Info popups initialized via event delegation.");
        } else {
            console.warn("Main content container not found for info popup delegation.");
        }
    }

    // Function to bundle Supabase/Core initializations
    function initializeSupabaseAndCoreFeatures() {
        console.log("Initializing Supabase client and core features...");
        try {
            // Initialize Supabase client - Check if window.supabase is available first
            if (!supabase) {
                 if (typeof window.supabase === 'undefined' || !window.supabase?.createClient) {
                     console.error("Supabase library (supabase-js) is not loaded. Cannot initialize client.");
                     // Proceed without Supabase client - chat will be disabled
                 } else {
                     const { createClient } = window.supabase;
                     // Use ANON key for client-side initialization
                     supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                     console.log("Supabase client initialized successfully.");
                 }
            } else {
                 console.log("Supabase client already initialized.");
            }

            // Cache Google Drive buttons and user display element
            googleSignInButton = document.getElementById('googleSignInButton');
            googleSignOutButton = document.getElementById('googleSignOutButton');
            loadFromDriveButton = document.getElementById('loadFromDriveButton');
            saveToDriveButton = document.getElementById('saveToDriveButton');
            downloadLocalButton = document.getElementById('downloadLocalButton');
            signedInUserDisplayElement = document.getElementById('signedInUserDisplay');


            // Initialize Google APIs (GIS and Gapi) - This will handle showing the sign-in button
            loadGoogleAPIs(); // This calls  and handles Gapi load

            // Initialize other features (buttons, modals, popups etc.) - These should run regardless of Supabase
            // Removed redundant initSaveButton, initUploadButton as listeners are added below or in DOMContentLoaded
            if (typeof initModals === 'function') initModals(); else console.warn("initModals function not found.");
            if (typeof initInfoPopups === 'function') initInfoPopups(); else console.warn("initInfoPopups function not found.");

            // Add listeners for error message buttons
           document.getElementById('retryButton')?.addEventListener('click', () => {
    console.warn("Retry button clicked. Initiating page reload."); // Add this log
    location.reload();
});
            document.getElementById('manualEntryButton')?.addEventListener('click', useDemoData);

             // Setup save summary button
            document.getElementById('saveSummaryBtn')?.addEventListener('click', generateAndSaveSummary);
            document.getElementById('generateAnalysisBtn')?.addEventListener('click', generateAndDisplayNewSummary);

            // Setup listeners for File Input (for manual upload)
            if (fileInput) {
                 fileInput.addEventListener('change', handleManualFileUpload);
                 // Add listener for the initial upload button if it exists
                 const initialUploadButton = document.getElementById('initialUploadButton');
                 if(initialUploadButton) {
                     initialUploadButton.addEventListener('click', () => fileInput.click());
                 }
                 console.log("Manual file upload listeners initialized.");
            } else { console.warn("File input element not found."); }


            // Setup listeners for Google Drive buttons (handlers implemented below)
            if (loadFromDriveButton) {
                 loadFromDriveButton.addEventListener('click', handleLoadFromDriveClick);
                 console.log("Load from Drive button listener added.");
            } else { console.warn("Load from Drive button not found."); }

            if (saveToDriveButton) {
                 saveToDriveButton.addEventListener('click', handleSaveToDriveClick);
                 console.log("Save to Drive button listener added.");
            } else { console.warn("Save to Drive button not found."); }

            // Setup listener for Google Sign Out button
             if (googleSignOutButton) {
                 googleSignOutButton.addEventListener('click', handleGoogleSignOut);
                 console.log("Sign Out button listener added.");
             } else { console.warn("Sign Out button not found."); }

            // Setup listener for local Download button
             if (downloadLocalButton) {
                 downloadLocalButton.addEventListener('click', handleLocalDownload);
                 console.log("Local Download button listener added.");
             } else { console.warn("Local Download button not found."); }


            // Initial fetch for usage info and then update UI based on that access
            // This also handles initializing the chat UI based on initial state
            fetchInitialUsage();


            // Ensure spinner is hidden finally if not already handled
            // This is also done by handleError and processAndDisplayData finally blocks,
            // but a final check here can't hurt if logic somehow bypasses others.
            // Removed this from here, let the specific flows manage the spinner.

        } catch (initError) {
            console.error("Error initializing Supabase/core features:", initError);
             // If core initialization fails, likely can't recover well. Use error handler.
             handleError("Core Initialization Failed", initError);
        }
    }

    // Helper function to show initial message when no data is found
    function showInitialPromptOrMessage(message = "Upload a PSR JSON file or sign in with Google Drive to load your dashboard.") { // Updated default message
        console.log("Executing showInitialPromptOrMessage");
        hideAllMainContentAreas(); // Hide everything else first

        // Prefer showing the structured upload prompt if available
        if (initialUploadPrompt) {
            initialUploadPrompt.style.display = 'block';
             // Ensure the upload button listener is active for this state
            const initialUploadButton = document.getElementById('initialUploadButton');
            if (initialUploadButton && fileInput) {
                // Listener is added in initializeSupabaseAndCoreFeatures, just ensure button is visible if needed
                 initialUploadButton.style.display = 'inline-block'; // Assuming it's part of the prompt div
                 console.log("Initial upload prompt and button visible.");
            } else {
                 console.warn("Initial upload button or file input not found.");
            }

        } else if (initialMessageElement) {
             // Fallback to simple message if prompt not found
            initialMessageElement.textContent = message;
            initialMessageElement.style.display = 'block';
            console.log("Displayed fallback initial message element.");
        } else {
             console.warn("Could not find initial prompt or message elements.");
        }

        // Ensure chat is hidden if we revert to the initial state
        if (chatInterfaceCardElement) { chatInterfaceCardElement.style.display = 'none'; }
        enableChatInput(false); // Disable chat input as well
         setChatStatus("No data loaded", false);
         // Hide Drive buttons if signed out or not loaded, show Sign In
         updateDriveButtonVisibility(!!googleAccessToken); // Use current token status to update visibility
    }

     // Helper to hide all potential main content/initial states
     function hideAllMainContentAreas() {
         if (loadingSpinner) loadingSpinner.style.display = 'none';
         if (errorMessageElement) errorMessageElement.style.display = 'none';
         if (mainContentElement) { mainContentElement.style.display = 'none'; mainContentElement.classList.add('hidden'); }
         if (initialMessageElement) initialMessageElement.style.display = 'none';
         if (initialUploadPrompt) initialUploadPrompt.style.display = 'none';
         closeModal('driveLoadModal'); // Close the Drive load modal if open
         closeModal('progressModal'); // Close other modals too
         closeModal('infoModal');
     }

     // Handle window resize to potentially re-render charts for responsiveness
     function handleResize() {
         //console.log("Window resized. Attempting to relayout charts..."); // Commented out - too noisy
         const incomeChartDiv = document.getElementById('incomeChart');
         const expenseChartDiv = document.getElementById('expenseChart');

         // Check if plotly is available and the divs exist and contain a chart
         if (typeof Plotly !== 'undefined') {
             if (incomeChartDiv && incomeChartDiv.data) { // Check if Plotly data is attached
                 //console.log("Relayouting Income Chart...");
                 Plotly.relayout(incomeChartDiv, { autosize: true });
             }
             if (expenseChartDiv && expenseChartDiv.data) { // Check if Plotly data is attached
                  //console.log("Relayouting Expense Chart...");
                 Plotly.relayout(expenseChartDiv, { autosize: true });
             }
         } // else { console.warn("Plotly not available for relayout on resize."); } // Commented out - too noisy
     }

     // --- Google API Loading and Initialization ---
    // Load GIS (for authentication) and Gapi (for API calls) libraries
    function loadGoogleAPIs() {
        console.log("Loading Google APIs...");
        // GIS script tag added directly in HTML head with onload="initializeGIS()"
        // Gapi script tag added directly in HTML head with onload="handleGapiLoad()"

        // We rely primarily on the script tag onload attributes for timing,
        // but these checks can act as fallbacks if the scripts load before DOMContentLoaded
        // or if for some reason onload doesn't fire immediately.

        // Check if gapi library is already available (might be if script loaded very fast)
        if (typeof gapi !== 'undefined') {
             // If gapi is available, call its onload handler to load the 'client' module
             handleGapiLoad();
        } else {
             // If gapi is not immediately available, the script's onload will call handleGapiLoad later.
             console.log("Gapi not immediately available, waiting for script load.");
        }

         // Check if GIS library is already available
         if (typeof google !== 'undefined' && typeof google.accounts !== 'undefined') {
             // If GIS is available, call its onload handler to initialize the token client
             initializeGIS();
         } else {
             // If GIS is not immediately available, the script's onload will call initializeGIS later.
             console.log("GIS not immediately available, waiting for script load.");
         }
    } // <-- This is the correct closing brace for loadGoogleAPIs

// Handle Gapi library load (triggered by the script tag)
function handleGapiLoad() {
    console.log("Gapi library loaded. Loading 'client' module...");
    // Load the core client library, which is necessary before using gapi.client
    gapi.load('client', () => {
         console.log("Gapi 'client' module loaded and ready.");
         // At this point, gapi.client should be available.
         // We don't need to do anything else here immediately,
         // the token setting and Drive API load happen in handleGoogleTokenResponse
         // after a successful sign-in.
    });
}


       // Initialize GIS (Google Identity Services) - Triggered by the GIS script tag onload
    function initializeGIS() {
        console.log("GIS library loaded. Initializing token client...");
        // Check if the Google Identity Services library is available
        // Use a short delay to potentially give the library a moment if needed, though onload should mean ready
         setTimeout(() => { // Adding a small delay for resilience
             if (typeof google === 'undefined' || typeof google.accounts === 'undefined' || typeof google.accounts.oauth2 === 'undefined') {
                  console.error("GIS library not available after load timeout.");
                  console.warn("Google Identity Services library not available. Google Drive features disabled.");
                  // Explicitly hide buttons if GIS failed to load, show sign-in is pointless
                  updateDriveButtonVisibility(false);
                  if (googleSignInButton) googleSignInButton.style.display = 'none';
                  setChatStatus("Google sign-in setup failed.", false);
                  return; // Exit function if library isn't available
             }

             try {
                 // Initialize the Google Identity Services token client
                 // The callback handles success and 'interaction_required' responses.
                 // The error_callback handles other issues like popup blocked or invalid requests.
                 googleTokenClient = google.accounts.oauth2.initTokenClient({
                     client_id: GOOGLE_CLIENT_ID, // Should be your correct Client ID constant
                     scope: GOOGLE_SCOPES,
                     callback: handleGoogleTokenResponse, // <-- Success and 'interaction_required' responses go here
                     error_callback: (error) => { // <-- Other errors go here (e.g. popup blocked, invalid_request, etc.)
                         console.error("GIS initTokenClient error:", error);
                         // Handle errors that prevent the callback from even being called, like popup blockers.
                         // 'immediate_failed' from prompt: 'none' might also end up here.
                          if (error.type === 'popup_closed' || error.error === 'popup_closed_by_user') {
                              console.log("Google Sign-In popup closed by user.");
                              setChatStatus("Sign-in cancelled", false);
                          } else if (error.error === 'immediate_failed') {
                              // This typically comes from the silent prompt: 'none' attempt failing outright
                              console.log("Silent Google Sign-In failed outright (immediate_failed).");
                              setChatStatus("Sign-in needed", false); // Prompt user to click the button
                          } else {
                              // Handle other unexpected GIS errors more seriously, might need user info for handleError
                              console.error("Other unexpected GIS error:", error); // Log the full error object
                              // Pass the error to the central handler if it's not a known silent failure/cancellation
                              handleError("Google Sign-In Process Error", new Error(`GIS error during request: ${error.message || error.error || 'Unknown error'}`));
                          }
                          // In case of any error in the error_callback, ensure buttons reflect not signed in state
                          updateDriveButtonVisibility(!!googleAccessToken); // Should evaluate to false here
                     }
                 });
                 console.log("GIS token client initialized.");

                 // --- Add the click listener to the sign-in button ---
                 // Ensure the button element is cached before adding the listener
                 googleSignInButton = googleSignInButton || document.getElementById('googleSignInButton');
                 if (googleSignInButton && googleTokenClient) {
                     // Remove existing listener to prevent duplicates if initializeGIS is somehow called more than once
                      // Using an inline function handler below, so no specific name to remove.
                      // If you make handleGoogleSignInClick a separate named function, use removeEventListener.
                      // For simplicity with inline: just add the listener; if initializeGIS runs twice, listener is added twice (harmless).
                     googleSignInButton.addEventListener('click', () => {
                         console.log("Google Sign-In button clicked. Requesting access token...");
                         // Request an access token for user interaction. This will trigger the callback upon completion.
                         googleTokenClient.requestAccessToken();
                         setChatStatus("Waiting for sign-in...", true); // Provide user feedback
                     });
                     console.log("Google Sign-In button listener added.");
                 } else {
                      console.warn("Google Sign-In button element or token client not available to add listener.");
                 }

                 // --- Attempt silent re-authentication on page load ---
                 // This should be called *after* the googleTokenClient is initialized.
                 // It checks if the user has a valid, recent session and attempts to get an access token silently.
                 // If successful, handleGoogleTokenResponse is called with the token.
                 // If not successful (no valid session, user needs to pick account, etc.), the callback (handleGoogleTokenResponse)
                 // is called with { error: 'interaction_required' } or { error: 'access_denied' }.
                 if (googleTokenClient) { // Ensure the client object exists before calling its method
                      console.log("Attempting silent Google re-authentication...");
                      // Use prompt: 'none' for a silent check.
                      googleTokenClient.requestAccessToken({ prompt: 'none' });
                      // The response (success or interaction_required/access_denied) goes to handleGoogleTokenResponse.
                      // Other errors go to the error_callback defined above.
                 } else {
                     console.warn("Google Token client not available to attempt silent re-auth. Skipping silent check.");
                 }
                 // --- END Silent Re-auth ---


                  // Explicitly update button visibility here once GIS is initially ready.
                  // At this point, googleAccessToken is likely null (unless a token was cached somehow very early),
                  // so this will typically show the sign-in button by default.
                  // The result of the silent re-auth attempt above will then update the UI via handleGoogleTokenResponse or the error_callback.
                  updateDriveButtonVisibility(!!googleAccessToken); // Show/hide based on initial token state


             } catch (e) { // Catch errors during the GIS initialization itself (initTokenClient call fails)
                  console.error("Error initializing GIS token client:", e);
                  handleError("Google Sign-In Setup Failed", e); // Report the error using the central handler
             }
         }, 100); // Add a small delay (100ms) before init as a precaution

    } // <-- End of initializeGIS function

           
    // Handle the response from the Google Token Client (Authorization Response)
    // This function is called by the Google GIS library after:
    // 1. A successful interactive sign-in (tokenResponse contains access_token).
    // 2. A successful silent re-authentication (tokenResponse contains access_token).
    // 3. A failed silent re-authentication where interaction is required (tokenResponse contains error: 'interaction_required').
    // 4. User denies permissions during interactive flow (tokenResponse contains error: 'access_denied').
    // 5. User closes the popup (tokenResponse contains error: 'popup_closed_by_user').
    function handleGoogleTokenResponse(tokenResponse) {
        console.log("Google token response received:", tokenResponse);
        // Always ensure previous error state is cleared from UI before processing the response
        hideAllMainContentAreas(); // Ensure error message modal is hidden if it was showing

        // Check if the response contains a valid access token (SUCCESS PATH)
        if (tokenResponse && tokenResponse.access_token) {
            console.log("Google token response successful. Access token obtained.");
            googleAccessToken = tokenResponse.access_token; // Store the token globally
            console.log("Access Token obtained (length:", googleAccessToken.length, ")."); // Log length, not full token for security

            // Inject the obtained token into the gapi.client library for making API calls
            // Check if gapi.client is available and has setToken method
            if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined' && typeof gapi.client.setToken === 'function') {
                gapi.client.setToken({ access_token: googleAccessToken });
                console.log("Token set in gapi.client.");

                // Now that we have a token and it's set in gapi.client, load the Drive API library.
                // gapi.client.load uses promises and handles idempotency (safe to call multiple times).
                 gapi.client.load('drive', 'v3')
                    .then(() => {
                        console.log("Google Drive API v3 loaded successfully after sign-in.");
                        // The Drive API (gapi.client.drive) is now ready to use.
                        // Update button visibility to show Drive-related buttons (Load/Save), hide sign-in.
                        updateDriveButtonVisibility(true);
                        // Fetch user info for display (e.g., "Signed in as...")
                        fetchGoogleUserInfo();

                        // --- Determine what to do after successful sign-in ---
                        // If dashboard data is NOT already loaded (e.g., from URL params),
                        // attempt to automatically load the user's file from Drive.
                         if (!dashboardData || !dashboardData.userInput || Object.keys(getSafe(() => dashboardData.userInput, {})).length === 0) {
                             console.log("No data loaded from URL. Attempting auto-load from Drive after sign-in.");
                             // Show spinner while loading from Drive
                             if (loadingSpinner) loadingSpinner.style.display = 'flex';
                             setChatStatus("Loading from Drive...", true);
                             // Call the function to initiate loading from Drive.
                             // handleLoadFromDriveClick manages its own loading state and error display.
                             handleLoadFromDriveClick();

                         } else {
                             // If data was already loaded (e.g., from URL params),
                             // just show the main dashboard with updated buttons and indicate signed-in status.
                             console.log("Data already loaded from URL. Skipping auto-load from Drive.");
                             // Ensure main content is visible if it wasn't already (e.g., if XTl loaded structure but no data)
                              // Note: processAndDisplayData usually handles showing mainContent. If data was loaded
                              // from URL *before* this, mainContent might already be visible.
                              // This ensures it's visible if the initial state was 'no data, but XTL valid'.
                             if (mainContentElement) {
                                mainContentElement.style.display = 'block';
                                mainContentElement.classList.remove('hidden');
                             }
                             if (loadingSpinner) loadingSpinner.style.display = 'none'; // Hide spinner if it was on
                             setChatStatus("Signed in to Drive", false); // Indicate successful sign-in
                             // Ensure buttons are correctly visible when data is loaded and signed in (redundant but safe)
                              updateDriveButtonVisibility(true);
                         }

                    })
                    .catch((loadError) => {
                         console.error("Error loading Google Drive API after sign-in:", loadError);
                         // This is a failure *after* authentication, but related to API access.
                         // Treat as an error but ensure token/sign-in state is kept.
                         // Don't clear googleAccessToken here.
                         handleError("Google Drive API Load Failed", loadError); // Report the error using central handler
                         // Ensure Drive buttons are hidden if the API failed to load
                         updateDriveButtonVisibility(false); // SignedIn will be true, but Load/Save require API
                         setChatStatus("Drive API Failed", false);
                    });

            } else {
                // This case should ideally not happen if gapi.js loaded correctly via onload=handleGapiLoad()
                // and handleGapiLoad successfully loaded the 'client' module.
                // It means gapi.client is somehow not ready *even though* auth succeeded.
                console.error("Gapi client not available to set token after successful response. Ensure api.js and 'client' module are loaded.");
                 googleAccessToken = null; // Clear token as gapi.client is broken
                 googleUser = null; // Clear user info
                 driveFolderId = null; // Clear cached folder ID
                handleError("Google API Client Setup Failed", new Error("Google API client not fully ready after authentication.")); // Report the error
                updateDriveButtonVisibility(false); // Hide Drive buttons
                 setChatStatus("API Client Failed", false);
            }

        // --- Handle expected non-fatal error responses (interaction_required, access_denied, etc.) ---
        // These are results where a token was NOT obtained, but it's a known state that doesn't
        // necessarily indicate a critical application error needing the full handleError modal.
        // This handles failures from both silent ('prompt:none') and interactive ('prompt:auto') requests.
        } else if (tokenResponse && (tokenResponse.error === 'interaction_required' || tokenResponse.error === 'access_denied' || tokenResponse.error === 'popup_closed_by_user')) {
             console.warn("Google token response indicated interaction is required or access denied/cancelled:", tokenResponse.error, tokenResponse.error_description);
             googleAccessToken = null; // Ensure token is null as authentication was NOT successful
             googleUser = null; // Clear user info display
             // Clear token from gapi.client if it was somehow set previously
             if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined' && typeof gapi.client.setToken === 'function') {
                 gapi.client.setToken(null);
             }
             driveFolderId = null; // Clear cached folder ID

             // Update UI to show the sign-in button and reflect not signed in status
             updateDriveButtonVisibility(false); // Pass false because we are NOT signed in (no token)
             signedInUserDisplayElement = signedInUserDisplayElement || document.getElementById('signedInUserDisplay');
              if (signedInUserDisplayElement) {
                  signedInUserDisplayElement.textContent = '';
                  signedInUserDisplayElement.style.display = 'none';
              }

             // Set status message indicating user needs to click the button
             setChatStatus("Sign-in needed", false);

        // --- Handle any other unexpected errors in the token response ---
        } else if (tokenResponse && tokenResponse.error) {
            console.error("Google token response contained an unexpected error:", tokenResponse);
            googleAccessToken = null; // Ensure token is null
            googleUser = null;
            if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined' && typeof gapi.client.setToken === 'function') {
                gapi.client.setToken(null);
            }
            driveFolderId = null;

            // Treat these as more serious failures needing the central error handler
             handleError("Google Sign-In Response Error", new Error(`Unexpected error from Google: ${tokenResponse.error || 'No error code'}: ${tokenResponse.error_description || 'Unknown'}`));
             setChatStatus("Sign-in Failed", false);
             updateDriveButtonVisibility(false); // Ensure buttons reflect failure
        } else {
             // --- Fallback for truly empty or unexpectedly structured responses ---
             console.warn("Google token response was empty or unexpectedly structured.", tokenResponse);
              googleAccessToken = null; // Ensure token is null
              googleUser = null;
              if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined' && typeof gapi.client.setToken === 'function') {
                  gapi.client.setToken(null);
              }
              driveFolderId = null;

              handleError("Google Sign-In Response Error", new Error("Received empty or invalid response from Google."));
              setChatStatus("Sign-in Failed", false);
              updateDriveButtonVisibility(false);
        }
    } // <-- End of handleGoogleTokenResponse function
    
    // Fetch basic Google User Info (optional, for displaying signed-in status)
    // Called after a successful login/re-auth and Drive API load.
    async function fetchGoogleUserInfo() {
        console.log("Fetching Google user info...");
        // Need to load oauth2 API module if not already loaded
        try {
            // Check if gapi.client is available and has a token before attempting API call
            if (typeof gapi === 'undefined' || typeof gapi.client === 'undefined' || typeof gapi.client.getToken !== 'function' || !gapi.client.getToken()) {
                console.warn("Gapi client not ready or no token available to fetch user info.");
                 return; // Exit if prerequisites are not met
            }
             // Load the oauth2 API module if it hasn't been loaded yet.
             // gapi.client.load uses promises and handles idempotency.
            await gapi.client.load('oauth2', 'v2')
                 .then(() => console.log("OAuth2 API v2 loaded for user info."))
                 .catch(err => console.error("Error loading OAuth2 API for user info:", err));

            // Check again if the oauth2 API is available after attempting load
             if (typeof gapi.client.oauth2 === 'undefined' || typeof gapi.client.oauth2.userinfo === 'undefined' || typeof gapi.client.oauth2.userinfo.get !== 'function') {
                 console.error("Google OAuth2 userinfo API not available after load attempt.");
                 return; // Exit if API is not available
             }

            // Make the API request to get user information
            const response = await gapi.client.oauth2.userinfo.get();
            googleUser = response.result; // Store user info globally
            console.log("Google User Info:", googleUser);

            // Display user name if element exists and user info is available
            signedInUserDisplayElement = signedInUserDisplayElement || document.getElementById('signedInUserDisplay');
            if (signedInUserDisplayElement && googleUser?.name) {
                signedInUserDisplayElement.textContent = `Signed in as: ${googleUser.name}`;
                signedInUserDisplayElement.style.display = 'inline-block'; // Make the span visible
                console.log(`Signed in user display updated: ${googleUser.name}`);
            } else if (signedInUserDisplayElement) {
                 // If element exists but no user name (e.g., email only or error), hide it
                 signedInUserDisplayElement.style.display = 'none';
                 signedInUserDisplayElement.textContent = ''; // Clear any old text
            }


        } catch (error) {
            console.error("Error fetching Google user info:", error);
            // If fetching user info fails, it's not a critical app error, just log it.
            // The UI will proceed without the user's name displayed.
        }
    }


    // Handle Google Sign Out
    // Revokes the access token and clears local Google-related state.
    function handleGoogleSignOut() {
        console.log("Signing out of Google...");
        // Check if we have a token and the GIS library is available to revoke it
        if (googleAccessToken && typeof google !== 'undefined' && typeof google.accounts !== 'undefined' && typeof google.accounts.oauth2 !== 'undefined' && typeof google.accounts.oauth2.revoke === 'function') {
            // Revoke the access token to invalidate it on Google's side
            google.accounts.oauth2.revoke(googleAccessToken, (revokeResponse) => {
                 console.log("Google access token revoke response:", revokeResponse); // Log revoke response from Google
                console.log("Google access token revoked successfully.");
                // Clear local state after successful revocation
                googleAccessToken = null;
                googleUser = null;
                 // Clear the token in gapi.client as well
                 if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined' && typeof gapi.client.setToken === 'function') {
                    gapi.client.setToken(null);
                    console.log("Token cleared in gapi.client.");
                    // Optionally clear the Drive API instance if needed, though typically not strictly necessary
                    // gapi.client.drive = undefined; // Or null
                 }
                console.log("Google sign out process complete.");

                // Update button visibility to hide Drive buttons and show sign-in button
                updateDriveButtonVisibility(false);
                 // Clear and hide the signed-in user display
                 signedInUserDisplayElement = signedInUserDisplayElement || document.getElementById('signedInUserDisplay');
                 if (signedInUserDisplayElement) {
                     signedInUserDisplayElement.textContent = '';
                     signedInUserDisplayElement.style.display = 'none';
                 }

                 // Clear the cached Drive folder ID as it's specific to the signed-in user/session
                 driveFolderId = null;
                 console.log("Drive folder ID cache cleared.");

                 // After signing out of Google, the user is back to a state where they need to load data.
                 // Show the initial upload prompt state again.
                 showInitialPromptOrMessage();
                 setChatStatus("Signed out of Drive", false); // Update chat status
            });
        } else {
            // If we don't have an access token or GIS is not available, we can't revoke.
            // Just clear local state and update UI.
            console.log("No Google access token or GIS library not available to revoke. Clearing local state only.");
            googleAccessToken = null;
            googleUser = null;
             if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined' && typeof gapi.client.setToken === 'function') {
                 gapi.client.setToken(null);
             }
             driveFolderId = null; // Clear cache
            // Update UI visibility
            updateDriveButtonVisibility(false);
             signedInUserDisplayElement = signedInUserDisplayElement || document.getElementById('signedInUserDisplay');
             if (signedInUserDisplayElement) {
                 signedInUserDisplayElement.textContent = '';
                 signedInUserDisplayElement.style.display = 'none';
             }
             // Show initial prompt state
             showInitialPromptOrMessage();
             setChatStatus("Signed out of Drive", false);
        }
    }

    // Update visibility of Google Drive related buttons and the user display span.
    // Called whenever the signed-in state or data loading state changes.
    function updateDriveButtonVisibility(isSignedIn) {
        // Ensure all relevant button and display elements are cached
        googleSignInButton = googleSignInButton || document.getElementById('googleSignInButton');
        googleSignOutButton = googleSignOutButton || document.getElementById('googleSignOutButton');
        loadFromDriveButton = loadFromDriveButton || document.getElementById('loadFromDriveButton');
        saveToDriveButton = saveToDriveButton || document.getElementById('saveToDriveButton');
        downloadLocalButton = downloadLocalButton || document.getElementById('downloadLocalButton'); // Local download fallback
        signedInUserDisplayElement = signedInUserDisplayElement || document.getElementById('signedInUserDisplay');


        console.log("Updating Drive button visibility. Signed in:", isSignedIn);

        // Toggle visibility of Sign-In and Sign-Out buttons based on signed-in state
        if (googleSignInButton) googleSignInButton.style.display = isSignedIn ? 'none' : 'inline-block';
        if (googleSignOutButton) googleSignOutButton.style.display = isSignedIn ? 'inline-block' : 'none';

        // Determine if dashboard data is currently loaded (needed for Save/Download)
        const isDataLoaded = dashboardData && dashboardData.userInput && Object.keys(getSafe(() => dashboardData.userInput, {})).length > 0;
         console.log("Data loaded:", isDataLoaded);


        // Load from Drive button is visible when signed in
        if (loadFromDriveButton) loadFromDriveButton.style.display = isSignedIn ? 'inline-block' : 'none';

        // Save to Drive button requires BOTH signed-in status AND data loaded
        if (saveToDriveButton) saveToDriveButton.style.display = (isSignedIn && isDataLoaded) ? 'inline-block' : 'none';

        // Local download button is visible whenever data is loaded (doesn't require sign-in)
        if (downloadLocalButton) downloadLocalButton.style.display = isDataLoaded ? 'inline-block' : 'none';

        // Display user info span only when signed in
        if (signedInUserDisplayElement) signedInUserDisplayElement.style.display = isSignedIn ? 'inline-block' : 'none';


        console.log("Button states updated:", {
             signIn: googleSignInButton?.style.display,
             signOut: googleSignOutButton?.style.display,
             load: loadFromDriveButton?.style.display,
             save: saveToDriveButton?.style.display,
             localDownload: downloadLocalButton?.style.display,
             signedInUserDisplay: signedInUserDisplayElement?.style.display
        });
    }

    // --- Manual File Upload Handler ---
     function handleManualFileUpload(event) {
         console.log("Manual file upload triggered.");
        const file = event.target.files[0];
        if (!file) {
            console.log("No file selected.");
             // Clear the file input even if no file was selected (e.g. user cancelled)
            event.target.value = '';
            return;
        }

        if (file.type !== 'application/json') {
            alert('Please upload a valid JSON file.');
            // Clear the file input so the same file can be selected again
            event.target.value = '';
            return;
        }

        const reader = new FileReader();
        reader.onloadstart = () => {
            console.log("Reading file...");
             hideAllMainContentAreas();
             if (loadingSpinner) loadingSpinner.style.display = 'flex';
             setChatStatus("Loading file...", true);
        };
        reader.onload = (e) => {
            console.log("File read successfully.");
            try {
                const fileContent = e.target.result;
                const parsedData = JSON.parse(fileContent);
                console.log("Parsed file content:", parsedData);

                // Validate loaded data structure - check for minimum required parts
                if (parsedData && parsedData.userInput && typeof parsedData.userInput === 'object' && parsedData.userInput.personalInfo) {
                    console.log("File content appears to be valid PSR data.");
                    // Data loaded from file overrides current context
                    // If metadata exists, use that for userId/tier, otherwise keep current
                    const userIdFromMetadata = getSafe(() => parsedData.metadata?.userId);
                    const tierFromMetadata = getSafe(() => parsedData.metadata?.tier);

                    if (userIdFromMetadata !== 'N/A' && userIdFromMetadata !== currentUserId) {
                        console.warn(`Overriding current user ID (${currentUserId}) with ID from file metadata: ${userIdFromMetadata}`);
                        currentUserId = userIdFromMetadata;
                    }
                     if (tierFromMetadata !== 'N/A' && tierFromMetadata !== effectiveTier) {
                         console.warn(`Overriding current tier (${effectiveTier}) with tier from file metadata: ${tierFromMetadata}`);
                          effectiveTier = tierFromMetadata;
                     }
                     // Ensure tier is valid if provided, default to basic
                    if (!['basic', 'pro'].includes(effectiveTier)) {
                        effectiveTier = 'basic';
                        console.warn("Invalid tier found in file metadata. Defaulting to basic.");
                    }

                     // Add source metadata
                    parsedData.metadata = parsedData.metadata || {};
                    parsedData.metadata.source = 'manual_upload';

                    processAndDisplayData(parsedData); // Process and display the loaded data
                    setChatStatus("File loaded successfully", false);
                     // Update button visibility now that data is loaded
                     updateDriveButtonVisibility(!!googleAccessToken);

                } else {
                    console.error("File content does not match expected PSR format.", parsedData);
                    throw new Error("Invalid file format. Please upload a valid SmartWealth Navigator PSR file.");
                }
            } catch (parseError) {
                 console.error("Error processing uploaded file:", parseError);
                 handleError("Error processing file", parseError);
            } finally {
                 // Clear the file input so the same file can be selected again after error
                 event.target.value = '';
            }
        };
        reader.onerror = (error) => {
            console.error("Error reading file:", error);
             handleError("Error reading file", new Error("Could not read the selected file."));
             // Clear the file input
             event.target.value = '';
        };
        reader.readAsText(file); // Read the file as text
     }

     // --- Local Download Handler ---
     function handleLocalDownload() {
         console.log("Initiating local download...");
         if (!dashboardData || !dashboardData.userInput) {
             alert("No data to download.");
             console.warn("Attempted local download with no dashboard data.");
             return;
         }

         try {
             // Ensure chat history is included in the data to be saved
             dashboardData.chatHistory = chatMessages.filter(msg => msg && msg.role && msg.content);
             // Ensure metadata is up-to-date, especially userId and tier
             dashboardData.metadata = dashboardData.metadata || {};
             dashboardData.metadata.userId = currentUserId;
             dashboardData.metadata.tier = effectiveTier;
             dashboardData.metadata.source = 'local_download_source'; // Add source info


             const dataStr = JSON.stringify(dashboardData, null, 2); // Pretty-print JSON
             const blob = new Blob([dataStr], { type: 'application/json' });
             const url = URL.createObjectURL(blob);

             const a = document.createElement('a');
             a.href = url;
             // Suggest a filename including user name and date
             const userName = getSafe(() => dashboardData.userInput.personalInfo.userName, 'Report').replace(/\s+/g, '_');
             const date = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
             a.download = `${userName}_PSR_${date}.json`;

             // Append to body, click, and remove
             document.body.appendChild(a);
             a.click();
             document.body.removeChild(a);

             URL.revokeObjectURL(url); // Clean up the object URL

             console.log("Local download initiated successfully.");
             setChatStatus("Report downloaded locally.", false); // Update status
             addMessageToChat("System", "Report downloaded locally.", false); // Add confirmation to chat

         } catch (e) {
             console.error("Error during local download:", e);
             setChatStatus("Download failed.", false); // Update status
             alert("Failed to download report: " + e.message);
              addMessageToChat("System", "Failed to download report locally.", true); // Add error to chat
         }
     }


    // --- Google Drive Handlers Implementation ---

    /**
     * Finds the designated SmartWealth Navigator Reports folder in Google Drive.
     * Creates the folder if it doesn't exist.
     * Stores the folder ID in the global `driveFolderId`.
     * @returns {Promise<string>} A promise that resolves with the folder ID.
     */
    async function findOrCreateDriveFolder() {
        console.log(`Attempting to find or create Drive folder: ${PSR_FOLDER_NAME}`);
        if (!gapi || !gapi.client || !gapi.client.drive) {
            console.error("Google Drive API client is not loaded for folder operation.");
            throw new Error("Google Drive API is not ready.");
        }

        if (driveFolderId) {
             console.log(`Folder ID already cached: ${driveFolderId}`);
             return driveFolderId; // Return cached ID if available
        }

        try {
            // 1. Search for the folder in the root
            const searchResponse = await gapi.client.drive.files.list({
                q: `name='${PSR_FOLDER_NAME}' and mimeType='application/vnd.google-apps.folder' and 'root' in parents and trashed=false`,
                spaces: 'drive',
                fields: 'files(id, name)',
                pageSize: 1
            });

            const files = searchResponse.result.files;

            if (files && files.length > 0) {
                // Folder found
                driveFolderId = files[0].id;
                console.log(`Found existing Drive folder: ${PSR_FOLDER_NAME} (ID: ${driveFolderId})`);
                return driveFolderId;
            } else {
                // 2. Folder not found, create it
                console.log(`Drive folder "${PSR_FOLDER_NAME}" not found. Creating...`);
                const fileMetadata = {
                    'name': PSR_FOLDER_NAME,
                    'mimeType': 'application/vnd.google-apps.folder',
                    'parents': ['root'] // Create in the root folder
                };
                const createResponse = await gapi.client.drive.files.create({
                    resource: fileMetadata,
                    fields: 'id'
                });

                driveFolderId = createResponse.result.id;
                console.log(`Created new Drive folder: ${PSR_FOLDER_NAME} (ID: ${driveFolderId})`);
                return driveFolderId;
            }
        } catch (error) {
            console.error("Error finding or creating Drive folder:", error);
            throw new Error(`Failed to access or create Google Drive folder "${PSR_FOLDER_NAME}". Please check Google Drive permissions.`);
        }
    }

    /**
     * Lists PSR files within the designated folder.
     * @returns {Promise<Array<Object>>} A promise that resolves with a list of files (id, name, modifiedTime).
     */
    async function listDriveFiles() {
        console.log(`Listing files in folder ID: ${driveFolderId}`);
        if (!gapi || !gapi.client || !gapi.client.drive || !driveFolderId) {
             console.warn("Google Drive API not ready or folder ID missing for listing.");
             throw new Error("Google Drive API is not ready or folder not accessible.");
        }

        try {
            // Search for files by name and mimeType within the specific folder
            const searchResponse = await gapi.client.drive.files.list({
                q: `name='${PSR_FILE_NAME}' and mimeType='${PSR_MIME_TYPE}' and '${driveFolderId}' in parents and trashed=false`,
                spaces: 'drive',
                fields: 'files(id, name, modifiedTime)',
                orderBy: 'modifiedTime desc', // Order by modification time descending
                pageSize: 10 // Get up to 10 files with the same name (should ideally be only one)
            });

            const files = searchResponse.result.files;
            console.log(`Found ${files ? files.length : 0} files matching "${PSR_FILE_NAME}".`, files);
            return files || [];

        } catch (error) {
            console.error("Error listing Drive files:", error);
             // Provide more specific error message based on Google API error structure
            let userFacingError = "Failed to list files from Google Drive.";
             if (error.result?.error?.message) {
                 userFacingError = `Google Drive Error: ${error.result.error.message}`;
             }
            throw new Error(userFacingError);
        }
    }

     /**
     * Loads the content of a specific file from Google Drive.
     * @param {string} fileId The ID of the file to load.
     * @returns {Promise<Object>} A promise that resolves with the parsed JSON content of the file.
     */
    async function loadDriveFileContent(fileId) {
        console.log(`Loading file content for file ID: ${fileId}`);
        if (!gapi || !gapi.client || !gapi.client.drive) {
             console.error("Google Drive API client is not loaded for content loading.");
             throw new Error("Google Drive API is not ready.");
        }

        try {
            // Use alt=media to download the file content
            const response = await gapi.client.drive.files.get({
                fileId: fileId,
                alt: 'media'
            });

            // The response.result contains the file content (as text for JSON)
            console.log("Raw file content received (first 200 chars):", String(response.body).substring(0, 200) + '...');

            try {
                const fileContent = JSON.parse(response.body); // Assuming the content is JSON
                console.log("Parsed file content from Drive:", fileContent);
                return fileContent;
            } catch (parseError) {
                 console.error("Error parsing file content as JSON:", parseError);
                 throw new Error("Failed to parse the file content as JSON. It might be corrupted.");
            }

        } catch (error) {
            console.error("Error loading file content from Drive:", error);
             // Check if the error indicates permission issues (e.g., 403) or file not found (404)
             let userFacingError = "Failed to load file from Google Drive.";
             if (error.result?.error?.code === 403) {
                 userFacingError = "Permission denied to access this file in Google Drive. Please check your Google account permissions.";
             } else if (error.result?.error?.code === 404) {
                 userFacingError = "File not found in Google Drive. It may have been moved or deleted.";
             } else if (error.result?.error?.message) {
                  userFacingError = `Google Drive Error: ${error.result.error.message}`;
             } else if (error.message) {
                  userFacingError = `Load Error: ${error.message}`;
             }
            throw new Error(userFacingError);
        }
    }


    /**
     * Saves the current dashboardData as a JSON file to the designated Drive folder.
     * Updates the existing file if found, otherwise creates a new one.
     * @returns {Promise<void>} A promise that resolves when the file is saved.
     */
    async function saveFileToDrive() {
        console.log("Attempting to save file to Google Drive...");

        if (!dashboardData || !dashboardData.userInput) {
             throw new Error("No dashboard data available to save.");
        }
        if (!gapi || !gapi.client || !gapi.client.drive || !googleAccessToken) {
             console.error("Google Drive API is not ready or user is not signed in for saving.");
             throw new Error("Google Drive API is not ready or user is not signed in.");
        }

        // Ensure chat history is included in the data to be saved
         dashboardData.chatHistory = chatMessages.filter(msg => msg && msg.role && msg.content);
        // Ensure metadata is up-to-date, especially userId and tier
        dashboardData.metadata = dashboardData.metadata || {};
        dashboardData.metadata.userId = currentUserId;
        dashboardData.metadata.tier = effectiveTier;
        dashboardData.metadata.source = 'google_drive_source'; // Add source info


        const fileContent = JSON.stringify(dashboardData, null, 2);
        const blob = new Blob([fileContent], { type: PSR_MIME_TYPE });

        let fileIdToUpdate = null;

        try {
            // 1. Ensure the folder exists and get its ID
            const folderId = await findOrCreateDriveFolder();
            console.log("Drive folder ID for saving:", folderId);

            // 2. Search for an existing file with the standard name in this folder
            const existingFiles = await listDriveFiles(); // listDriveFiles already filters by name/type/parent

            if (existingFiles && existingFiles.length > 0) {
                // Found existing file(s) - use the first one (most recent if list was ordered)
                fileIdToUpdate = existingFiles[0].id;
                console.log(`Found existing file "${PSR_FILE_NAME}" (ID: ${fileIdToUpdate}). Will update.`);
            }

            // 3. Prepare the request body (metadata is separate in multipart)
            const fileMetadata = {
                'name': PSR_FILE_NAME,
                'mimeType': PSR_MIME_TYPE,
                // Specify parents ONLY when creating (POST), not when updating (PATCH)
                ...(fileIdToUpdate ? {} : { 'parents': [folderId] })
            };

            // Use multipart upload for file content
            const form = new FormData();
            form.append('metadata', new Blob([JSON.stringify(fileMetadata)], { type: 'application/json' }));
            form.append('file', blob);

            // Determine the API endpoint and method (update or create)
            const path = fileIdToUpdate ? `/upload/drive/v3/files/${fileIdToUpdate}` : `/upload/drive/v3/files`;
            const method = fileIdToUpdate ? 'PATCH' : 'POST'; // Use PATCH to update, POST to create

            console.log(`Executing Drive file ${fileIdToUpdate ? 'update (PATCH)' : 'create (POST)'} request...`);

            // 4. Execute the request using gapi.client.request
            const response = await gapi.client.request({
                path: path,
                method: method,
                params: { uploadType: 'multipart' }, // Indicate multipart upload
                headers: { 'Authorization': `Bearer ${googleAccessToken}` }, // Ensure Authorization header is set
                body: form
            });

            console.log(`Drive file ${fileIdToUpdate ? 'updated' : 'created'} successfully:`, response.result);
            // The response.result will contain the file metadata including the ID

        } catch (error) {
            console.error("Error saving file to Drive:", error);
             // Provide more specific error messages if possible
            let userFacingError = "Failed to save file to Google Drive.";
             if (error.message.includes("Google Drive API is not ready") || error.message.includes("not signed in")) {
                 userFacingError = "Please sign in to Google Drive first.";
             } else if (error.message.includes("Failed to access Google Drive folder")) {
                 userFacingError = error.message; // Use the specific folder error message
             } else if (error.result?.error?.message) {
                 userFacingError = `Google Drive Error: ${error.result.error.message}`;
             } else if (error.message) {
                  userFacingError = `Save Error: ${error.message}`;
             }
            throw new Error(userFacingError);
        }
    }

     /**
      * Handles the click event for the "Load from Drive" button.
      * Finds the folder, lists relevant files, and initiates loading the standard file.
      * Opens a modal to select if multiple files with the same name are found (unlikely but possible).
      */
     async function handleLoadFromDriveClick() {
         console.log("handleLoadFromDriveClick triggered.");
         if (!gapi || !gapi.client || !gapi.client.drive || !googleAccessToken) {
             console.warn("Google Drive not signed in or API not ready.");
             alert("Please sign in to Google Drive first.");
             return;
         }

         // Show loading state
         hideAllMainContentAreas(); // Hide existing content
         if (loadingSpinner) loadingSpinner.style.display = 'flex';
         setChatStatus("Searching Drive for file...", true);

         const driveLoadModal = document.getElementById('driveLoadModal');
         const driveFileListDiv = document.getElementById('driveFileList');
         const driveLoadErrorP = document.getElementById('driveLoadError');

         if (driveFileListDiv) driveFileListDiv.innerHTML = 'Searching...';
         if (driveLoadErrorP) driveLoadErrorP.textContent = '';


         try {
             // 1. Ensure the folder exists
             const folderId = await findOrCreateDriveFolder();

             // 2. List files in the folder matching the standard name
             const files = await listDriveFiles();

             if (!files || files.length === 0) {
                 console.log("No PSR file found in Drive folder.");
                 if (loadingSpinner) loadingSpinner.style.display = 'none'; // Hide spinner
                 showInitialPromptOrMessage("No SmartWealth Navigator file found in your Google Drive. You can upload a local file or generate a new report.");
                 setChatStatus("No file found in Drive", false);
                 // Re-initialize chat (it will be disabled if no data is loaded but auth is ok)
                 initializeChat(); // Ensure chat UI state is correct

                 // Update button visibility (Load button should still be visible if signed in)
                 updateDriveButtonVisibility(!!googleAccessToken);

                 return; // Exit function
             }

             // 3. Handle multiple files or load the first one found
             if (files.length > 1) {
                 console.warn(`Found multiple files (${files.length}) named "${PSR_FILE_NAME}". Presenting options.`);
                 // Sort files by modification time (most recent first)
                 files.sort((a, b) => new Date(b.modifiedTime).getTime() - new Date(a.modifiedTime).getTime());

                 if (driveFileListDiv) {
                     driveFileListDiv.innerHTML = '<p class="mb-2">Multiple files found with the same name. Please select one (most recent first):</p>';
                     files.forEach(file => {
                         const modifiedDate = new Date(file.modifiedTime).toLocaleString();
                         const fileLink = document.createElement('a');
                         fileLink.href = '#';
                         fileLink.textContent = `${file.name} (Modified: ${modifiedDate})`;
                         fileLink.style.display = 'block';
                         fileLink.style.marginBottom = '5px';
                         // Use a data attribute or closure to pass the file ID to the click handler
                         fileLink.dataset.fileId = file.id;
                         fileLink.onclick = async (e) => {
                             e.preventDefault();
                             const selectedFileId = e.target.dataset.fileId; // Get ID from data attribute
                             console.log(`User selected file ID: ${selectedFileId}`);
                             closeModal('driveLoadModal'); // Close selection modal
                             // Add a slight delay before starting the load process to ensure modal closes visually
                             setTimeout(() => performFileLoad(selectedFileId), 100);
                         };
                         driveFileListDiv.appendChild(fileLink);
                     });
                 }
                 if (driveLoadErrorP) driveLoadErrorP.textContent = ''; // Clear previous error message

                 if (loadingSpinner) loadingSpinner.style.display = 'none'; // Hide spinner
                 setChatStatus("Select file to load", false);
                 openModal('driveLoadModal'); // Open modal for selection

             } else {
                 // Only one file found, load it directly
                 const fileToLoad = files[0];
                 console.log(`Found single file to load: "${fileToLoad.name}" (ID: ${fileToLoad.id}). Loading...`);
                 closeModal('driveLoadModal'); // Ensure modal is closed if open
                 // Add a slight delay before starting the load process
                 setTimeout(() => performFileLoad(fileToLoad.id), 50);
             }

         } catch (error) {
             console.error("Error during Load from Drive initial steps:", error);
             if (loadingSpinner) loadingSpinner.style.display = 'none'; // Hide spinner
             setChatStatus("Load failed", false);
             // Update error message in modal if it's still open, otherwise use main error handler
             if(driveLoadModal && driveLoadModal.style.display === 'block' && driveLoadErrorP) {
                 driveLoadFileListDiv.innerHTML = ''; // Clear file list
                 driveLoadErrorP.textContent = `Error: ${error.message || 'Unknown error'}`;
                 setChatStatus("Error listing files", false);
             } else {
                 handleError("Failed to search or list files from Google Drive", error);
             }
         }
         // Note: Spinner hiding and status are managed within performFileLoad or handleError
     }

     /**
      * Performs the actual file loading and data processing after a file ID is selected/identified.
      * @param {string} fileId The ID of the file to load.
      */
     async function performFileLoad(fileId) {
         console.log(`Initiating file load for ID: ${fileId}`);
         hideAllMainContentAreas(); // Ensure everything is hidden before showing spinner
         if (loadingSpinner) loadingSpinner.style.display = 'flex';
         setChatStatus("Loading file content...", true);

         try {
             const fileContent = await loadDriveFileContent(fileId);

             console.log("Processing loaded data from Drive file...");

             // Validate loaded data structure
             if (fileContent && fileContent.userInput && typeof fileContent.userInput === 'object' && fileContent.userInput.personalInfo) {
                  console.log("Loaded file content is valid PSR data. Updating dashboard.");
                  // Data loaded from file overrides current context
                  // Prefer userId/tier from file metadata if present and valid
                 const userIdFromMetadata = getSafe(() => fileContent.metadata?.userId);
                 const tierFromMetadata = getSafe(() => fileContent.metadata?.tier);

                 if (userIdFromMetadata !== 'N/A' && userIdFromMetadata !== currentUserId) {
                     console.warn(`Overriding current user ID (${currentUserId}) with ID from file metadata: ${userIdFromMetadata}`);
                     currentUserId = userIdFromMetadata;
                 }
                  if (tierFromMetadata !== 'N/A' && tierFromMetadata !== effectiveTier) {
                      console.warn(`Overriding current tier (${effectiveTier}) with tier from file metadata: ${tierFromMetadata}`);
                       effectiveTier = tierFromMetadata;
                  }
                  // Ensure tier is valid if provided, default to basic
                 if (!['basic', 'pro'].includes(effectiveTier)) {
                     effectiveTier = 'basic';
                     console.warn("Invalid tier found in file metadata. Defaulting to basic.");
                 }


                  // Add source metadata
                 fileContent.metadata = fileContent.metadata || {};
                 fileContent.metadata.source = 'google_drive_loaded';


                 processAndDisplayData(fileContent); // This handles hiding spinner and showing main content
                 setChatStatus("Loaded from Drive", false);

             } else {
                 console.error("Loaded file content does not match expected PSR format.", fileContent);
                 throw new Error("The file from Google Drive is not a valid SmartWealth Navigator report.");
             }

         } catch (error) {
             console.error("Error during file load process:", error);
             if (loadingSpinner) loadingSpinner.style.display = 'none'; // Hide spinner
             setChatStatus("Load failed", false);
             handleError("Failed to load file from Google Drive", error);
         } finally {
             // Spinner hiding is done within try/catch or by handleError
             // Button visibility is updated by processAndDisplayData or handleError
         }
     }


     /**
      * Handles the click event for the "Save to Drive" button.
      * Initiates the process of saving the current dashboardData to the standard file.
      */
     async function handleSaveToDriveClick() {
         console.log("handleSaveToDriveClick triggered.");

         if (!dashboardData || !dashboardData.userInput) {
             alert("No dashboard data to save.");
             console.warn("Attempted Save to Drive with no dashboard data.");
             return;
         }
         if (!gapi || !gapi.client || !gapi.client.drive || !googleAccessToken) {
             alert("Please sign in to Google Drive first.");
              console.warn("Google Drive not signed in or API not ready for saving.");
             return;
         }

         // Provide immediate feedback to the user
         setChatStatus("Saving to Drive...", true);
         // Disable save button to prevent multiple clicks
         if (saveToDriveButton) saveToDriveButton.disabled = true;
         if (loadFromDriveButton) loadFromDriveButton.disabled = true; // Disable load during save


         try {
             await saveFileToDrive();
             console.log("File saved to Drive successfully.");
             setChatStatus("Saved to Drive ✅", false);
             addMessageToChat("System", "Your report has been saved to Google Drive.", false); // Add confirmation to chat

         } catch (error) {
             console.error("Error during Save to Drive process:", error);
             setChatStatus("Save failed", false);
             addMessageToChat("System", "Failed to save report to Google Drive: " + (error.message || "Unknown error"), true); // Add error to chat
             // Optionally show a more detailed error modal
             // handleError("Failed to save to Google Drive", error); // Can call this for critical errors
         } finally {
             // Re-enable buttons
             if (saveToDriveButton) saveToDriveButton.disabled = false;
             if (loadFromDriveButton) loadFromDriveButton.disabled = false;
             // Status message will auto-clear or stay if error
         }
     }


    // --- MAIN Document Ready Event ---
    document.addEventListener('DOMContentLoaded', function() {
        console.log("DOM fully loaded. Initializing application...");

        // --- 1. Cache Global DOM Elements ---
        // Cache them safely, check for null later if needed
        loadingSpinner = document.getElementById('loadingSpinner');
        errorMessageElement = document.getElementById('errorMessage');
        mainContentElement = document.getElementById('mainContent');
        initialMessageElement = document.getElementById('initialMessage');
        initialUploadPrompt = document.getElementById('initialUploadPrompt');
        errorTextElement = document.getElementById('errorText');
        debugInfoElement = document.getElementById('debugInfo');
        fileInput = document.getElementById('fileInput');
        chatInterfaceCardElement = document.getElementById('chatInterfaceCard'); // Cache chat card

        // Cache Google Drive buttons and user display element
        googleSignInButton = document.getElementById('googleSignInButton');
        googleSignOutButton = document.getElementById('googleSignOutButton');
        loadFromDriveButton = document.getElementById('loadFromDriveButton');
        saveToDriveButton = document.getElementById('saveToDriveButton');
        downloadLocalButton = document.getElementById('downloadLocalButton');
        signedInUserDisplayElement = document.getElementById('signedInUserDisplay');


        // --- 2. Set Initial UI State ---
        // Hide all main content areas first, then show spinner
        hideAllMainContentAreas();
        if (loadingSpinner) {
            loadingSpinner.style.display = 'flex'; // Use flex for centering spinner
            console.log("Spinner shown.");
        } else {
             console.error("Loading spinner element not found!");
             // Cannot show spinner, proceed with caution
        }


        // --- 3. Initialization Flow ---
        try {
            // Get URL parameters once
            const params = parseUrlParams();

            // Check for the 'data=null' special case first (from Jotform redirect without data)
            if (params === null) {
                // parseUrlParams already logged warning.
                console.log("'data=null' param detected. Showing initial upload prompt.");
                if (loadingSpinner) loadingSpinner.style.display = 'none';
                showInitialPromptOrMessage();
                initializeSupabaseAndCoreFeatures(); // Initialize other features (buttons, modals, maybe Supabase client, Google APIs)
                return; // Stop main initialization flow
            }

            // Parse the xtl parameter FIRST to get userId and effectiveTier
            const xtlParsedSuccessfully = parseXtlParameter(params);

            // Parse financial data from URL parameters regardless of XTL success
            // This sets initial dashboardData (might be null if no params except xtl/userID)
            dashboardData = parseDataFromUrlParams(params);

            // Initialize Supabase and core features (buttons, modals, Google APIs etc.)
            // This also triggers fetchInitialUsage and subsequent chat initialization,
            // AND initiates Google API loading (which will manage sign-in button visibility).
            initializeSupabaseAndCoreFeatures();


            // Determine which main content state to show based on data and auth status
            if (dashboardData && dashboardData.userInput && Object.keys(dashboardData.userInput).length > 0 && dashboardData.userInput.personalInfo) {
                 // Data was successfully parsed from URL params
                 console.log("Dashboard data parsed from URL. Processing and displaying.");
                 // Update metadata source for loaded data (already done in parseDataFromUrlParams)
                 processAndDisplayData(dashboardData); // This handles showing mainContent and hiding spinner, and setting chat state
            } else if (xtlParsedSuccessfully && currentUserId) {
                 // No dashboard data from URL, but XTL was valid.
                 // Show the main container structure as a shell, waiting for file upload/load from Drive.
                 // This state should typically auto-trigger Load from Drive if the user is signed in.
                 console.log("No dashboard data in URL, but XTL valid. Showing empty main content shell and waiting for user action or Drive auto-load.");
                 hideAllMainContentAreas();
                 if (mainContentElement) {
                    mainContentElement.style.display = 'block';
                    mainContentElement.classList.remove('hidden');
                 } else {
                     console.error("Main content element not found!");
                     handleError("Critical: Main content element not found.", new Error("DOM element #mainContent is missing."));
                     return; // Cannot proceed without main content
                 }
                 // Update UI elements to show "N/A" or default states explicitly
                 updateReportBasics({}, {}); // Pass empty objects to reset UI
                 updateRatiosDisplay({});
                 updateGoalsDisplay({}, {});
                 updateDebtsDisplay({}, {});
                 updateUIDisplayFromAI({});
                 renderCharts({}); // Attempt to render empty charts or messages

                 if (loadingSpinner) loadingSpinner.style.display = 'none'; // Hide spinner
                 // Button visibility updated by initializeSupabaseAndCoreFeatures -> loadGoogleAPIs -> initializeGIS
                 // Auto-loading from Drive is attempted in handleGoogleTokenResponse after successful sign-in

            } else {
                 // No dashboard data from URL and no valid XTL.
                 console.log("No dashboard data or valid XTL. Showing initial prompt/message.");
                 if (loadingSpinner) loadingSpinner.style.display = 'none'; // Hide spinner
                 showInitialPromptOrMessage(); // Show the upload prompt or generic message
                 // Error message might already be showing if XTL parse failed (handleInvalidAccess)
                 // Button visibility handled by showInitialPromptOrMessage
            }


        } catch (error) {
            console.error("CRITICAL Error during initial setup:", error);
            // Use the central error handler for any unexpected errors during setup
            handleError("Critical Initialization Error", error);
        } finally {
            // The spinner hiding is now managed by the specific display paths (processAndDisplayData, handleError, showInitialPromptOrMessage).
            console.log("DOMContentLoaded finally block finished.");
        }
         // Add the resize listener outside the try/catch/finally to ensure it's always added
         window.addEventListener('resize', handleResize);
         console.log("Window resize listener added.");
    });


</script>

</body>
</html>
